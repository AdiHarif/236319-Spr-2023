diff --git a/Mini-LISP/S.h b/Mini-LISP/S.h
index 43bd42d..0cd51b9 100644
--- a/Mini-LISP/S.h
+++ b/Mini-LISP/S.h
@@ -1,7 +1,7 @@
 #include <cstdint>
 #include <iostream>
-#ifndef MINI_LISP_H
-#define MINI_LISP_H 
+#ifndef S_H
+#define S_H 
 
 #include "hacks.h"
 
@@ -54,7 +54,6 @@ namespace Strings {
 
 union S; 
 
-
 /* An S expression is identified by a 16 bits handle (the type H).
  * It is an atom is the handle is non-positive (the index zero is 
  * reserved for the special NIL atom). It is an internal node */
@@ -63,8 +62,6 @@ representation S { // Representation of an S expression
   perspective(H handle)
   construct S(H h) by (handle(h));
   property String asAtom() returns  (Strings::pool + handle)
-
-
   construct S(S car, S cdr) by(handle(Pairs::allocate(car.handle,cdr.handle)))
   construct S(String s) by(handle(Strings::allocate(s)))
 
@@ -109,7 +106,9 @@ auxiliary fluentons.
   bool null() const; /// sink: Atomic function of Mini-Lisp 
   bool t() const;    /// sink: Auxiliary fluenton, complements null
   S car() const;     /// atomic function of Mini-Lisp 
+  S rac() const;     /// auxiliary: same as car, except no checking is made 
   S cdr() const;     /// atomic function of Mini-Lisp 
+  S rdc() const;     /// auxiliary: same as car, except no checking is made 
   S eval() const;    /// atomic function of Mini-Lisp 
   S q() const;       /// implements library functions quote
   S l() const;       /// returns a singleton list containing this S expression 
@@ -135,7 +134,6 @@ auxiliary fluentons.
   S $2$() const;  /// second element in a list
   S $3$() const;  /// third element in a list
 };
-
 #undef NULL
 // Fluenton sources of Names of atoms that represent atomic functions 
 extern const S NIL, T; //
@@ -154,4 +152,4 @@ extern const S MISSING, REDUNDANT, UNDEFINED, INVALID, BUG, EMPTY, EXHAUSTED;
 inline bool die(S s) { throw BUG.cons(s); }
 
 #undef construct
-#endif // MINI_LISP_H 
+#endif // S_H 
diff --git a/Mini-LISP/a-list.h b/Mini-LISP/a-list.h
index b4566f9..283c14a 100644
--- a/Mini-LISP/a-list.h
+++ b/Mini-LISP/a-list.h
@@ -1,6 +1,6 @@
 #ifndef A_LIST
 #define A_LIST
-#include "00.h"
+#include "S.h"
 extern S alist ;
 extern S set(S name, S value);
 extern S lookup(S id, S alist);
diff --git a/Mini-LISP/basics.h b/Mini-LISP/basics.h
index f574018..469e85f 100644
--- a/Mini-LISP/basics.h
+++ b/Mini-LISP/basics.h
@@ -1,6 +1,6 @@
 #ifndef BASICS_H
 #define BASICS_H
-#include "00.h"
+#include "S.h"
 
 inline bool exists(S x, S xs) { return !xs.null() && (xs.car().eq(x) || exists(x, xs.cdr())); } 
 inline bool islist(S s) { return s.null() || !s.atom() && islist(s.cdr()); }
diff --git a/Mini-LISP/diff b/Mini-LISP/diff
index 411f853..e69de29 100644
--- a/Mini-LISP/diff
+++ b/Mini-LISP/diff
@@ -1,418 +0,0 @@
-diff --git a/Mini-LISP/Makefile b/Mini-LISP/Makefile
-index fe949b4..675c2fe 100644
---- a/Mini-LISP/Makefile
-+++ b/Mini-LISP/Makefile
-@@ -47,11 +47,13 @@ endif
- 
- CFLAGS += -MD -MP -w 
- 
--test: $(TEST_OBJS)
-+store: store.o words.o characters.o
- 	$(CXX) $(LDFLAGS) -o $@ $^ -lgtest -lpthread
- 
-+test: $(TEST_OBJS)
-+	$(CXX) $(LDFLAGS) -o $@ $^ -lgtest -lpthread
- 
--all: test mini-lisp 
-+all: test mini-lisp store 
- 
- dump.cc: dump.h
- 
-@@ -64,8 +66,6 @@ dump.cc: dump.h
- mini-lisp: mini-lisp.o	$(OBJS) 
- 	$(CXX) $(LDFLAGS) -o $@ $^ 
- 
--store: store.o
--	$(CXX) $(LDFLAGS) -o $@ $^ -lgtest -lpthread
- 
- 
- # -include $(SRC:%.c=%.d)
-diff --git a/Mini-LISP/chic.h b/Mini-LISP/chic.h
-index 7011486..70a94ab 100644
---- a/Mini-LISP/chic.h
-+++ b/Mini-LISP/chic.h
-@@ -27,5 +27,6 @@
- #define	returns(x) const {return x;}
- #define by(...) :__VA_ARGS__{}
- 
--#define max(x,y) (x > y ? x : y) 
--#define min(x,y) (x < y ? x : y) 
-+template<typename T> constexpr T max(T h1, T h2) { return h1 > h2 ? h1 : h2; } 
-+template<typename T> constexpr T min(T h1, T h2) { return h1 < h2 ? h1 : h2; } 
-+template<typename T> constexpr T range(T h1, T h2) { return h2 - h1 + 1; } 
-diff --git a/Mini-LISP/store.cc b/Mini-LISP/store.cc
-index ccade6f..5cafd1c 100644
---- a/Mini-LISP/store.cc
-+++ b/Mini-LISP/store.cc
-@@ -1,231 +1,54 @@
--#include "chic.h"
-+#include "store.h"
- 
--/*@ The Primitive Types@
--Our byte addressable underlining machine offers three primitive types: byte,
--half, and, word whose sizes are 8, 16, and 32 bits respectively.  These types
--are fixed width signed integers, represented in two's complement, and are
--similar to the types byte, short, and int of the Java virtual machine. Punning
--is allowed, and used extensively: A word is constituted by two consecutive
--halves. No particular byte or halves ordering is assumed. */
- 
--typedef int8_t  byte; /// JVM's byte              |  8 bits signed integer | character in an atom
--typedef int16_t Half; /// Half a word/JVM's short | 16 bits signed integer | handle of an S-expression 
--typedef int32_t Word; /// Machine word/JVM's int  | 32 bits signed integer | an dotted pair S-expression   
--
--/*@ Types for S-Expressions@ S-Expressions come in two varieties: (1) Dotted
-- pairs (pairs for short) are compound S-expressions defined by two, smaller,
-- S-expressions, and (2) atoms, which are a sequence of characters. 
--
-- The type is represents S-expressions of both kinds.  However, this type not
-- store the actual data of an S-expression, but rather a handle to this data.
-- When the handle is used to access the data, we obtain a value whose type is
-- either Atom or Pair */
--
--Type S;     // An S-expression represented by its handle
--Type Pair;  // A compound S-expression, i.e., a dotted pair
--// Type Atom;  // An atomic S-expression, i.e., a memory address
--
--
--/*@ Types for S-Expressions@ S-Expressions come in two varieties: 
--An atomic S-expression is a C like string: a memory address of a byte storing
--the first character, of the atom's text. The full text of an atom
--are the characters in this byte and all bytes that follow  until the first 
--occurrence of the null byte, i.e., a byte in which all bits are zero, 
--denoted in C by \verb/'\0'/ and mathematically by~$\natural$.  */
--
--typedef const char *const Atom; // Underlining representation of atoms as pointers to characters
--Type S;
--Type Pair;
--
--Type S { // An S-expression represented by its handle
--  Representation {
--    perspective(Half handle) // The inner representation 
--  };
--  // construct S(Half h) by (handle(h));
--  property bool null() returns (handle == 0)
--  property bool atom() returns (handle <= 0)
--  property bool pair() returns (handle > 0) 
--  property bool eq(S s) returns (atom() && handle == s.handle)
--  S(Half h): handle(h) {} 
--  property Pair $_p$(); /// Interpreted as handle of pair, retrieves the pair behind (mutable)  
--  property Atom $_a$(); /// Interpreted as handle of atom, retrieves its text representation 
--};
--
--Type Pair { // The different perspectives of a pair.
--  Representation {
--    perspective(Word cons)        /// I.   | A single word with two halves: 
--    perspective(Half car, cdr)    /// II.  | A pair of car and cdr, each in a half word.
--    perspective(Half prev, next)  /// III. | An unused pair item in the list of pairs. 
--    perspective(Half head, rest)  /// IV.  | An data item in the stack used in the parser. 
--  };
--};
--
--/*@ The Store$ 
--The store provides an abstract memory model that manages the allocation and 
--delallocation of S-expressions objects. These come in two varieites: Atomic 
--S-expressions, the Pair,
--whihstorage two kinds of entities:
--the Pair, which represents 
--fo higher levels of the . However, other portions of the implementation need
--not worry about
--the details of the frugality. Here we present an abstract model of a 
--``store'' and the services it provides. 
--*/
--
--Context Store {
--  Provides function S make(S car, S cdr); /// Returns (handle of) pair with given values of (handles of) its two components
--  Provides function S make(Atom);         /// Returns (handle of) atom with given text; 
--  Provides procedure free(S);             /// Marks an S-expression handle previously returned by make as no longer in use 
--}
--
--Context Store { 
--  // Global:
--  Provides constant(Word) $m$;    /// how many bytes are used by the store 
--  // Atoms:
--  Provides constant(Half) $M_a$;  /// how many atoms are initially available 
--  Provides function Half $v_a$(); /// how many chars remain available for allocation 
--  Provides function Half $u_a$(); /// how many chars were allocated 
--  Allocate Half current = 0;
--  // Pairs
--  Provides constant(Half) $M_p$;  /// how many pairs are initially available 
--  Provides function Half $v_p$(); /// how many pairs remain available for allocation 
--  Provides function Half $u_p$(); /// how many pairs were allocated 
--}
--
--Context Store { // Prototype for store.h
--  Provides data array(char) A;
--  Provides data array(Pair) P;
--}
--
--Context Store { 
--  Let Half $M_a$ = 1 << 12;
--  Let Half $M_p$ = (1 << 15) - $M_a$ + 3; 
--  Let Word $m$ = $M_a$ + $M_p$ * sizeof (Pair);
--  Let Half NIL_SIZE = sizeof "NIL";
--}
--
--Allocate static union  {
--  char block[Store::$m$];
-+Let Word $m$ = $M_a$ + $M_p$ * sizeof (Pair);
-+static union  {
-+  char block[$m$];
-   struct {
--   char $A_0$[Store::$M_a$ - Store::NIL_SIZE];
--   char A[Store::NIL_SIZE] = { 'N', 'I', 'L', '\0' };
--   Pair P[Store::$M_p$];
-+   char $A_0$[$M_a$ - LIMBO];
-+   char A[LIMBO] = { 'N', 'I', 'L', '\0' };
-+   Pair P[$M_p$];
-   };
- } memory; 
- 
--Context Store { 
--  using Context Store;
--constexpr auto x =3;
--constexpr auto y = x *x;
--  Let array(Pair) P = memory.P - 1;
--  Let array(Pair) $P_0$ = memory.P - 1;
--  Let array(Pair) $P_1$ = memory.P + $M_p$;
--  Let array(char) A  = memory.A;
--  Let array(char) $A_0$  = memory.$A_0$;
--  Let array(char) $A_1$  = memory.A + $M_a$;
--  Let Half $L_a$ = $A_0$ - A, $H_a$ = 0;   
--  Let Half $L_p$ = memory.P - P, $H_p$ = $P_1$ - memory.P;   
--  Let Half $L$ = min($L_a$, $L_p$ ), $H$ = max($H_a$, $H_p$);
--  Let Half $N_p$ = $H_p$ - $L_p$ + 1;
--  Let Half $N_a$ = $H_a$ - $H_a$ + 1;
--  Let Half $N$ = $H$ - $L$ + 1;
--  Half  
--}
--
-+Let array(Pair) P = memory.P - 1;
-+Let array(Pair) $P_0$ = memory.P - 1;
-+Let array(Pair) $P_1$ = memory.P + $M_p$;
-+Let array(char) A  = memory.A;
-+Let array(char) $A_0$  = memory.$A_0$;
-+Let array(char) $A_1$  = memory.A + $M_a$;
-+// Let Half $A_f$ = $A_0$ - A, $A_t$ = 0;   
-+// Let Half $P_f$ = memory.P - P, $P_t$ = $P_1$ - memory.P;   
-+// Let Half $N_p$ = $P_t$ - $P_f$ + 1;
-+// Let Half $N_a$ = $A_t$ - $A_t$ + 1;
- 
--Context Store {   
--}
- 
--Context Store {
--  Half flip(Half h)   { return h + (1 << 15); } 
--  bool red(Half h) { return h < $L$ || h > $H$; } 
--  void flip(Pair &p)  { Pair.car = flip(p.car); }
--  bool red(Pair p) { return red(p.car);  }
--}
-+// Provides Half $A_f$ = $A_0$ - A, $A_t$ = 0;   
-+// Provides Half $P_f$ = memory.P - P, $P_t$ = $P_1$ - memory.P;   
-+// Let Half $L$ = min($A_f$, $P_f$ ), $H$ = max($A_t$, $P_t$);
- 
--/* Making an S expression from an input string is by moving the pool pointer
-- * down and then copying the input there. A bit of optimization saves some
-- * space by refraining from allocating the same string twice; moreover, there
-- * is also a minimal attempt to allow one string to be realizes the suffix of a
-- * previously allocated string */ 
- 
--static Half size(const char *s) { for (Half $ = 0;; ++$) if (s[$] == '\0') return $ + 1; }
--static char upper(char c) { return c < 'a' || c > 'z' ? c : c - 'a' + 'A'; }
--static bool eq(const char *s1, const char *s2) {
--  for (; upper(*s1) == upper(*s2); ++s1, ++s2)
--    if (*s1 == '\0')
--      return true;
--  return false;
--}
-+// Global:
-+Provides constant(Word) $m$;    /// how many bytes are used by the store 
-+// Atoms:
-+Provides constant(Half) $M_a$;  /// how many atoms are initially available 
-+Provides function Half $v_a$(); /// how many chars remain available for allocation 
-+Provides function Half $u_a$(); /// how many chars were allocated 
-+// Pairs
-+Provides constant(Half) $M_p$;  /// how many pairs are initially available 
- 
--S Store::make(Atom s) {
--  for (Half $ = 0; $ >= current; --$) 
--    if (eq(s, A+$))
--      return $;
--  const Half n = ::size(s);
--  current -= n;
--  for (Half h = 0; h < n; ++h) // Only case in code to change the pool 
--    const_cast<char&>(A[current + h]) = ::upper(s[h]);
--  return S(current);
--}
- 
--static Half init() {
--  for (Half h = $L_p$  + 1; h < $H_p$; ++h) {
--    P[h].prev = h - 1;
--    P[h].next = h + 1;
--  }
--  P[$L_p$ ].prev = 0;
--  P[$L_p$ ].next = $L_p$  + 1;
--  P[$H_p$].prev = $H_p$ - 1;
--  P[$H_p$].next = 0;
--  for (Half h = $L_p$; h <= $H_p$; ++h) 
--    flip[P[h]];
--  return $L_p$;
--}
--
--static Half next = init;
--static Half $v_p$ = $n_p$; 
--
--static Half make(Pair p) {
--  const Half h = 1 + (p.cons ^ (p.cons <<< 7)) % $N_p$;
--  if (P[h].cons == p.cons) 
--    return h;
--  if (h == next || !red(P[h])) {
--    flip(P[next]);
--    next = P[next].next;
--    flip(P[next]);
--    P[h] = p;
--    return h;
--  }
--  flip(P[h]);
--  const Half prev = P[h].prev, next = P[h].next;
--  if (prev != 0) {
--    flip(P[prev]);
--    P[prev].next = next; 
--    flip(P[prev]);
--  }
--  if (next != 0) {
--    flip(P[next]);
--    P[next].prev = prev; 
--    flip(P[next]);
--  }
--  return h;
--}
--
--S make(Half car, Half cdr) {
--  return make(Pair(car,cdr));
--}
--
--void free(Half h) {
--  D(h, remaining);
--  pool[h].next = next(), remaining++, next() = h;
--}
-+Provides Half m$_p$;              /// how many are currently available 
-+Provides Half made$_p$;           /// how many pairs were made, reuses are counted
-+Provides Half free$n_p$;          /// how many pairs were freed 
-+Provides Half collected$n_p$;     /// how many pairs were garbage collected 
- 
- #undef min
- #undef max
- #undef data
- #undef function
- #undef Type
-+
- #include "gtest/gtest.h"
- 
- int main(int argc, char **argv) {
-@@ -238,43 +61,41 @@ TEST(SExpression, size) {
-   EXPECT_EQ(2, sizeof(S));
- }
- 
--using Context Store;
--
--TEST(Atoms, $L_a$) { 
--  EXPECT_LT($L_a$,0);
--  EXPECT_GE(A - $A_0$,$L_a$);
-+TEST(Atoms, $A_f$) { 
-+  EXPECT_LT($A_f$,0);
-+  EXPECT_GE(A - $A_0$,$A_f$);
- }
- 
--TEST(Atoms, $H_a$) { 
--  EXPECT_EQ($H_a$, 0);
--  EXPECT_EQ((const char *const) A + $H_a$, (const char *const) P);
-+TEST(Atoms, $A_t$) { 
-+  EXPECT_EQ($A_t$, 0);
-+  EXPECT_EQ((const char *const) A + $A_t$, (const char *const) P);
- }
- 
--TEST(Atoms, $N$) { 
--  EXPECT_GT($H_a$, $L_a$);
--  EXPECT_GT($N$, 0);
--  EXPECT_EQ($N$, sizeof memory.$A_0$ + 1);
-+TEST(Atoms, $X_n$) { 
-+  EXPECT_GT($A_t$, $A_f$);
-+  EXPECT_GT($X_n$, 0);
-+  EXPECT_EQ($X_n$, sizeof memory.$A_0$ + 1);
- }
- 
--TEST(Pairs, $L_p$) { 
--  EXPECT_GT($L_p$, $H_a$);
--  EXPECT_LT($L_p$, $H_p$);
--  EXPECT_EQ($L_p$, 1);
-+TEST(Pairs, $P_f$) { 
-+  EXPECT_GT($P_f$, $A_t$);
-+  EXPECT_LT($P_f$, $P_t$);
-+  EXPECT_EQ($P_f$, 1);
- }
- 
--TEST(Pairs, $H_p$) { 
--  EXPECT_GT($H_p$, $L_p$);
--  EXPECT_EQ($H_p$, $N_p$);
--  EXPECT_EQ($P_1$ - memory.P, $H_p$);
--  EXPECT_EQ($M_p$, $H_p$);
-+TEST(Pairs, $P_t$) { 
-+  EXPECT_GT($P_t$, $P_f$);
-+  EXPECT_EQ($P_t$, $P_n$);
-+  EXPECT_EQ($P_1$ - memory.P, $P_t$);
-+  EXPECT_EQ($M_p$, $P_t$);
- }
- 
--TEST(Pairs, $N_p$) { 
--  EXPECT_GT($N_p$,0);
--  EXPECT_LT($N_p$,sizeof memory);
--  EXPECT_LT($N_p$,sizeof memory.P);
--  EXPECT_EQ($N_p$, $M_p$);
--  EXPECT_EQ($N$,sizeof memory.P / sizeof memory.P[0]);
-+TEST(Pairs, $P_n$) { 
-+  EXPECT_GT($P_n$,0);
-+  EXPECT_LT($P_n$,sizeof memory);
-+  EXPECT_LT($P_n$,sizeof memory.P);
-+  EXPECT_EQ($P_n$, $M_p$);
-+  EXPECT_EQ($X_n$,sizeof memory.P / sizeof memory.P[0]);
- }
- 
- TEST(Store, minimalSize) {
-@@ -287,37 +108,6 @@ TEST(Store, overflow) {
-   EXPECT_LT((Half) - $M_a$ - 1, 0);
- }
- 
--TEST(Marking, Pairs) { 
--  EXPECT_LT(flip($L_p$), $L_a$);   
--  EXPECT_LT(flip($H_p$), $L_a$);   
--  EXPECT_LT(flip(($L_p$ + $H_p$)/2), $L_a$);   
--  EXPECT_LT(flip($L_p$-1), $L_a$);   
--  EXPECT_LT(flip($L_p$+1), $L_a$);   
--  EXPECT_EQ(flip(flip($p_p$)), $p_p$);
--  EXPECT_EQ(flip(flip($H_p$)), $H_p$);
--  EXPECT_EQ(flip(flip(($p_p$ + $H_p$)/2)),($p_p$ + $H_p$)/2);
--  EXPECT_EQ(flip(flip($H_p$ + 1)),$H_p$ + 1 );
--  EXPECT_EQ(flip(flip($H_p$ + 1)), $H_p$ + 1);
--}
--
--TEST(Marking, Atoms) { 
--  EXPECT_GT(flip($L_a$), $H_a$);   
--  EXPECT_LT(flip($H_a$),0);
--  EXPECT_GT(flip(($L_a$ + $H_a$)/2), $H_p$);   
--  EXPECT_GT(flip($H_a$-1), $H_p$);   
--  EXPECT_GT(flip($L_a$+1), $H_p$);   
--  EXPECT_EQ(flip(flip($L_a$)), $L_a$);
--  EXPECT_EQ(flip(flip($H_a$)), $H_a$);
--  EXPECT_EQ(flip(flip(($L_a$ + $H_a$)/2)),($L_a$ + $H_a$)/2);
--  EXPECT_EQ(flip(flip($L_a$ + 1)),$L_a$ + 1 );
--  EXPECT_EQ(flip(flip($H_a$ + 1)), $H_a$ + 1);
--}
--
--TEST(Marking, MarkingIsMarked) { 
--  for (Half h = $L$; h <= $H$; ++h)
--    EXPECT_TRUE(red(flip(h)));
--}
--
- TEST(Store, PrimitiveSizs) { 
-   EXPECT_EQ(sizeof(byte), 1);
-   EXPECT_EQ(sizeof(char), 1);
diff --git a/Mini-LISP/eval.h b/Mini-LISP/eval.h
index 22fc0c3..db30dbd 100644
--- a/Mini-LISP/eval.h
+++ b/Mini-LISP/eval.h
@@ -1,4 +1,4 @@
-#include "00.h"
+#include "S.h"
 
 extern S evaluate_list(S);
 extern S eval(S s); 
diff --git a/Mini-LISP/io.h b/Mini-LISP/io.h
index d59508c..222dfac 100644
--- a/Mini-LISP/io.h
+++ b/Mini-LISP/io.h
@@ -1,6 +1,6 @@
 #include <iostream>
 #include <sstream>
-#include "00.h"
+#include "S.h"
 #include "parser.h"
 
 /** Auxiliary file that should not be used by production code, only 
diff --git a/Mini-LISP/pairs.cc b/Mini-LISP/pairs.cc
index 73b907c..821956e 100644
--- a/Mini-LISP/pairs.cc
+++ b/Mini-LISP/pairs.cc
@@ -1,4 +1,4 @@
-#include "00.h"
+#include "S.h"
 #include "stack-trace.h"
 #define SILENT 1 
 #if SILENT
diff --git a/Mini-LISP/parser.h b/Mini-LISP/parser.h
index ffc5245..ab92a5e 100644
--- a/Mini-LISP/parser.h
+++ b/Mini-LISP/parser.h
@@ -1,6 +1,6 @@
 #ifndef PARSER_H
 #define PARSER_H
-#include "00.h"
+#include "S.h"
 #include "tokenizer.h"
 
 /** An implementation of a simple, single instance hand tailored LL(1) parser.
diff --git a/Mini-LISP/stack.h b/Mini-LISP/stack.h
index af19b0d..e29b6f5 100644
--- a/Mini-LISP/stack.h
+++ b/Mini-LISP/stack.h
@@ -1,4 +1,4 @@
-#include "00.h"
+#include "S.h"
 /* Manages a singleton stack of handles, used by the LL parsing algorithm. This
  * stack is implemented as a dynamically allocated singly linked list, where
  * each element is a pair of handles: One handle in the pair carries the data;
diff --git a/Mini-LISP/store.h b/Mini-LISP/store.h
index c3daca9..9c990e4 100644
--- a/Mini-LISP/store.h
+++ b/Mini-LISP/store.h
@@ -23,7 +23,7 @@ typedef int32_t Word; /// Machine word/JVM's int  | 32 bits signed integer | an
  either Atom or Pair 
 */
 
-Type $S_X$;     // An S-expression represented by its handle
+struct $S_X$;     // An S-expression represented by its handle
 
 /*@ Atoms$ An atomic S-expression is a C like string: a memory address of a
 byte storing the first character of the atom's text. The text of an atom is
@@ -35,7 +35,7 @@ typedef const char *const Atom; // Underlining representation of atoms as pointe
 
 Type Pair;  // A compound S-expression, i.e., a dotted pair
 
-Type $S_X$ { // An S-expression represented by its handle
+struct $S_X$ { // An S-expression represented by its handle
   Representation {
     perspective(Half handle) // The inner representation 
   };
diff --git a/Mini-LISP/strings.cc b/Mini-LISP/strings.cc
index 7989480..c696757 100644
--- a/Mini-LISP/strings.cc
+++ b/Mini-LISP/strings.cc
@@ -1,4 +1,4 @@
-#include "00.h"
+#include "S.h"
 #include "stack-trace.h"
 
 #define SILENT 1 
diff --git a/Mini-LISP/t-pairs.cc b/Mini-LISP/t-pairs.cc
index 9a3408c..2108849 100644
--- a/Mini-LISP/t-pairs.cc
+++ b/Mini-LISP/t-pairs.cc
@@ -1,6 +1,6 @@
 #include <iostream>
 #include "gtest/gtest.h"
-#include "00.h"
+#include "S.h"
 #include "test.h"
 
 namespace Pairs {
diff --git a/Mini-LISP/tokenizer.cc b/Mini-LISP/tokenizer.cc
index 39e4d4f..23b6483 100644
--- a/Mini-LISP/tokenizer.cc
+++ b/Mini-LISP/tokenizer.cc
@@ -1,4 +1,4 @@
-#include "00.h"
+#include "S.h"
 #include "tokenizer.h"
 #include "dump.h"
 
diff --git a/Mini-LISP/tokenizer.h b/Mini-LISP/tokenizer.h
index 2823e55..03f967b 100644
--- a/Mini-LISP/tokenizer.h
+++ b/Mini-LISP/tokenizer.h
@@ -1,6 +1,6 @@
 #ifndef TOKENIZER_H
 #define TOKENIZER_H
-#include "00.h"
+#include "S.h"
 namespace Tokenizer {
   enum { undefined = 128, $};
   const char tokens[] = "()[].\'";
@@ -12,7 +12,6 @@ namespace Tokenizer {
   extern H unget(); 
   extern H peep();
 }
-  extern bool exists(const char, String s); 
-
+extern bool exists(const char, String s); 
 #endif
 
diff --git a/Mini-LISP/words.cc b/Mini-LISP/words.cc
index fe0abef..5126827 100644
--- a/Mini-LISP/words.cc
+++ b/Mini-LISP/words.cc
@@ -8,16 +8,21 @@ static bool red(Half h);
 static void flip(Pair &p);
 static bool red(Pair p); 
 
+#define DIE die(__LINE__); 
+auto inline die(int t) {
+  throw t;
+}
+#include "colors.h"
+
 Half free($S_X$ s) {
   auto const h = s.handle;
-  if (red(P[h])) return h; 
-  P[h].next = next; 
-  P[h].prev = $P_x$; 
-  flip(P[h]);
-
-  flip(P[next]);
-  P[next].prev = h;
-  flip(P[next]);
+  is.red(next) || DIE;
+  is.black(h) || DIE;
+  paint.red(h);
+  is.red(h) || die(s);
+  set.red(h).next().to(next); 
+  set.red[h].prev().to($P_x$); 
+  set.red(next).prev() = h;
 
   return next = h;
 }
@@ -36,6 +41,7 @@ static Half init() {
   return next = $P_f$;
 }
 
+
 static $S_X$ make(Pair p) {
   auto h = next;
   flip(P[next]);
@@ -43,9 +49,14 @@ static $S_X$ make(Pair p) {
   P[next].prev = $P_x$;
   flip(P[next]);
   P[h] = p;
+
+  is.white(h)  || die(p.cons(h).cons("Not white"));
+  is.white.car = p.car || die(p.cons(h).cons(("Not same"));
+  p == P[h] || die(p.cons(h).cons(("Not same"));
   return h;
 }
 
+
 static $S_X$ require(Pair p) {
   const Half h = $P_f$ + (p.cons ^ (p.cons << 7) ^ (p.cons >> 3)) % $P_n$;
   if (P[h].cons == p.cons) 
@@ -61,10 +72,14 @@ static $S_X$ require(Pair p) {
     flip(P[prev]);
   }
   if (next != $P_x$) {
+    isred.(h)
     flip(P[next]);
     P[next].prev = prev; 
     flip(P[next]);
   }
+  is.white(h)  || die(p.cons(h).cons("Not white"));
+  p == P[h] || die(p.cons(h).cons(("Not same"));
+  is.white(h) 
   return h;
 }
 $S_X$ make(Half car, Half cdr) { return make(Pair(car,cdr)); }
@@ -86,12 +101,6 @@ Half length() {
   return result;
 }
 
-Half flip(Half h)  { return h + (1 << 15); } 
-Half xflip(Half h)  { return h; } 
-bool red(Half h)   { return h < $X_f$ || h > $X_t$; } 
-void flip(Pair &p) { p.car = flip(p.car); }
-bool red(Pair p)   { return red(p.car);  }
-
 #undef min
 #undef max
 #undef data
