 ⌘פרק{הביצה והתרנגולת}
 גם מי שאינו אורניתולוג יודע כי כל תרנגולת היא אפרוח שהתפתח לאחר שבקע מביצה, וכל  ביצה הוטלה על ידי תרנגולת שקדמה לה. פרדוקס הביצה והתרנגולת המיוחס לאריסטו†{22},
 שואל האם הביצה קדמה לתרנגולת, או שמא, התרנגולת קדמה לביצה.
⌘תחילת{ציינון}

    • מחד, הטענה שהתרנגולת קדמה לביצה לא יכולה להיות נכונה, כי הרי התרנגולת הראשונה הייתה בצעירותה אפרוחית
     שבקעה מביצה.
        • מאידך, אם תמצי לומר שהביצה קדמה לתרנגולת, מיד יטען כנגדך שהביצה הזו הוטלה על ידי תרנגולת שקדמה לאותה ביצה.
      ⌘סוף{ציינון}
        ההנחה הסמויה בפרדוקס זה היא ששרשרת הזמן, כשהיא נמתחת לאחור, היא אינסופית, כלומר שגילו של היקום הוא סופי.
        
        בפרק זה, נעסוק במופעים של פרדוקסים אלגנטיים דומים בתחום של שפות התכנות. בדיוק כמו הביצה והתרנגולת, הפרדוקסליות הטמונה בפרדוקסים אלו היא קלה ביותר להבנה. לעיתים יהיו לפרדוקסים היתרם אלגנטיים, קצרים ופשוטים , אך לא נכונים.  אך במרבית המקרים, טיבם של פרדוקסים הוא זה שהיתרם בא רק לאחר חקירה עמקנית, שהיא הרבה פחות אלגנטית מהפרדוקס עצמו.

    
    נדגים זאת במספר היתרים שונים של פרדוקס הביצה והתרנגולת.
⌘תחילת{ספרור}
        •  ⌘כתב␣עבה{היתר דתי:} באופן כללי, האל ברא את התרנגולת. על פי גישתן של דתות רבות, האל ברא את העולם, כאשר הוא מכיל בתוכו מינים שונים. בפרט, האל ברא את העולם, ובשלב מסוים נבראו התרנגולות יש מאין. בדת היהודית, למשל, בשלב בריאת בעלי החיים, עולה†{" וַיִּבְרָא אֱלֹהִים, אֶת-הַתַּנִּינִם הַגְּדֹלִים; וְאֵת כָּל-נֶפֶשׁ הַחַיָּה הָרֹמֶשֶׂת אֲשֶׁר שָׁרְצוּ הַמַּיִם לְמִינֵהֶם, וְאֵת כָּל-עוֹף כָּנָף לְמִינֵהוּ, וַיַּרְא אֱלֹהִים, כִּי-טוֹב.", בראשית א' כ"א.} כי החיות נבראו בוגרות. בפרט, נבראה לראשונה תרנגולת בוגרת (או מספר תרנגולות בוגרות), אשר הטילו את הביצים הראשונות, עד לתרנגולותינו אנו.
        • ⌘כתב␣עבה{היתר יווני קלסי:} האלים בראו הן את התרנגולת והן את הביצה. מדובר גם כאן בהיתר דתי, וריאציה להיתר הראשון. בגרסא זו, נבראו ע"י האל התרנגולות והביצים, כרעם ביום בהיר. פתרון זה עוקף את ההנחה שמקורן של תרנגולות בהכרח מביצים.
        • ⌘כתב␣עבה{היתר מדעי:} לדידם של אלו המאמינים בתורת האבולוציה, אין הכרח שכל ביצה ממנה נוצרה תרנגולת היא של תרנגולת. למעשה, מדובר בהנחה פשטנית אשר אינה מתארת נכונה את היווצרות החיים. כל מין התפתח ממין קודם וקדום על ידי שורה של מוטציות גנטיות אקראיות שהתרחשו במרוצת השנים. באמצעות מנגנונים של מוטציות†{24} וברירה טבעית, התפתחו לאורך השנים, באופן הדרגתי, יצורים שהם התרנגולות אותם אנחנו מכירים היום. הנ"ל סותר במידת מה את הגדרת הפרדוקס גם כן, וגם לו וריאנטים רבים. באופן כללי, לפי רובן התרגנולות התפתחו מאב קדמון כלשהו בתהליך הדרגתי, כך שלשאלת "מי קדם למי" לא נותרת משמעות רבה. דוגמה לתאוריה ולתשובה.
        • ההיתר הנכון†{לדעת המחבר. מדובר בשאלה שמעסיקה את בני האדם מקדמת דנא, וכל הפתרונות האפשריים לגיטימיים עד אשר יוכח אחרת.}: התרנגולת והביצה - חד המה. התהליך האבולוציוני שאחראי ליצירת תרנגולות כולל שתי שרשראות שונות, אך מצומדות. השרשראות הללו מתחילות בתא הראשון בו היו חיים, כאשר השרשרת הראשונה היא שהשפיעה על מהלך חייו של יצור התרנגולת-ביצה, כלומר על מהלך חייו כצעיר, ואילו השרשרת השנייה השפיעה על מהלך חייו כבוגר. 
        
נרצה לדון בפועלו של ריצ'רד דוקינס†{26}, בהציעו ניסוי מחשבתי לבירור מקורו של האדם. קחו תמונה של עצמכם, ושימו מעליה תמונה של אביכם. מעליה הניחו תמונה של אביו, והמשיכו כך הלאה מספר בלתי-מוגבל של פעמים. בסופו של דבר תגיעו ככל הנראה לאב הקדמון ביותר של כל המינים. הטענה היא שבמעבר על השרשרת, לא נוכל להבחין בהבדל ממשי בין 2 דורות עוקבים, אך בין 2 דורות שמרחקם ניכר, כמעט ולא יוותר דמיון. בשרשראות המתחילות מהתרנגולת של הדוד סימה, לא הנחנו תמונות, כי אם סרט של כל ההתפתחות של היצורים, בזה על גבי זה, ועולה מכך מסקנה אודות הפרדוקס עצמו.
        
הוכחה לכך תוצע כדלקמן: נתבונן בשרשרת ההורה-צאצא של תרנגולת ספציפית, נניח, של הדודה סימה. הנ"ל (התרנגולת!) בקעה מביצה מסוימת שהטילה תרנגולת שנרכשה ע"י הדודה סימה ביריד, והשרשרת ממשיכה אחורה עד לאותו חד-תא היולי ממנו נוצרו החיים לראשונה, ואשר גרם ליצירת חד-תא אחר, שהתחיל את השרשרת שמובילה את התרנגולת האהובה של סימה.
        
        נשים לב כי הוכחה זו, וכל דרך החשיבה הזו הנוגעת להיתר זה, היא למעשה רדוקציה של אופן יצירת החיים. הסתכלנו על שרשרת בעלי חיים המקושרת ביחסי "התפתח מ-", שמתחילה בנו ונגמרת בתא החי הראשון. הבעיה של יצירת החיים נחשבת פרדוקסלית הרבה פחות, וגם לה היתרים רבים (דתיים, ביולוגיים וכו'), אך הם נחשבים בעיני רבים "מוזרים" הרבה פחות, שכן יש לכל היתר שכזה תימוכין וראיות.
⌘סוף{ספרור}
    
    ראינו אם כן פרדוקס משובב נפש. פרדוקס שקל מאוד להבין אותו, קל להתירו באמצעים מטאפיזיים.
    
§§נקודת תחילת הביצוע
    
נעסוק בתת-פרק זה בסוגיית נקודת תחילת ביצוע של תכנית.
    ראינו, בין השאר בתכניות "שלום, עולם!", הוראות בקוד אשר אחראיות להדפסת שורות טקסט. חלק מהוראות מעין אלו מכונות "פקודות", והן בין השאר מרכיבות תכנית. פקודות עשויות להיות מאוגדות במקטעים, המכונים בלוקים. בלוקים אלו עשויים להיות מקוננים אלו באלו, וניתן לכנותם בשם. בשפות שונות, ובכללן שפת שיא, לבלוקים משוימים אלו ניתן השם "פונקציה" (בְּPascal, למשל, מבחינים בין "פונקציות" ל"פרוצדורות" - שני סוגים שונים של בלוקים שכאלו).
    בהינתן אחת מאותן פונקציות, כפי שתוארו, ניתן ללמוד רבות אודות הפונקציות לה תקרא הפונקציה שבידינו. ניתן גם ללמוד, בתלות מסוימת בכישורינו אנו ובכישוריו של הוגה הפוקנציה, מה תכליתה ומהו האופן בו היא מוציאה תכליתה זו מהכוח אל הפועל. דא עקא, לא ניתן ללמוד מקריאה כזו או אחרת מי יקרא לפוקנציה. הדבר שקול לקריאת ספר בישול. מעיון בספר, עמוק ככל שיהיה, לא יוכל לדעת איש מי יקרא בספר ואילו פשעים קולינריים יחולל בשמו.
    נרצה לקוות שבשפות תכנות בהן נשתמש יוגדר סדר ביצוע בין הבלוקים האלו†{דטרמיניזם ועקביות בשפות תכנות הינה דבר כמעט הכרחי במערכות גדולות. עם זאת, יש לכך חריגות. לפרטים נוספים.}. במילים אחרות, שפות שונות מגדירות בצורה שונה את נקודת תחילת הביצוע של תכנית מחשב, בפרט כאשר התכנית מורכבת מקבצי טקסט שונים המכילים, בין השאר, בלוקים מהסוג שתואר. נתאר לפיכך גישות שונות של שפות תכנות שונות באשר לסוגיה זו.
    1. הגישה האוטרקית - פסקל: על פי הגישה האוטרקית, קיימת בתכנית מילה מוגדרת מראש, שחייבת להופיע פעם אחת ויחידה בתכנית, אשר החל ממנה מתחילה לרוץ התכנית. בשפת פסקל, למשל, המילה השמורה program מגדירה את מקום תחילת ביצוע התכנית. בשפת התכנות†{28}AWK התכנית מתחילה לרוץ החל מהמילה השמורה begin, אך בשפה זו אין חובה לתת שם לבלוק ממנו מתחיל הביצוע.
    2. הגישה המטאפיזית - שפת שיא: זוהי גישה נפוצה יותר בשפות תכנות, לפיה ריצת התכנית מתחילה בפונקציה בעלת שם מסוים, אלא ששם זה אינו מוגדר מראש, אלא ניתן לשינוי ע"י המשתמש. שם הפונקציה ממנה מתחילים
    בפרט אינו מוגדר על פי סביבת העבודה. בשפת שיא, למשל, ממומשת גישה זו, ולא קיימת מילה המקבילה
    ל-program בְּPascal. ריצת התכנית מתחילה בדר"כ מהפונקציה main, ועם זאת אפשר לשנות זאת באמצעות
    הגדרות ההידור של תכנית. להלן דוגמה לכך משפת שיא: (המקור- מסמך "צעדים ראשונים", עמוד 20)
    


   

    \begin{verbatim}
/* Hello, World! in C for MS-Windows */

#include <windows.h>

int PASCAL WinMain(HINSTANCE hInstance,
HINSTANCE hPrevInstance, LPSTR CmdLine, int Show)
{¢¢
MessageBox(
GetActiveWindow(),
“Hello, World!”,
“Hello Windows World”,
MB_OK);
return 0;
}
\end{verbatim}
    
    1. הגישה ההוליסטית - ג'אווה†{ברוסית: קרפדה!}: גישה שמכלילה את הגישה
    הקודמת. לפי גישה זו, נקודת התחלת הביצוע עודנה חיצונית
    לשפה עצמה, אך עם זאת השפה מגדירה קביעות מדויקות באשר
    לנקודת תחילת הביצוע. לא יתכן במצב זה כי תחילת הביצוע
    תוגדר בסביבת הפיתוח, ולכן לא יתכן שתהיה נקודת תחילת
    ביצוע שונה ב-2 סביבות פיתוח שונות. הנ"ל מתקיים בשפת
    Eiffel, שם כותב המתכנת קובץ בתחביר הדומה לזה של השפה,
    בו מוגדרת בין היתר נקודת תחילת הביצוע. זהו המצב גם בשפת
    ג'אווה, בה ניתן באמצעות מנגנון בשם Reflection, להתחיל
    ביצוע מכל מקום, בעזרת פונקציית main בכל מחלקה. הנ"ל
    מציב קושי בתכנון שפה יבילה והוליסטית (מדוע?). 2. הגישה
    של ביצוע אינטרקטיבי - שפות עם מפרשים†{30}: בשפות
    מֵפוׂרַשוׂת, המצב מעט שונה. תחילת ביצוע התכנית היא בפקודה
    הראשונה המובאת בפני המפרש, וממשיכה הלאה ככל שחפץ לב
    המתכנת להמשיך ולתת פקודות בפני מפרשו. הנ"ל מתרחש בלולאה
    המכונה: RIEL - Read, Interpret, Execute Loop. משמעותה
    נובעת משמה - עבור כל פקודה מבצע המפרש ארבעה שלבים
    בעיבוד הפקודה: קריאתה, פרשונה, ביצועה והמשך לפקודה
    הבאה. נקודת ההתחלה תהיה אפוא הפקודה הראשונה המוקלדת, או
    הנטענת לפרשון. שפה המממשת עקרון זה היא Ocaml.
    
    עסקנו עד כה בנקודת תחילת הביצוע של תכניות מחשב, ועם זאת זנחנו את הנושא החשוב
    מכל: איך המחשב מתחיל לעבוד? הרי ידוע לכל שעל מנת להפעיל תכניות מחשב, על תכניות
    אחרות להפעילן טרם לכך. נשאלת השאלה מי הפעיל את התכנית הראשונה? ובכן, נסביר:
    בחומרת המחשב קיים קוד צרוב (קובץ הוראות בסיסיות למחשב) בשם ROM: Read Only
    Memory - מדובר בקובץ הוראות בסיסי ביותר הגורם לביצוען של הפעולות ההִיוּלִיוֹת
    ביותר בהפעלת המחשב. הן מפעילות אחת, בשלב מסוים קוראות מידע והוראות מזיכרון
    המחשב, ובעקבותן מופעלת אחרת, בשרשרת עד להדלקת המחשב. למותר לציין שהתהליך כולל
    שלבים מרובים, בהם ניתן לעשות בדרגות שונות. למעוניינים בהרחבה: הסבר קצר, הסבר
    מקיף יותר, פקולטה שזהו עניינה. 
    §§ צבת בצבת עשוייה 
    בהינתן שְׂפַת תכנות אוניברסלית ℒ
    יש טעם לשאול באיזו שפה כתוב המהדר או המפרש של ℒ. אך, כיוון ש ℒ היא אוניברסלית,
    הרי אם אפשר לכתוב את המהדר (לחילופין, המפרש) של ℒ בשפה 'ℒ הרי גם ניתן לכתוב את
    המהדר (לחילופין, המפרש) בשפה ℒ עצמה. מתברר שמקובל מאוד לכתוב את המהדר של השפה
    בשפה עצמה. כך למשל, המהדר של שְׂפַת C כתוב בִּשְׂפַת C. המהדר של שְׂפַת Java כתוב בִּשְׂפַת
    Java, וכו'. כמובן שהדבר מעורר קושי: כי אם המהדר עבור שפה מסוימת כתוב באותה שפה,
    הרי כיצד הודר המהדר? התשובה הפשוטה היא שהמהדר הידר את עצמו, וכך הם בדרך כלל פני
    הדברים. אלא, שהדבר מוביל לרקורסיה אינסופית. 
    
    §§ סוגיה תלמודית 
    חז"ל הבחינו בבעיה
    דומה של רקורסיה אינסופית מעין זו בסוגיא התלמודית הידועה בשם "צבת בצבת עשוייה".
    בגמרא, במסכת פסחים דף נ"ד עמוד א' נאמר: ⌘כתב␣עבה{צבתא בצבתא מתעבדא וצבתא קמייתא מאן עבד
    הא לאי בריה בידי שמים} ובתרגום לעברית: "הצבת אינה נעשית אלא בצבת אחרת. וראשונה
    מי עשאה? על כרחך (אתה נאלץ לומר כי) מאליה נעשית בידי שמים (כלומר, עיון בשאלת הצבת מביאך להכרה בשמיים).". 
    
    כלומר, צבת שהיא מכשיר לאחיזת מטילי
    ברזל לשם ליבונם באש ועיבודם, עשוייה אף היא ברזל, ואף היא מיוצרת בצבת אחרת שקדמה
    לה. כיצד אם כן נוצרה הצבת הראשונה? הפתרון המוצע על ידי הגמרא הוא שהצבת הראשונה     נבראה בערב שבת הראשון, בזמן "בין השמשות", שעה שאלוהים סיים לברוא את כל הדברים
    האחרים, והתכונן לשבות ממלאכתו לקראת ירידת השבת. 
    
    פתרון ניסי שכזה אינו בא בחשבון
    עבור שפות תכנות. מסכת פסחים מציגה גם דרך אחרת שבה יוצרה הצבת הראשונה (על ידי
    דפוס נחושת). לעומת זאת, בשפות תכנות, ניתן לבצע תהליך של bootstrapping שבאמצעותו
    ניתן לפתח מהדר המסוגל להדר את עצמו.†{לא נתאר כאן את התהליך, אבל בסופו של יום, הוא דומה מאוד למה שהיה עושה נַפָּח עני שברשותו ברזל, אך לא כסף לרכישת צבת. נפח כזה היה משתמש בכבשנו באופן איטרטיבי, כאשר בכל פעם הוא היה משתמש בגוש הברזל הדומה ביותר לצבת שיש ברשותו, כדי ליצר קירוב טוב יותר לצבת.} 
    
§§ מדד לאלגנטיות של שפה
אבן בוחן מרתקת לאלגנטיות של שְׂפַת תכנות היא אורך המהדר (או המפרש) של השפה, כאשר הוא כתוב בשפה עצמה. שהרי ככל שהשפה מורכבת ומתוחכמת יותר, מחד קל יותר לכתוב את המהדר, אך מאידך המהדר לעסוק בכל המורכבות והעושר הזה.
    לחילופין, שפה שהיא פשוטה ביחס (כמו שְׂפַת ה batch של DOS) שהוזכרה מעלה, היא קלה אולי להידור, אבל הפשטות של השפה מהווה אבן נגף בבואנו להשתמש בה כדי לכתוב מהדר.
    הנה מספר אורכים אופייני של מהדר לשפה הכתוב בשפה עצמה:
    1. מהדר לשפת C הכתוב בשפה עצמה, דורש כמה עשרות אלפי שורות. המהדר gcc מפרס על פני כשבעה מיליון שורות קוד.
    2. המהדר הראשון לשפת פסקל, אשר נכתב בִּשְׂפַת Pascal דרש כשבעת אלפים ומאתיים שורות.
    3. מפרש לשפת ליספ הכתוב בליספ, הידוע גם כפונקציה האוניברסלית eval דורש כמאה שורות, או מעט פחות מכך.
    לעומת זאת, מפרש בסיסי לשפת פרולוג הכתוב בפרולוג יכול להכתב בשורה אחת בלבד, ומפרש מתוחכם, המאפשר למשל מעקב אחרי החישוב, לא ידרוש בדרך כלל יותר מעשר שורות.
      
§§ הגדרת שפות פורמליות להגדרת שפה פורמלית, באמצעות עצמן
    מהי שפה פורמלית, כל שְׂפַת תכנות היא שפה פורמלית. ישנן שפות פורמליות שאינן שפות תכנות.
    שפות תכנות אינן מכניזים נוח להגדרת שפה פורמלית.
    מכניזמים להגדרת שפות פורמליות. מתברר שגם מכניזמים אלו הם שפה פורמלית.
    
    בדרך כלל, קל הרבה יותר להגדיר שפה פורמלית, מאשר לכתוב מהדר של השפה בעזרת עצמה.
    הנה דוגמאות.
    הגדרת BNF בעזרת עצמו
    הגדרת EBNF בעזרת עצמו
    ביטוי רגולרי המגדיר מהו ביטוי רגולרי חוקי
    קל להגדיר את משפחת ה BNF באצעות ביטוי רגולרי.
    קל להשתמש ב BNF כדי להגדיר מהו ביטוי רגוליר.
    אבל, ניתן להגדיר ביטוי רגולרי באמצעות ביטוי רגולרי? לא! רקורסיה.
    טבלת סיכום, הגדרה הדדית.
    
    מסיבה זו, השפות BNF וְ-EBNF הן אלגנטיות יותר מביטויים רגולריים.
    המספר השלם החיובי הקטן ביותר שאי אפשר לתאר בתריסר מילים או פחות
    המשפט "הַטִּבְעִי הַקָּטָן בְּיוֹתֵר מֵאֵלּו שֶׁאֵינָם גְּדִירִים בְּפָחוֹת מִתְּרֵיסָר מִלִּים" הוא מופע של הפרדוקס של ברי. לִכְאוֹרָה, ברור שקיימים המונים של טבעיים מהסוג הנדון במשפט, שכן מספר הטבעיים גדול בהרבה ממספר ההגדרות. יש הלא אינסוף טבעיים ולעומתם, מספר ההגדרות האפשריות הוא סופי, על אף היותו עצום ורב†{32}. שהרי, יגדל מספר המילים בשפה העברית ככל שיגדל, סופי הוא יוותר עדיין. ממילא, מספר הצירופים בני פחות מתריסר מילים בשפה העברית, לא יוכל להיות אינסופי.
    נסמן על כן בְּ-$X$ את הקבוצה האינסופית של המספרים שאינם גדירים. הרי ודאי שימצא ב-$X$ אחד, $x$, הקטן שבחבריו, כלומר כזה $x$ הנקבע על ידי:
  \[
    ∃x∈X ∙ ∀x'∈X ∙ x'≠x ⇒ x'>x
  \]
    אלא, וכאן נגלה הפרדוקס שבדבר, שכן המשפט שהובא בפתיח נצרך לתשע של מילים בלבד כדי להגדיר את $x$ זה עצמו, ועל כן על כרחך נמצאת אומר $x∌X$
    ההיתר של הפרדוקס נגלה מהבנת השוני בין הגדרה מתימטית "רגילה" ובין שפה טבעית. הפרדוקס שבמשפט, אשר כתוב בשפה טבעית, נובעת מכך שהמשפט מדבר על משפטים אחרים בשפה הטבעית. 
    
    בשפה טבעית קיימת אפשרות לנסח בשפה עצמה משפטים הנוגעים למשפטים אחרים בשפה עצמה. עצימת העין נוכח הקשיים שבמגבלות של התייחסות עצמית, היא זו שמביאה לסתירה.
    בניסוח המשפט האמור או כל גִּרְסָה אחרת שלו†{ובפרט, המשפט שמופיע בכותרת סעיף זה (ואגב, הערת שוליים זו, אף היא דוגמא לטקסט בשפה טבעית המתייחס לעצמו.)}, טמונה הנחה סמויה לפיה קיימת משמעות מדוייקת למונחים "גדיר", "בר-הגדרה" או "ניתן לתיאור".

    נכון, נדמה כאילו אנחנו יודעים לזהות הגדרה מדוייקת כשזו מופיעה לפנינו, ולדחות מלפנינו כל הגדרה ערטילאית או לא מדוייקת. אך מתברר כי אי אפשר לעשות זאת בהיסח הדעת במבנים שכליים כגון תיאוריה מתימטית או שפה טבעית, שהם מורכבים מספיק כדי להכיל "התייחסות עצמית". "התייחסות עצמית" זו היא שעומדת מאחורי הפרדוקס של ברי, כמו גם הפרדוקס של ראסל ("תהי $U$ הקבוצה של כל הקבוצות שאינן מכילות את עצמן, האם $U∈U$?") ופרדוקסים אחרים%
    †{
    בפרט, המשפט שבפתיח הוא הגדרה העוסקת בהגדרות. כיוון שמשפט זה הוא הגדרה בעצמו, הוא עוסק בעצמו. }.

    
    אמרנו שהפרדוקס שבמשפט נובע מההנחה הסמוייה שהמונח "גדיר", הוא אכן מוגדר היטב. ציינו, שההטעייה המבריקה שבמשפט היא שאכן, בדרך כלל, קל להבחין בין משהו שניתן להגדרה, ומשהו שאינו ניתן להגדרה. הפרדקוס יופרך משנשים לב לכך שההבחנה הקלה בין הגדרה ובין "לא הגדרה" נכשלת כשהיא נדרשת להגדרות, כמו המשפט שבפתיח, שמתייחסות לעצמן. הפרדוקס של ברי מוכיח מגבלה מהותית של שפה אנושית†{המונח שפה אנושית כולל גם שפות טבעיות מהאטרוסקית אל שְׂפַת הפקצות, ושפות מלאכותיות, מהאספרנטו ועד הננדורינית שדיברו אותה בני לילית שבחבל ננדור שבארץ התיכונה.}. בפרט, ניתן (במאמץ הגדרתי לא מבוטל) לנסח משפט מתימטי שמשמעותו היא הבאה
    
    תהי $H$ שפה אנושית שהיא מורכבת מספיק כדי לאפשר:
    \תחילת{ציינון}
        • דיון על השפה בתוך השפה עצמה,
        • דיון על קבוצות לא חסומות בגודלן.
           \סוף{ציינון}
        הרי בתוך השפה $H$ ישנם משפטים שלא ניתן לתת להם משמעות עקבית עם שאר מרכיבי השפה.
 
    
    נדגיש שתי אלו:
    \תחילת{ציינון}
        • אי אפשר ליצור את הפרדוקס בלא שהשפה $H$ תהיה מסוגלת להכיל היגדים בדבר "קבוצת כל מי שאפשר לתאר ב $H$ באמצעות תריסר מילים". הפרדוקס נשען על היגד זה.
        • לעומת זאת, אין צורך לדרוש שהשפה $H$ תהיה מורכבת דיה כדי לדון במספרים או במתימטיקה. כל שנדרש הוא האפשרות לדון בקבוצות לא חסומות. ניתן לנסח את הפרדוקס של ברי כך שיסוב על סדריות, ואפשר גם לנסות לכתוב: "הַפְּרִיט הָרִאשׁוֹן שֶׁיִּמָּכֵר בְּ-EBAY מִבֵּין אֵלּוּ שֶׁתֵּאוּרָם נִדְרָשׁ לְיוֹתֵר מִתְּרֵיסָר מִלִּים". ניסוח זה מדגים היטב את הדרישה לדיון בקבוצה בלתי חסומה. אין במשפט משום כל, אם קבוצת הפריטים שעשויה להימכר ב EBAY היא קטנה ממספר התיאורים בני תריסר מילים או פחות. לעומת זאת, הפרדוקס נוצר אם מספר הפריטים שיכול להמכר ב-EBAY הוא בלתי חסום, ולכן גדול ממספר התיאורים הללו.
        קורט גֶדֶל הכיר בעובדה שמשפט מתימטי מוביל לפרדוקס אם המשפט טוען שהוא עצמו אינו נכון. אבל הוא גם הבחין בכך שאין פרדוקס במשפט הטוען שהוא עצמו אינו יָכִיחַ. משפט אי השלמות הראשון של גֶדֶל הוא ניסוח מתימטי מדוייק של הטענה לעיל בדבר שפה טבעית.
    \סוף{ציינון}
    
    בכל תיאוריה מתימטית T אשר מקיימת את התנאים הבאים:
    \תחילת{ציינון}
        • העדר סתירות
        • מורכבת מספיק כדי להכיל את האקסיומות של המספרים הטבעיים
        קיים משפט T, כך ש $T∈T$, הוא נכון, אך לא יָכִיחַ בתיאוריה $T$.
    \סוף{ציינון}
    
    האינטואיציה של הוכחת משפט אי השלמות הראשון של גדל מתחילה בדיון בפרדוקס של ברי.
    אלא שבתיאוריות המתימטיות של גדל, קל למשפטים שמדברים על עצמם. הסיבה היא שבמערכת
    מתימטית שהיא מספיק מורכבת כדי להכיל את המספרים הטבעיים מצטיינת בתכונות הבאה: 
⌘תחילת{ציינון}
   • כל משפט, הוכחה או טענה, ניתנים לקידוד כמספר טבעי בודד. (קידוד זה נקרא קידוד     גדל, ואפשר לבנות אותו למשל באמצעות התרגום של כל משפט לכתיב ה-ASCII). 
   •  כל משפט
    שעוסק במספרים, עוסק לפיכך גם במשפטים, וגם בהוכחות של משפטים. המשפט T נבנה
    באופן הבא: נסתכל על כל ההוכחות האפשריות בתיאוריה T, נקודד כל הוכחה כזו כמספר
    טבעי, ואחר נבנה מספר טבעי אחר, מספר גדל של התיאוריה T, שהוא גם נכון כמשפט, וגם
    לא יָכִיחַ בתיאוריה T. מספר גדל של תיאוריה מסוימת, הוא קידוד של משפט נכון
    אך לא יָכִיחַ בתיאוריה. הבניה של מספר גדל היא מפורשת. היא בונה מספר כזה המקודד
    משפט שהוכחתו שונה מזו מכל ההוכחות הקיימות בשפה. ואינה נובעת משיקולי ספירה.
    במילים אחרות, משפט אי השלמות של גדל אומר שתיאוריה מתימטית אם היא לא טריביאלית,
    היא לא שלמה. וכיצד כל זאות קשור לנושא?
    
    ואף מספר זה הוא אפסי לאין שיעור לעומת המספר של גרהם, מספר טבעי שהוא כה גדול,
    שהיקום כולו אינו מספיק לכתיבת
 ⌘סוף{ציינון}     
 §    הסכנה שבתכניות המשעשעות המדפיסות את עצמן
    
    מהי תכנית המדפיסה את עצמה? ובכן, הגדרה נאיבית תהיה תכנית אשר הפלט שלה היא היא עצמה, אך נחדד, שהרי גם התכנית הריקה תענה על הגדרה זו, ולא נרצה פתרון פשטני כל כך שייחשב פתרון תקף לבעיה אלגנטית זו. לא נרצה גם שתכנית שמקבלת את עצמה כקלט טקסטואלי ומדפיסה טקסט זה תיחשב, שכן מדובר בפתרון טכני בלבד.
    לפיכך, ההגדרה היא כדלקמן: תכנית המדפיסה את עצמה, ובלעז, Quine, היא תכנית לא ריקה אשר לא מקבלת קלט והפלט היחידי שלה הוא התכנית עצמה (כך נימנע גם מלכלול תכניות אשר מדפיסות לאורך הזמן את כל הפלטים האפשריים, בזה אחר זה, עד אשר תדפיס בעת מסוים את עצמה). תכניות מעין אלו מהוות אבן שואבת במדעי המחשב, וניתן להתייחס אליהן בצורה מתמטית באופן הבא: אם נתייחס לסביבת הביצוע כאל פונקציה (מקבוצת התכניות אל קבוצת הפלטים), נקבל כי תכנית המדפיסה את עצמה היא נקודת שבת†{36}.
    בנוסף, מבחינה ספרותית, ניתן לומר שקוד שכזה הוא קוד ארס-פואטי, שכן הוא עוסק בכתיבת קוד בעצמו.
    נראה מספר דוגמאות†{ראוי להדגיש נקודה חשובה זו.} לתכניות המדפיסות את עצמן:
    ג'אווה:
    
    Perl:
    
    Python:
    
    ולהלן דוגמה בשיא חד, המלווה בהסבר ובהרחבה.
    
    מהו הטריק†{38}שבזכותו עובדות תכניות אלו? ניתן לחלק באופן גס את הקוד ל-2 חלקים:
   ⌘תחילת{ספרור}
   •  מערך מחרוזות ו/או אוסף קבועים, אשר מכילים את קוד
    הביצוע של התכנית.
   •  קוד הביצוע של התכנית, אשר מכיל הוראות להדפסה פעמיים
    של מערך המחרוזות המדובר, וכן קבועים נוספים הדרושים
    לשכפול מדויק של הקוד לתוך מה שיודפס. בריצת התכנית
    יודפס, כאמור, פעמיים המערך והתווים הרלוונטיים - בפעם
    הראשונה עבור הדפסת החלק הראשון של התכנית (מערך
    המחרוזות), ובפעם השנייה עבור הדפסת החלק השני - קוד
    הביצוע ממש.
     ⌘סוף{ספרור}   
    עם זאת, טמונה בקודים מעין אלו סכנה של ממש. תכניות כאלו עשויות להוות כלי להחדרה
    של וירוסים†{למעשה, מינוח מדויק יותר הוא סוס טרויאני, מונח שעל משמעותו ניתן וראוי לדון רבות.}בידי זֵדִים†{40}. כתב על כך קן תומפסון†{אבי UNIX! חלוץ אמריקאי בתחום מדעי המחשב, ידוע בשל תרומתו לפיתוח שפות התכנות B,Go והגדרת UTF-8.} במאמרו†{42}. נתחיל
בתיאור מנגנון רלוונטי. נניח שנתון לנו קובץ המקור של המהדר של שפת שיא, ונרצה
להכניס בו שינוי מסוים - נרצה שבהינתן תו הבקרה v/ , תודפס מפלצת ASCII הזו. כיצד
נעשה זאת? ובכן, בהינתן קוד המקור האידיאלי הבא של המהדר, נגלה כי אין זו משימה
קשה במיוחד:

מדובר בקוד המקבל תווים בשפה, ומחזיר את התו הרלוונטי עבור כל מקרה. היות שהמהדר של שפת שיא כתוב בעצמו בשפת שיא, המהדר של השפה "מכיר" את התווים המיוחדות האלו, ויודע "מה לעשות".
על מנת להשלים את הקוד על מנת שיכיל את התוספת שלנו (ידוע שהדפסת מפלצות ASCII שכאלו מביאה למורת רוח מרובה בקרב המשתמשים), נבצע את השינוי הבא:
הוספנו את השורה המתאימה, וננסה עתה להדר את הקובץ החדש של המהדר באמצעות המהדר הישן שברשותנו. אך, אבוי, שוד ושבר, נקבל שגיאה! הרי המהדר הישן לא יודע מפלצות ASCII מהן, ולא יודע מהו התו v/.
נרצה לפיכך "לאלף" את המהדר הישן להכיר תוסף זה, על מנת שיוכל להדר אותו, ולהפוך אותו לקומפיילר תקני המכיל את השינוי. ניגש אפוא לקובץ המקור של המהדר הישן, ונוסיף בו את השינוי הבא (אחרון, מבטיחים!):
כעת, המהדר הישן מכיר את התו v/. נניח שקיימת מחרוזת תווים כלשהי, המייצגת את מפלצת ה-ASCII המועדפת עלינו, וכי היא מיוצגת ע"י ה-11 בדוגמה שלהלן. נהדר באמצעותו את המהדר החדש שכתבנו, ונקבל קובץ binary שמכיל מהדר חדש, המטמיע את התוספת החדשה. ניתן באמצעות תוצר זה להדר תכניות שיבצעו תוספת זו.
    
    באופן דומה, אך זהה מבחינה רעיונית, ניתן, לאחר מאמץ מחשבתי ניכר, לתאר נזקים
כבירים אף יותר מהופעה של מפלצת (מאיימת ככל שתהיה) על צג המחשב. דוגמה לכך היא
פריצה לחשבונות פרטיים במערכות UNIX, ע"י הוספת פרצה, לפיה ניתן יהיה להתחבר לכל
חשבון באמצעות סיסמא כלשהי (נניח iAmHackerHoHoHo). בשלב הבא, נבצע את התהליך כפי
שביצענו בדוגמה הקודמת, ובאמצעותו נקבל את מערכת UNIX החדשה, בה תהיה קיימת פרצה
זו. הפרצה תהיה מקודדת ומוטמעת במערכת החדשה, ללא יכולת זיהוי. זהו סוס טרויאני
עמיד בפני התקפות.

§ גבולות התכנית
נוסחת הירון לחישוב השטח S של משולש שגדלי צלעותיו הן a, b וְ C היא אלגנטית במיוחד:

כאשר

הבה נכתוב בזריזות תכנית Pascal בעבור הנוסחה הזו
\תחילת{קוד}
Program h;
VAR a,b,c,p: real;
Begin
readln(a,b,c);
p := (a+b+c)/2;
writeln(sqrt(p*(p-a)*(p-b)*(p-c)))
end.
\סוף{קוד}

מי שכתב אי פעם תכנית בִּשְׂפַת מכונה כלשהי, יכול לשוות בנפשו כיצד יתרגם המהדר את
התכנית לעיל לשפת המכונה שעליה היא תרוץ, למעט ענין פעוט אחד: ידוע לכל כי ישנן
פקודות מכונה לחישוב הסכום הסכום, המכפלה, ההפרש והמנה של שני מספרים ממשיים. אבל,
כיצד יחושב השורש הריבועי? אפילו אם נניח כי יש המכונה מכילה פקודה לחישוב השורש,
עדיין ישנה השאלה של התרגום של פקודות הקלט והפלט שבתכנית, שהרי אלו בוודאות אינן
מצויות באוסף פקודות המכונה. על כרחך אתה נאלץ לומר כי התרגום של תכנית בִּשְׂפַת
תכנות מסוימת, פשוטה ככל שתהייה, לשפת מכונה, חייב להשתמש בפרודצרות ופונקציות אשר
אינם מצויים בתכנית עצמה. השאלה בה עוסק פרק זה היא, בניסוח לא פורמלי, היא: "כיצד
נקבעים גבולות התכנית?"†{הקורא הכמה בשלב זה לארמז ספרותי או תיאולוגי, יכול לללמוד מעט על התהליכים היהודיים והננוצריים של קנוניזציה של כתבי הקודש, אשר בהם נקבע אלו מבין הספרים שייכים לתנ"ך. פלגים שונים בנצרות הגיעו לתוצאות שונות ביחס לשאלה זו. מעניין לציין כי בתנ"ך היהודי ישנם מה שהיינו קוראים שגיאות עקידה (Linking Error), ככתוב "כִּי אַרְנוֹן גְּבוּל מוֹאָב בֵּין מוֹאָב וּבֵין הָאֱמֹרִי. עַל-כֵּן יֵאָמַר בְּסֵפֶר מִלְחֲמֹת יְהוָה: אֶת וָהֵב בְּסוּפָה וְאֶת הַנְּחָלִים אַרְנוֹן…" אלא שספר מלחמות ה' אינו מצוי בידינו;. (אגב, בברית החדשה הנוצרית, בכל הגדרותיה השונות, אין הפניה לספרים חיצוניים או לספרים שאבדו.)}, או בלשון אחרת, בהינתן שְׂפַת תכנות מסוימת, ובהינתן כל
    קטעי הקוד הקיימים בעולם הכתובים בשפה זו:
 ⌘תחילת{ציינון}
         • אלו קטעים יוצרים תכנית מסוימת, ואלו תכנית אחרת?
        • האם יתכן שקטע קוד מסוים יהיה שייך ליותר מאשר תכנית אחת? ואם כן, מתי יקרה הדבר?
        • היאך מוגדר בכלל "קטע קוד"?
        • בהינתן כל קטעי הקוד מהם מורכבת התכנית, כיצד נקבע מאיזה מהם יתחיל הביצוע?
        ⌘סוף{ציינון}
        כדי לדעת את התשובה לאלו, בדרך כלל אין זה מספיק להכיר את הדקדוק והמשמעות של
        השפה, אלא נדרשת הבנה של הסביבה בה פועלת התכנית, והאינטרקציה של התכנית עם
        סביבתה. הגישה הנקוטה בִּשְׂפַת פסקל, היא הגישה האוטרקית, על פיה יש רק קטע קוד אחד
        היוצר תכנית, וקטע זה מצוי בקובץ אחד. כל הפונקציות והפרוצדורות אשר יכולות להיות
        מופעלות על ידי התכנית מצוייות בקטע זה, או מוגדרות על ידי שְׂפַת התכנות.
        בְּPascal ישנה גם מילה שמורה program המגדירה את התחלת התכנית, באשר הביצוע יתחיל במילה השמורה begin המתאימה לה. בשפות אוטרקיות אחרות, כמו גירסאות ישנות של בייסיק למשל, תחילת הביצוע יכולה להקבע בדרך אחרת, למשל מהפקודה הראושנה בתכנית.
        הגישה האוטרקית בְּPascal נובעת מייעוד השפה ללומדים. לשם קיומו של חזון זה, בחר
        מתכנן השפה גם להימנע משימוש בספריות. כל הפונקציות והפרודצרות אשר בהן יכול
        המתכנת בשפה להשתמש הן אלו שהוא כתב בעצמו, או אלו שמוגדרות כחלק מהשפה. בפרט,
המפרט של הפונקציות readln וְ-writeln מצוי בהגדרת השפה עצמה. יוצר השפה בחר שלא
להשתמש במילים שמורות בכדי לציין את הפונקציות והפרוצדרות המוגדרות על ידי השפה,
אלא לקבוע שאלו הם מזהים מוגדרים מראש. הבחירה הזו מבטיחה ששירותים אלו יהיו
זמינים למתכנת בכל עת, זאת, מבלי לסרבל את השפה בהגדרה של מספר גדול של מילים
שמורות, אשר ימנעו מהמתכנת להשתמש במילים אלו לצרכיו. רעיון זה מתפרס בְּPascal לא
רק על הפונקציות והפרוצדרות, אלא גם על הטיפוסים היסודיים, ואף על שמות הקבועים.
המילים integer, true וְ-false אינן מילים שמורות בשפה, והמתכנת יכול להגדירן מחדש.
בפרט, התכנית הבאה המדגימה את סיסמת המפלגה בספר 1984 של ג'ורג' אורוול היא תכנית
חוקית בְּPascal:

    
\תחילת{קוד}
program NineteenEightyFour;
const
integer=true;
true=false;
false=integer;
begin
writeln("Truth is ", true);
writeln("False is ", false);
end.
\סוף{קוד}
    
מרבית הסיכויים הם שאם תזין תכנית זו במהדר ה Pascal החביב עליך, הוא יפלוט בתגובה
שגיאות הידור לרוב. התפתחות השפה הביאה לכך שהמילים true וְ false הפכו בחלוף השנים
למילים שמורות, וההבדל בין המילה true ובין הישות שהיא מציינת, הלא היא ערך האמת
המופשט, נמוג. מנגד, האבחנה בין הסימון ובין הישות שהוא מייצג מתחזקת בשפות
מודרניות, אשר בהן הסימן '+' למשל, נבדל מפעולת החיבור אותה הוא מייצג. כך בC++
למשל, המתכנת יכול להשתמש בסימן זה גם לפעולות אחרות באמצעות תהליך הקרוי העמסת
אופרטורים.
מנגד לגישה האוטרקית, קיימת הגישה המטאפיזית הנקוטה על ידי שְׂפַת C. על פי גישה זו,
תיחום התכנית נעשה מבחוץ לה, באמצעות כלים אשר אינם מוגדרים בשפה. בגישה זו, אוסף
של קטעי קוד המצויים (למשל) בקבצים שונים נאסף על ידי העוקד†{44} לכדי תכנית אחת,
אך השפה עצמה אינה מתייחסת להגדרת העוקד. העוקד גם מחבר לתכנית ספריה של שירותים.
הספריה היא סטנדרטית, במובן זה, שלהגדרת השפה נלווית גם הגדרה של הספריה
הסטנדרטית, אך שתי הגדרות אלו הן בלתי תלויות. ניתן לשנות ולפתח את הספריה
הסטנדרטית מבלי לשנות את השפה ואת המהדר שלה. המתכנת אף הוא יכול לבחור להחליף
חלקים מהספריה הסטנדרטית, או את התכנית כולה. נעיין כעת בתכנית שלום עולם בִּשְׂפַת C:

\תחילת{קוד}
main() {¢¢
printf("Hello, World!\n");
}
\סוף{קוד}

טרם שנמשיך, נדרשות כמה מילים כדי להפיס את דעתו של מי שיזעם על התכנית כפי שהיא כתובה כאן, משום שלכאורה חסרה בה ההוראה:
\תחילת{קוד}
#include <stdio.h>
\סוף{קוד}
אשר כביכול גורמת לקישור של התכנית לספריה הסטדנדרטית, אשר בה מוגדרת הפונקציה
printf. ובכן, לא מיניה ולא מקצתיה: התכנית תהודר ותקושר לספריה הסטנדרטית בין אם
נכלול הוראה זו ובין אם לאו. ההוראה אמנם גורמת ליבוא קובץ הגדרות, אשר מסייע
למהדר לבדוק את התכנית. אך יבוא זה נעשה טרם ההידור, והמהדר אינו מודע לו כלל
וכלל, ועל אחת כמה וכמה העוקד. העקידה לספריה הסטדנדרטית נעשה באמצעות הפקודה cc
אשר אינה מפעילה את המהדר בלבד, אלא גם את הקדם מעבד, כמו גם את העוקד. הפעלת
העוקד מעבירה לו בקשה לעקוד את הקובץ המהודר עם הספריה הסטדנדרטית. בהפעלת פקודה
זו ניתן בקלות להשתמש בדגלים אשר יכתיבו עקידה עם ספריה אחרת, או אי ביצוע עקידה
כלל.
לאחר דברי פיוס אלו נציין כי התכנית הזו משתמשת בשירותי הספריה הסטנדרטית בשתי דרכים.
\תחילת{ציינון}
    • ראשית, ישנו השימוש הברור בפונקציה printf אשר לקוחה מהספריה. פונקציה זו כתובה בִּשְׂפַת C, והיא נגישה לכל דיכפין אשר יכול אף לשנות אותה אם יחפוץ בכך.
    • התלות השניה בשירותי הספריה היא בקביעה כי נקודת תחילת הביצוע היא בפונקציה main. החלטה זו מוכתבת על ידי העוקד, אשר אוסף את כל קטעי התכנית, ובכללם שלושת השורות מעלה, הגדרת הפונקציה printf מהספריה, כמו גם את כל הפונקציות והמשתנים בהם משתמשת printf, ויצירת תכנית אחת מהם. אחרי האיסוף הזה, יש גם לקבוע את נקודת ההתחלה.
        העובדה שהעוקד בוחר להתחיל את הביצוע בפונקציה main היא מוסכמה, אולם, ישנם מקרים בהם היא אינה מקויימת. כך למשל תכניות הכתובות עבור מערכת ההפעלה חלונות יתחילו ב WinMain.
        הסיבה העיקרית שבה לימוד תכנות בשפה חדשה לעולם יתחיל בכתיבת תכנית "שלום, עולם!" היא שתכנית זו כופה על המתכנת להשתמש (אם כי לא בהכרח מתוך הבנה מלאה) במנגנונים לתחימת גבולות התכנית, ולקביעת תחילת הביצוע. וכפי שהדוגמאות כאן מורות, המנגנון הזה אינו תמיד מוסבר באופן מפורש, או שהביאור של אופן פעולתו הוא מייגע ובלתי נגיש למתכנת המתחיל.
    \סוף{ציינון}
    
אוטרקית
מטאפיזית/ספריה
נקודת התחלה
שורה ראשונה או ממילה שמורה
מוגדרת מחוץ לתכנית.
בדרך כלל ישנם נהגים מקובלים, קונבנציות, (אולם הנוהג אינו בהכרח דין).
קלט/פלט
שגרות עזר וכיוצא בזה
אחד משלושה:
-מהווים חלק מהגדרת השפה
-באמצעות מזהים מוגדרים מראש
-מילים שמורות
בקבצי ספריה למיניהם שעל המתכנת לחבר לתכנית.
טיפוסים יסודיים
-בשפה
-מילים שמורות
-מילים מוגדרות מראש
בדרך כלל מילים שמורות
היקף התכנית
תמיד יהיה בקובץ בודד
מוגדר מחוץ לשפה באמצעות הלינקר או כלי אחר. כלומר מוגדר גם מחוץ לתכנית עצמה.

§  רקורסיה הדדית
נתאר לעצמנו שתי פונקציות הקוראות זו לזו ברקורסיה הדדית, ()f ו-()g. נתאר לעצמנו שני טיפוסים Male ו-Female שהגדרת האחד תלויה בהגדרת האחר.
איך ניתן לכתוב זוג הגדרות שתלויות זו בזו הדדית? במיוחד בשיטה שבה ה-Scope מתחיל בהגדרה, ומסתיים בסוף הבלוק?
שתי אפשרויות עיקריות:
1. ניתן להשתמש בשם של טיפוס עוד לפני שהטיפוס הוגדר.
\תחילת{ציינון}
    • בִּשְׂפַת C, אפשר להגדיר משתנה המצביע לטיפוס רשומה, עוד לפני שהטיפוס מוגדר.
\סוף{ציינון}

\תחילת{קוד}
struct Data *p;
struct Data {int i; char c; }
\סוף{קוד}

בדוגמא רואים הגדרה של המשתנה p שהטיפוס שלו הוא מצביע למשתנה מהטיפוס struct Data וזאת עוד לפני שהטיפוס struct Data הוגדר.
\תחילת{ציינון}
    • בשפת פסקל, ניתן להשתמש בטיפוס של מצביע לטיפוס, עוד טרם שהטיפוס הוגדר.
\סוף{ציינון}

1. ביצוע Declaration לאחד מבני הזוג, ואחר כך, Definition לבן הזוג השני, ולבסוף Definition לבן הזוג השני.
\תחילת{ציינון}
    • הנה דוגמא בִּשְׂפַת C:
\סוף{ציינון}
\תחילת{קוד}
extern char f(); // Declaration of f()
char g() {¢¢ return f(); } // Definition of g()
char f() {¢¢ return g(); } // Definition of f()
\תחילת{ציינון}
• והנה דוגמא בִּשְׂפַת פסקל:
Program p;
Function f: Character;
forward; (* Declaration of Function f *)
Function g: Character;
Begin (* Definition of Function g *)
g := f (* Using Function f in Function g *)
end;
Function f: Character; (* Definition of Function f *)
Begin
f := g (* Using Function g in function f *)
end;
Begin
(* Body of program p *)
end.
\סוף{ציינון}
\סוף{קוד}

§§  רקורסיה הדדית הבנויה בשפה
כאשר תוכננו שפות התכנות הראשונות, למחשבים היה כוח חישוב מועט. ההידור התבצע ככל
שאפשר במעבר אחד על התכנית. זו אחת הסיבות לקיום כלל ה-Scope לפיו הגדרה מוכרת
מהשורה שבה היא מבוצעת ועד לסוף הבלוק. בשפות תכנות חדשות יותר, כמו Java, שְׂפַתC++
, וְ-＃C, קיים מנגנון חזק יותר, לפיו הטווח של הגדרה הוא הבלוק שבה היא מתבצעת,
כלומר ה-Scope של הגדרה יכול להתחיל עוד לפני שההגדרה עצמה בוצעה. הנה דוגמא בC++
:
\תחילת{קוד}
class X {¢¢
char f() {¢¢ return g(); } // Definition of f()
char g() {¢¢ return f(); } // Definition of g()
}
\סוף{קוד}
הגדרות קולטרליות
הגדרות של פונקציות ומחלקות בתוך מחלקה שלC++ , או Java, מוכרות בכל המחלקה. תכונה
זו מאפשרת רקורסיה הדדית. המצב ההפוך מתקיים בהגדרות קולטרליות. המילה קולטרלי באה
לומר שאין לאף הגדרה עדיפות לאחרת, כל אחת מהן יכולה להופיע לפני כל אחת אחרת.
הצורך בהגדרות קולטרליות (או סימולטניות) אינו ברור מיידית, וזו אולי הסיבה שהן
נדירות, אבל הן קיימות בִּשְׂפַת ML, באמצעות המילה השמורה and. הנה דוגמא לשימוש
במילה זו
\תחילת{קוד}
val x = y and y = x
\סוף{קוד}
בהגדרה זו, המשמעויות של המזהים x וְ-y מתהפכות.
    
