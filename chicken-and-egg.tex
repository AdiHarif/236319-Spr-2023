גם מי שאינו אורניתולוג יודע כי כל תרנגולת היא אפרוח שהתפתח לאחר שבקע מביצה, וכל ביצה הוטלה על ידי תרנגולת קודמת. ⌘מונח[פרדוקס הביצה והתרנגולת]{פרדוקס הביצה והתרנגולת} המיוחס לאריסטו⌘הערת␣שוליים{384-322 לפנה"ס, יליד סטאגירה, מגדולי הפילוסופים ביוון העתיקה, ובנו של ניקומכוס, רופא החצר של מלך מוקדון.}, שואל מה אם הביצה קדמה לתרנגולת, או שמא, התרנגולת קדמה לביצה. 
⌘תחילת{ציינון}
• הטענה שהתרנגולת קדמה לביצה לא יכולה להיות נכונה, כי הרי התרנגולת הראשונה הייתה אפרוח שבקע מביצה.
• אם תמצי לומר שהביצה קדמה לתרנגולת, מיד יטען כנגדך שהביצה הזו הוטלה על ידי תרנגולת. 
ההנחה הסמויה בפרדוקס זה היא ששרשרת הזמן, כשהיא נמתחת לאחור, היא סופית, כלומר שגילו של היקום הוא סופי.
⌘סוף{ציינון}
בפרק זה, נעסוק במופעים של פרדוקסים אלגנטיים דומים בתחום של שפות התכנות. בדיוק כמו הביצה והתרנגולת, הפרדוקסליות הטמונה בפרדוקסים אלו היא קלה ביותר להבנה. לעיתים יהיו לפרדוקסים היתרם אלגנטיים, קצרים ופשוטים (אך לא נכונים בעליל). אך במרבית המקרים, טיבם של פרדוקסים הוא זה שהיתרם בא רק לאחר חקירה עמקנית, שהיא הרבה פחות אלגנטית מהפרדוקס עצמו.

נדגים זאת במספר היתרים שונים של ⌘מונח{פרדוקס הביצה והתרנגולת}. 
⌘תחילת{ספרור}
• ⌘גיבור{היתר דתי:} באופן כללי, האל ברא את התרנגולת. על פי גישתן של דתות רבות, האל ברא את העולם, כאשר הוא מכיל בתוכו מינים שונים. בפרט, האל ברא את העולם, ובשלב מסוים נבראו התרנגולות יש מאין. בדת היהודית, למשל, בשלב בריאת בעלי החיים, עולה⌘הערת␣שוליים{"וַיִּבְרָא אֱלֹהִים אֶת-הַתַּנִּינִם הַגְּדֹלִים; וְאֵת כָּל-נֶפֶשׁ הַחַיָּה הָרֹמֶשֶׂת אֲשֶׁר שָׁרְצוּ הַמַּיִם לְמִינֵהֶם וְאֵת כָּל-עוֹף כָּנָף לְמִינֵהוּ וַיַּרְא אֱלֹהִים כִּי-טוֹב.", בראשית א' כ"א.} כי החיות נבראו בוגרות. בפרט, נבראה לראשונה תרנגולת בוגרת (או מספר תרנגולות בוגרות), אשר הטילו את הביצים הראשונות, עד לתרנגולותינו אנו. 
• ⌘גיבור{היתר יווני:} ⌘מונח[אלוהים]{אלוהים} ברא הן את התרנגולת והן את הביצה. מדובר גם כאן בהיתר דתי, וריאציה להיתר הראשון. בגרסא זו, נבראו ע"י האל התרנגולות והביצים, כרעם ביום בהיר. פתרון זה עוקף את ההנחה שמקורן של תרנגולות בהכרח מביצים.
• ⌘גיבור{היתר מדעי:} לדידם של אלו המאמינים בתורת האבולוציה, אין הכרח שכל ביצה ממנה נוצרה תרנגולת היא של תרנגולת. למעשה, מדובר בהנחה פשטנית אשר אינה מתארת נכונה את היווצרות החיים. כל מין התפתח ממין קודם וקדום על ידי שורה של מוטציות גנטיות אקראיות שהתרחשו במרוצת השנים. באמצעות מנגנונים של מוטציות ⌘הערת␣שוליים{למעשה, אין זה מדויק. לקורא המעוניין בהעשרה ביולוגית, נרחיב כי מנגנון בשם "רקומבינציה" (שאינו נחשב ל"מוטציה") יוצר מגוון ביולוגי בין-דורי אף באדם, אשר באמצעותו, באפיק נפרד להורשה "רגילה", מתקבל מגוון גנטי במין מסוים. לפרטים נוספים.} וברירה טבעית, התפתחו לאורך השנים, באופן הדרגתי, יצורים שהם התרנגולות אותם אנחנו מכירים היום. הנ"ל סותר במידת מה את הגדרת הפרדוקס גם כן, וגם לו וריאנטים רבים. באופן כללי, לפי רובן התרנגולות התפתחו מאב קדמון כלשהו בתהליך הדרגתי, כך שלשאלת "מי קדם למי" לא נותרת משמעות רבה. 
• ⌘גיבור{ההיתר ה"נכון":} התרנגולת והביצה - חד המה. התהליך האבולוציוני שאחראי ליצירת תרנגולות כולל שתי שרשראות שונות, אך מצומדות. השרשראות הללו מתחילות בתא הראשון בו היו חיים, כאשר השרשרת הראשונה היא שהשפיעה על מהלך חייו של יצור התרנגולת-ביצה, כלומר על מהלך חייו כצעיר, ואילו השרשרת השנייה השפיעה על מהלך חייו כבוגר. הוכחה לכך תוצע כדלקמן: נתבונן בשרשרת ההורה-צאצא של תרנגולת ספציפית, נניח, של הדודה סימה. הנ"ל (התרנגולת!) בקעה מביצה מסוימת שהטילה תרנגולת שנרכשה ע"י הדודה סימה ביריד, והשרשרת ממשיכה אחורה עד לאותו חד-תא היולי ממנו נוצרו החיים לראשונה, ואשר גרם ליצירת חד-תא אחר, שהתחיל את השרשרת שמובילה את התרנגולת האהובה של סימה.

נרצה לדון בפועלו של ריצ'רד דוקינס ⌘הערת␣שוליים{ביולוג אבולוציוני בריטי, הידוע בשל ספרי המדע הפופולרי שחיבר. יש יטענו שהוא סטיבן הוקינג בגרסתו הביולוגית.}, בהציעו ניסוי מחשבתי לבירור מקורו של האדם. קחו תמונה של עצמכם, ושימו מעליה תמונה של אביכם. מעליה הניחו תמונה של אביו, והמשיכו כך הלאה מספר בלתי-מוגבל של פעמים. בסופו של דבר תגיעו ככל הנראה לאב הקדמון ביותר של כל המינים. הטענה היא שבמעבר על השרשרת, לא נוכל להבחין בהבדל ממשי בין 2 דורות עוקבים, אך בין 2 דורות שמרחקם ניכר, כמעט ולא יוותר דמיון. בשרשראות המתחילות מהתרנגולת של הדוד סימה, לא הנחנו תמונות, כי אם סרט של כל ההתפתחות של היצורים, בזה על גבי זה, ועולה מכך מסקנה אודות הפרדוקס עצמו.

נשים לב כי הוכחה זו, וכל דרך החשיבה הזו הנוגעת להיתר זה, היא למעשה ⌘מונח {רדוקציה} של אופן יצירת החיים. הסתכלנו על שרשרת בעלי חיים המקושרת ביחסי "התפתח מ-", שמתחילה בנו ונגמרת בתא החי הראשון. הבעיה של יצירת החיים נחשבת פרדוקסלית הרבה פחות, וגם לה היתרים רבים (דתיים, ביולוגיים וכו'), אך הם נחשבים בעיני רבים "מוזרים" הרבה פחות, שכן יש לכל היתר שכזה תימוכין וראיות.
⌘סוף{ספרור}
ראינו אם כן פרדוקס משובב נפש. פרדוקס שקל מאוד להבין אותו, קל להתירו באמצעים מטאפיזיים.

§ מקום תחילת ביצוע

נעסוק בתת-פרק זה בסוגיית ⌘מונח[מקום תחילת ביצוע התכנית]{מקום תחילת התכנית} ביצוע התכנית.

ראינו, בין השאר בתכניות "שלום, עולם!", הוראות בקוד אשר אחראיות להדפסת שורות טקסט. חלק מהוראות מעין אלו מכונות "⌘פקודות", והן בין השאר מרכיבות תכנית. ⌘פקודות עשויות להיות מאוגדות במקטעים, שכל אחד מהם מכוה ⌘מונח{בלוק}. בלוקים אלו עשויים להיות ⌘מונח[קינון]{מקוננים} אלו באלו, וניתן לכנותם בשם. בשפות שונות, ובכללן שפת ⌘סי, לבלוקים משוימים כאלו ניתן השם "פונקציה" (בְּ-⌘שי{Pascal}, למשל, מבחינים בין "פונקציות" ל"פרוצדורות" - שני סוגים שונים של בלוקים שכאלו). 

בהינתן אחת מאותן פונקציות, כפי שתוארו, ניתן ללמוד רבות אודות הפונקציות לה תקרא הפונקציה שבידינו. ניתן גם ללמוד, בתלות מסוימת בכישורינו אנו ובכישוריו של הוגה הפוקנציה, מה תכליתה וכיצד היא מגשימה תכליתה זו. דא עקא, לא ניתן ללמוד מקריאה כזו או אחרת מי יקרא לפוקנציה. הדבר שקול לקריאת ספר בישול. מעיון בספר, עמוק ככל שיהיה, לא יוכל לדעת איש מי יקרא בספר ואילו פשעים קולינריים יחולל בשמו. 

נרצה לקוות שבשפות תכנות בהן נשתמש יוגדר סדר ביצוע בין הבלוקים האלו ⌘הערת␣שוליים{דטרמיניזם ועקביות בשפות תכנות הינה דבר כמעט הכרחי במערכות גדולות. עם זאת, יש לכך חריגות. לפרטים נוספים.}. במילים אחרות, שפות שונות מגדירות בצורה שונה את ⌘מונח{מקום תחילת ביצוע התכנית} של תכנית מחשב, בפרט כאשר התכנית מורכבת מקבצי טקסט שונים המכילים, בין השאר, בלוקים מהסוג שתואר. 

נתאר לפיכך גישות שונות של שפות תכנות שונות באשר לסוגיה זו.
⌘תחילת{ספרור}
•⌘גיבור{הגישה האוטרקית - פסקל:} על פי ⌘מונח{הגישה האוטרקית}, קיימת בתכנית מילה מוגדרת מראש, שחייבת להופיע פעם אחת ויחידה בתכנית, אשר החל ממנה מתחילה לרוץ התכנית. בשפת ⌘שי{פסקל}, למשל, המילה השמורה ⌘קד{program} מגדירה את מקום תחילת ביצוע התכנית. בשפת התכנות ⌘שי{AWK}⌘הערת␣שוליים{שפת סקריפט שפותחה במעבדות בל בשנת 1977. תוכננה לעיבוד טקסט וזהו עיקר השימוש בה.} התכנית מתחילה לרוץ החל מהמילה השמורה ⌘קד{begin}, אך בשפה זו אין חובה לתת שם לבלוק ממנו מתחיל הביצוע.
• ⌘גיבור{הגישה המטאפיזית - שפת ⌘סי:} ⌘מונח{הגישה המטאפיזית} היא הנפוצה יותר בשפות תכנות, לפיה ריצת התכנית מתחילה בפונקציה בעלת שם מסוים, אלא ששם זה אינו מוגדר מראש, אלא ניתן לשינוי ע"י המשתמש. שם הפונקציה ממנה מתחילים 
בפרט אינו מוגדר על פי סביבת העבודה. בשפת ⌘סי, למשל, ממומשת גישה זו, ולא קיימת מילה המקבילה
ל-⌘קד{program} בְּPascal. ריצת התכנית מתחילה בדר"כ מהפונקציה ⌘קד{main}, ועם זאת אפשר לשנות זאת באמצעות
הגדרות ההידור של תכנית. להלן דוגמה לכך משפת ⌘סי: (המקור- מסמך "צעדים ראשונים", עמוד 20)
\begin{CPPn}
  /* Hello, World! in C for MS-Windows */

  #include <windows.h>

  int PASCAL WinMain(HINSTANCE hInstance,
  HINSTANCE hPrevInstance, LPSTR CmdLine, int Show)
  {¢¢
    MessageBox(
    GetActiveWindow(),
    "Hello, World!",
    "Hello Windows World",
    MB_OK);
    return 0;
  }
\end{CPPn}
• ⌘גיבור{הגישה ההוליסטית - ⌘גאוה:} גישה שמכלילה את הגישה הקודמת. לפי גישה זו, נקודת התחלת הביצוע עודנה חיצונית לשפה עצמה, אך עם זאת השפה מגדירה קביעות מדויקות באשר לנקודת תחילת הביצוע. לא יתכן במצב זה כי תחילת הביצוע תוגדר ב⌘מונח{סביבת הפיתוח}, ולכן לא יתכן שתהיה נקודת תחילת ביצוע שונה ב-2 סביבות פיתוח שונות. הנ"ל מתקיים בשפת ⌘שי{Eiffel}, שם כותב המתכנת קובץ בתחביר הדומה לזה של השפה, בו מוגדרת בין היתר נקודת תחילת הביצוע. זהו המצב גם בשפת ג'אווה, בה ניתן באמצעות מנגנון בשם "⌘מונח{צורת התבוננות}", להתחיל ביצוע מכל מקום, בעזרת פונקציית ⌘קד{main} בכל מחלקה. הנ"ל מציב קושי בתכנון שפה יבילה והוליסטית (מדוע?).
• ⌘גיבור{הגישה של ביצוע אינטרקטיבי - שפות עם מפרשים:} בשפות מֵפוׂרַשוׂת, המצב מעט שונה. תחילת ביצוע התכנית היא בפקודה הראשונה המובאת בפני ה⌘מונח{מפרש}, וממשיכה הלאה ככל שחפץ לב המתכנת להמשיך ולתת פקודות בפני מפרשו. הנ"ל מתרחש בלולאה המכונה: ⌘קד{read-interpret-execute-loop (reipl)}. משמעותה נובעת משמה - עבור כל פקודה מבצע המפרש ארבעה שלבים בעיבוד הפקודה: קריאתה, פרשונה, ביצועה והמשך לפקודה הבאה. נקודת ההתחלה תהיה אפוא הפקודה הראשונה המוקלדת, או הנטענת לפרשון. שפה המממשת עקרון זה היא  ⌘שי{Ocaml}.
⌘סוף{ספרור}

עסקנו עד כה בנקודת תחילת הביצוע של תכניות מחשב, ועם זאת זנחנו את הנושא החשוב מכל: איך המחשב מתחיל לעבוד? הרי ידוע לכל שעל מנת להפעיל תכניות מחשב, על תכניות אחרות להפעילן טרם לכך. נשאלת השאלה מי הפעיל את התכנית הראשונה? ובכן, נסביר: בחומרת המחשב קיים קוד צרוב, כלומר סדרת הוראות בסיסיות למחשב הצרובה ב⌘מונח{זיכרון קריאה בלבד} - מדובר בקובץ הוראות בסיסי ביותר הגורם לביצוען של הפעולות ההִיוּלִיוֹת ביותר בהפעלת המחשב. הן מפעילות אחת, בשלב מסוים קוראות מידע והוראות מזיכרון המחשב, ובעקבותן מופעלת אחרת, בשרשרת עד להדלקת המחשב. למותר לציין שהתהליך כולל שלבים מרובים, בהם ניתן לעשות בדרגות שונות. למעוניינים בהרחבה: הסבר קצר, הסבר מקיף יותר, פקולטה שזהו עניינה.



§ צבת בצבת עשוייה

בהינתן שְׂפַת תכנות אוניברסלית \(\mathcal{L}\) יש טעם לשאול באיזו שפה כתוב המהדר או המפרש של   \(\mathcal{L}\). אך, כיוון ש   \(\mathcal{L}\) היא אוניברסלית, הרי אם אפשר לכתוב את המהדר (לחילופין, המפרש) של   \(\mathcal{L}\) בשפה '  \(\mathcal{L}\) הרי גם ניתן לכתוב את המהדר (לחילופין, המפרש) בשפה   \(\mathcal{L}\) עצמה. 
מתברר שמקובל מאוד לכתוב את המהדר של השפה בשפה עצמה. כך למשל, המהדר של שְׂפַת ⌘סי כתוב בִּשְׂפַת ⌘סי. המהדר של שְׂפַת ⌘גאוה כתוב בִּשְׂפַת ⌘גאוה, וכו'. כמובן שהדבר מעורר קושי: כי אם המהדר עבור שפה מסוימת כתוב באותה שפה, הרי כיצד הודר המהדר? התשובה הפשוטה היא שהמהדר הידר את עצמו, וכך הם בדרך כלל פני הדברים. אלא, שהדבר מוביל לרקורסיה אינסופית.
​§§ סוגיה תלמודית

חז"ל הבחינו בבעיה דומה של רקורסיה אינסופית מעין זו בסוגיא התלמודית הידועה בשם "צבת בצבת עשוייה". בגמרא, במסכת פסחים דף נ"ד עמוד א' נאמר:


⌘יניב{צבתא בצבתא מתעבדא וצבתא קמייתא מאן עבד הא לאי בריה בידי שמים}


ובתרגום לעברית: "הצבת אינה נעשית אלא בצבת אחרת. וראשונה מי עשאה? על כרחך מאליה נעשית בידי שמים.". כלומר, צבת שהיא מכשיר לאחיזת מטילי ברזל לשם ליבונם באש ועיבודם, עשוייה אף היא ברזל, ואף היא מיוצרת בצבת אחרת שקדמה לה. כיצד אם כן נוצרה הצבת הראשונה?
הפתרון המוצע על ידי הגמרא הוא שהצבת הראשונה נבראה בערב שבת הראשון, בזמן "בין השמשות", שעה שאלוהים סיים לברוא את כל הדברים האחרים, והתכונן לשבות ממלאכתו לקראת ירידת השבת. 
פתרון ניסי שכזה אינו בא בחשבון עבור שפות תכנות. מסכת פסחים מציגה גם דרך אחרת שבה יוצרה הצבת הראשונה (על ידי דפוס נחושת). לעומת זאת, בשפות תכנות, ניתן לבצע תהליך של ⌘setLTR{⌘מונח{bootstrapping}} שבאמצעותו ⌘setRTL{ניתן} לפתח מהדר המסוגל להדר את עצמו.
§§ מדד לאלגנטיות של שפה
אבן בוחן מרתקת לאלגנטיות של שְׂפַת תכנות היא אורך המהדר (או המפרש) של השפה, כאשר הוא כתוב בשפה עצמה. שהרי ככל שהשפה מורכבת ומתוחכמת יותר, מחד קל יותר לכתוב את המהדר, אך מאידך המהדר לעסוק בכל המורכבות והעושר הזה. 
לחילופין, שפה שהיא פשוטה ביחס (כמו שְׂפַת ה ⌘שי{batch} של ⌘קד{DOS}) שהוזכרה מעלה, היא קלה אולי להידור, אבל הפשטות של השפה מהווה אבן נגף בבואנו להשתמש בה כדי לכתוב מהדר.
הנה מספר אורכים אופייני של מהדר לשפה הכתוב בשפה עצמה:
⌘תחילת{ספרור}
•מהדר לשפת ⌘סי הכתוב בשפה עצמה, דורש כמה עשרות אלפי שורות. המהדר ⌘שי{gcc} מפרס על פני כשבעה מיליון שורות קוד. 
•המהדר הראשון לשפת פסקל, אשר נכתב בִּשְׂפַת ⌘פסקל דרש כשבעת אלפים ומאתיים שורות.
•מפרש לשפת ליספ הכתוב בליספ, הידוע גם כפונקציה האוניברסלית ⌘קד{eval} דורש כמאה שורות, או מעט פחות מכך. 
⌘סוף{ספרור}
לעומת זאת, מפרש בסיסי לשפת פרולוג הכתוב בפרולוג יכול להכתב בשורה אחת בלבד, ומפרש מתוחכם, המאפשר למשל מעקב אחרי החישוב, לא ידרוש בדרך כלל יותר מעשר שורות.
​§§​ הגדרת שפות להגדרת שפה פורמלית, באמצעות עצמן
מהי שפה פורמלית, כל שְׂפַת תכנות היא שפה פורמלית. ישנן שפות פורמליות שאינן שפות תכנות.
שפות תכנות אינן מכניזים נוח להגדרת שפה פורמלית. 
מכניזמים להגדרת שפות פורמליות. מתברר שגם מכניזמים אלו הם שפה פורמלית.

בדרך כלל, קל הרבה יותר להגדיר שפה פורמלית, מאשר לכתוב מהדר של השפה בעזרת עצמה. 
הנה דוגמאות. 
​§§§ הגדרת BNF בעזרת עצמו
​§§§ הגדרת EBNF בעזרת עצמו
​§§§ ביטוי רגולרי המגדיר מהו ביטוי רגולרי חוקי
קל להגדיר את משפחת ה BNF באצעות ביטוי רגולרי.
קל להשתמש ב BNF כדי להגדיר מהו ביטוי רגוליר.
אבל, ניתן להגדיר ביטוי רגולרי באמצעות ביטוי רגולרי? לא! רקורסיה.
טבלת סיכום, הגדרה הדדית.

מסיבה זו, השפות BNF וְ-EBNF הן אלגנטיות יותר מביטויים רגולריים.

​§​ המספר השלם החיובי הקטן ביותר שאי אפשר לתאר בתריסר מילים או פחות
המשפט "הַטִּבְעִי הַקָּטָן בְּיוֹתֵר מֵאֵלּו שֶׁאֵינָם גְּדִירִים בְּפָחוֹת מִתְּרֵיסָר מִלִּים" הוא מופע של הפרדוקס של ברי. לִכְאוֹרָה, ברור שקיימים המונים של טבעיים מהסוג הנדון במשפט, שכן מספר הטבעיים גדול בהרבה ממספר ההגדרות. יש הלא אינסוף טבעיים ולעומתם, מספר ההגדרות האפשריות הוא סופי, על אף היותו עצום ורב⌘הערת␣שוליים{ואף מספר זה הוא אפסי לאין שיעור לעומת המספר של גרהאם, מספר טבעי שהוא כה גדול, שהיקום כולו אינו מספיק לכתיבתו, אפילו לא בצורת מגדל חזקות, ואפילו אם נניח שכל ספרה תופסת את נפח פלאנק בלבד. בכל זאת, את המספר של גרהאם של ניתן להגדיר בפחות מתריסר מילים: "המספר הגדול ביותר ששימש אי פעם בהוכחה מתימטית עד שנת 1980". 
}. שהרי, יגדל מספר המילים בשפה העברית ככל שיגדל, סופי הוא יוותר עדיין. ממילא, מספר הצירופים בני פחות מתריסר מילים בשפה העברית, לא יוכל להיות אינסופי. 
נסמן על כן בְּ-⌘שי{X} את הקבוצה האינסופית של המספרים שאינם גדירים. הרי ודאי שימצא ב-⌘שי{X} אחד, ⌘שי{x}, הקטן שבחבריו, כלומר כזה ⌘שי{x} הנקבע על ידי:
\[
\exists x\in X\mbox{}\forall x'\in X\mbox{}x'\ne x\mbox{}\Rightarrow x'>x
\]
אלא, וכאן נגלה הפרדוקס שבדבר, שכן המשפט שהובא בפתיח נצרך לתשע של מילים בלבד כדי להגדיר את ⌘שי{x} זה עצמו, ועל כן על כרחך נמצאת אומר $x\notin X$.

ההיתר של הפרדוקס נגלה מהבנת השוני בין הגדרה מתימטית "רגילה" ובין שפה טבעית. הפרדוקס שבמשפט, אשר כתוב בשפה טבעית, נובעת מכך שהמשפט מדבר על משפטים אחרים בשפה הטבעית. בשפה טבעית קיימת אפשרות לנסח בשפה עצמה משפטים הנוגעים למשפטים אחרים בשפה עצמה. עצימת העין נוכח הקשיים שבמגבלות של התייחסות עצמית, היא זו שמביאה לסתירה.
בניסוח המשפט האמור או כל גִּרְסָה אחרת שלו⌘הערת␣שוליים{ ובפרט, המשפט שמופיע בכותרת סעיף זה (ואגב, הערת שוליים זו, אף היא דוגמא לטקסט בשפה טבעית המתייחס לעצמו.)
}, טמונה הנחה סמויה לפיה קיימת משמעות מדוייקת למונחים "גדיר", "בר-הגדרה" או "ניתן לתיאור".

נכון, נדמה כאילו אנחנו יודעים לזהות הגדרה מדוייקת כשזו מופיעה לפנינו, ולדחות מלפנינו כל הגדרה ערטילאית או לא מדוייקת. אך מתברר כי אי אפשר לעשות זאת בהיסח הדעת במבנים שכליים כגון תיאוריה מתימטית או שפה טבעית, שהם מורכבים מספיק כדי להכיל "התייחסות עצמית". "התייחסות עצמית" זו היא שעומדת מאחורי הפרדוקס של ברי, כמו גם הפרדוקס של ראסל ⌘גיבור{("תהי $U$ הקבוצה של כל הקבוצות שאינן מכילות את עצמן, האם $U\in U$?")} ופרדוקסים אחרים⌘הערת␣שוליים{ובהם פרדוקס הגלב, הפרדוקס של בהארטירהארי, והפרדוקס של גרלינג-נלסון, הדן בלוגיקות שאינן עוסקות בעצמן. }.

בפרט, המשפט שבפתיח הוא הגדרה העוסקת בהגדרות. כיוון שמשפט זה הוא הגדרה בעצמו, הוא עוסק בעצמו.  אמרנו שהפרדוקס שבמשפט נובע מההנחה הסמוייה שהמונח "גדיר", הוא אכן מוגדר היטב.  ציינו, שההטעייה המבריקה שבמשפט היא שאכן, בדרך כלל, קל להבחין בין משהו שניתן להגדרה, ומשהו שאינו ניתן להגדרה. הפרדקוס יופרך משנשים לב לכך  שההבחנה הקלה בין הגדרה ובין "לא הגדרה" נכשלת כשהיא נדרשת להגדרות, כמו המשפט שבפתיח, שמתייחסות לעצמן. הפרדוקס של ברי מוכיח מגבלה מהותית של שפה אנושית⌘הערת␣שוליים{המונח שפה אנושית כולל גם שפות טבעיות מהאטרוסקית אל שְׂפַת הפקצות, ושפות מלאכותיות, מהאספרנטו ועד הננדורינית שדיברו אותה בני לילית שבחבל ננדור שבארץ התיכונה. 
}. בפרט, ניתן (במאמץ הגדרתי לא מבוטל) לנסח משפט מתימטי שמשמעותו היא הבאה 

\noindent\fbox{%
    \parbox{\textwidth}{%
תהי H שפה אנושית שהיא מורכבת מספיק כדי לאפשר:
⌘תחילת{ציינון}
• דיון על השפה בתוך השפה עצמה, 
• דיון על קבוצות לא חסומות בגודלן.
⌘סוף{ציינון}
הרי בתוך השפה H ישנם משפטים שלא ניתן לתת להם משמעות עקבית עם שאר מרכיבי השפה. 

    }%
}

נדגיש שתי אלו: 
⌘תחילת{ציינון}
• אי אפשר ליצור את הפרדוקס בלא שהשפה H תהיה מסוגלת להכיל היגדים בדבר "קבוצת כל מי שאפשר לתאר ב H באמצעות תריסר מילים". הפרדוקס נשען על היגד זה.
• לעומת זאת, אין צורך לדרוש שהשפה H תהיה מורכבת דיה כדי לדון במספרים או במתימטיקה. כל שנדרש הוא האפשרות לדון בקבוצות לא חסומות. ניתן לנסח את הפרדוקס של ברי כך שיסוב על סדריות, ואפשר גם לנסות לכתוב:  ⌘גיבור{"הַפְּרִיט הָרִאשׁוֹן שֶׁיִּמָּכֵר בְּ-⌘שי{EBAY} מִבֵּין אֵלּוּ שֶׁתֵּאוּרָם נִדְרָשׁ לְיוֹתֵר מִתְּרֵיסָר מִלִּים"}. ניסוח זה מדגים היטב את הדרישה לדיון בקבוצה בלתי חסומה. אין במשפט משום כל, אם קבוצת הפריטים שעשויה להימכר ב ⌘שי{EBAY} היא קטנה ממספר התיאורים בני תריסר מילים או פחות. לעומת זאת, הפרדוקס נוצר אם מספר הפריטים שיכול להמכר ב-⌘שי{EBAY} הוא בלתי חסום, ולכן גדול ממספר התיאורים הללו. 
קורט גֶדֶל הכיר בעובדה שמשפט מתימטי מוביל לפרדוקס אם המשפט טוען שהוא עצמו אינו נכון. אבל הוא גם הבחין בכך שאין פרדוקס במשפט הטוען שהוא עצמו אינו יָכִיחַ. משפט אי השלמות הראשון של גֶדֶל הוא ניסוח מתימטי מדוייק של הטענה לעיל בדבר שפה טבעית.
⌘סוף{ציינון}

קורט גֶדֶל הכיר בעובדה שמשפט מתימטי מוביל לפרדוקס אם המשפט טוען שהוא עצמו אינו נכון. אבל הוא גם הבחין בכך שאין פרדוקס במשפט הטוען שהוא עצמו אינו יָכִיחַ. משפט אי השלמות הראשון של גֶדֶל הוא ניסוח מתימטי מדוייק של הטענה לעיל בדבר שפה טבעית.


\noindent\fbox{%
    \parbox{\textwidth}{%
בכל תיאוריה מתימטית $ T $ אשר מקיימת את התנאים הבאים:
⌘תחילת{ציינון}
• העדר סתירות 
• מורכבת מספיק כדי להכיל את האקסיומות של המספרים הטבעיים.
⌘סוף{ציינון}
קיים משפט $ T $,  כך ש $ T \in T $, הוא נכון, אך לא יָכִיחַ בתיאוריה $ T $.

    }%
}
האינטואיציה של הוכחת משפט אי השלמות הראשון של גדל מתחילה בדיון בפרדוקס של ברי. אלא שבתיאוריות המתימטיות של גדל, קל למשפטים שמדברים על עצמם. הסיבה היא שבמערכת מתימטית שהיא מספיק מורכבת כדי להכיל את המספרים הטבעיים מצטיינת בתכונות הבאה:
⌘תחילת{ציינון}
• כל משפט, הוכחה או טענה, ניתנים לקידוד כמספר טבעי בודד. (קידוד זה נקרא קידוד גדל, ואפשר לבנות אותו למשל באמצעות התרגום של כל משפט לכתיב ה-ASCII).
• כל משפט שעוסק במספרים, עוסק לפיכך גם במשפטים, וגם בהוכחות של משפטים.
⌘סוף{ציינון}
 המשפט $ T $ נבנה באופן הבא: נסתכל על כל ההוכחות האפשריות בתיאוריה $ T $, נקודד כל הוכחה כזו כמספר טבעי, ואחר נבנה מספר טבעי אחר, מספר גדל של התיאוריה $ T $, שהוא גם נכון כמשפט, וגם לא      יָכִיחַ בתיאוריה $ T $. מספר גדל של תיאוריה מסוימת, הוא קידוד של משפט נכון אך לא יָכִיחַ בתיאוריה. הבניה של מספר גדל היא מפורשת. היא בונה מספר כזה המקודד משפט שהוכחתו שונה מזו מכל ההוכחות הקיימות בשפה. ואינה נובעת משיקולי ספירה.

 במילים אחרות, משפט אי השלמות של גדל אומר שתיאוריה מתימטית אם היא לא טריביאלית, היא לא שלמה. 


וכיצד כל זאות קשור לנושא?

§ הסכנה שבתכניות המשעשעות המדפיסות את עצמן

מהי תכנית המדפיסה את עצמה? ובכן, הגדרה נאיבית תהיה תכנית אשר הפלט שלה היא היא עצמה, אך נחדד, שהרי גם התכנית הריקה תענה על הגדרה זו, ולא נרצה פתרון פשטני כל כך שייחשב פתרון תקף לבעיה אלגנטית זו. לא נרצה גם שתכנית שמקבלת את עצמה כקלט טקסטואלי ומדפיסה טקסט זה תיחשב, שכן מדובר בפתרון טכני בלבד. 

לפיכך, ההגדרה היא כדלקמן: תכנית המדפיסה את עצמה, ⌘מונח{דפסן}, היא תכנית לא ריקה אשר לא מקבלת קלט והפלט היחידי שלה הוא התכנית עצמה (כך נימנע גם מלכלול תכניות אשר מדפיסות לאורך הזמן את כל הפלטים האפשריים, בזה אחר זה, עד אשר תדפיס בעת מסוים את עצמה). תכניות מעין אלו מהוות אבן שואבת במדעי המחשב, וניתן להתייחס אליהן בצורה מתמטית באופן הבא: אם נתייחס לסביבת הביצוע כאל פונקציה (מקבוצת התכניות אל קבוצת הפלטים), נקבל כי תכנית המדפיסה את עצמה היא נקודת שבת⌘הערת␣שוליים{⌘שי{Fixed Point}. נציין כי למונח הרחבות רבות בתחום הטופולוגיה המתמטית, המכלילות את המונח למרחבים מטריים שונים. לפרטים נוספים.}. 

בנוסף, מבחינה ספרותית, ניתן לומר שקוד שכזה הוא קוד ארס-פואטי, שכן הוא עוסק בכתיבת קוד בעצמו. 

נראה מספר דוגמאות⌘הערת␣שוליים{ראוי להדגיש נקודה חשובה זו.} לתכניות המדפיסות את עצמן:

⌘גאוה:
\begin{JAVAn}
public class Quine
{
  public static void main(String[] args)
  {
    char q = 34;      // Quotation mark character
    String[] l = {    // Array of source code
    "public class Quine",
    "{",
    "  public static void main(String[] args)",
    "  {",
    "    char q = 34;      // Quotation mark character",
    "    String[] l = {    // Array of source code",
    "    ",
    "    };",
    "    for(int i = 0; i < 6; i++)           // Print opening code",
    "        System.out.println(l[i]);",
    "    for(int i = 0; i < l.length; i++)    // Print string array",
    "        System.out.println(l[6] + q + l[i] + q + ',');",
    "    for(int i = 7; i < l.length; i++)    // Print this code",
    "        System.out.println(l[i]);",
    "  }",
    "}",
    };
    for(int i = 0; i < 6; i++)           // Print opening code
        System.out.println(l[i]);
    for(int i = 0; i < l.length; i++)    // Print string array
        System.out.println(l[6] + q + l[i] + q + ',');
    for(int i = 7; i < l.length; i++)    // Print this code
        System.out.println(l[i]);
  }
}
\end{JAVAn}


⌘setRTL{:Perl}⌘setLTR{}

\lstset{language=Perl}
\begin{lstlisting}[frame=single]
$_=q{print"\$_=q{$_};eval"};eval
\end{lstlisting}


⌘setRTL{:Python}⌘setLTR{}
\lstset{language=Python}
\begin{lstlisting}[frame=single]
s = 's = %r\nprint(s%%s)'
print(s%s)
\end{lstlisting}
⌘setRTL{}
ולהלן דוגמה ב-שיא חד, המלווה בהסבר ובהרחבה.



מהו הטריק⌘הערת␣שוליים{סיבה נוספת להתעניינות בנושא זה היא הופעתו כשאלה בשיעורי הבית, בסמסטר בו נכתב סיכום זה.} שבזכותו עובדות תכניות אלו? ניתן לחלק באופן גס את הקוד ל-2 חלקים: 
⌘תחילת{ספרור}
• מערך מחרוזות ו/או אוסף קבועים, אשר מכילים את קוד הביצוע של התכנית.
• קוד הביצוע של התכנית, אשר מכיל הוראות להדפסה פעמיים של מערך המחרוזות המדובר, וכן קבועים נוספים הדרושים לשכפול מדויק של הקוד לתוך מה שיודפס. 
⌘סוף{ספרור}
בריצת התכנית יודפס, כאמור, פעמיים המערך והתווים הרלוונטיים - בפעם הראשונה עבור הדפסת החלק הראשון של התכנית (מערך המחרוזות), ובפעם השנייה עבור הדפסת החלק השני - קוד הביצוע ממש. 

עם זאת, טמונה בקודים מעין אלו סכנה של ממש. תכניות כאלו עשויות להוות כלי להחדרה של ⌘מונח{וירוסים}⌘הערת␣שוליים{למעשה, מינוח מדויק יותר הוא סוס טרויאני, מונח שעל משמעותו ניתן וראוי לדון רבות.} בידי זֵדִים⌘הערת␣שוליים{הסבר מלא למילה זֵד שֵם ז: בלשון המקרא אדם רע, רשע; "טָפְלוּ עָלַי שֶׁקֶר זֵדִים" (תהלים קיט סט). [מילון רב-מילים]}. כתב על כך ⌘מונח{קן תומפסון}⌘הערת␣שוליים{אבי !UNIX חלוץ אמריקאי בתחום מדעי המחשב, ידוע בשל תרומתו לפיתוח שפות התכנות B,Go והגדרת UTF-8} במאמרו⌘הערת␣שוליים {להבנה מלאה יותר של אופן הפעולה של סוס טרויאני, ניתן ללחוץ כאן.
 }.

נתחיל בתיאור מנגנון רלוונטי. נניח שנתון לנו קובץ המקור של המהדר של שפת ⌘סי, ונרצה להכניס בו שינוי מסוים - נרצה שבהינתן תו הבקרה ⌘קד{v/} , תודפס מפלצת ⌘קד{ASCII} הזו. כיצד נעשה זאת? ובכן, בהינתן קוד המקור האידיאלי הבא של המהדר, נגלה כי אין זו משימה קשה במיוחד:

מדובר בקוד המקבל תווים בשפה, ומחזיר את התו הרלוונטי עבור כל מקרה. היות שהמהדר של שפת ⌘סי כתוב בעצמו בשפת ⌘סי, המהדר של השפה "מכיר" את התווים המיוחדות האלו, ויודע "מה לעשות". 

על מנת להשלים את הקוד על מנת שיכיל את התוספת שלנו (ידוע שהדפסת מפלצות ⌘קד{ASCII} שכאלו מביאה למורת רוח מרובה בקרב המשתמשים), נבצע את השינוי הבא: 
הוספנו את השורה המתאימה, וננסה עתה להדר את הקובץ החדש של המהדר באמצעות המהדר הישן שברשותנו. אך, אבוי, שוד ושבר, נקבל שגיאה! הרי המהדר הישן לא יודע מפלצות ⌘קד{ASCII} מהן, ולא יודע מהו התו ⌘קד{v/}. 

נרצה לפיכך "לאלף" את המהדר הישן להכיר תוסף זה, על מנת שיוכל להדר אותו, ולהפוך אותו ל⌘מונח{מהדר} תקני המכיל את השינוי. ניגש אפוא לקובץ המקור של המהדר הישן, ונוסיף בו את השינוי הבא (אחרון, מבטיחים!):
כעת, המהדר הישן מכיר את התו ⌘קד{v/}. נניח שקיימת מחרוזת תווים כלשהי, המייצגת את מפלצת ה-⌘קד{ASCII} המועדפת עלינו, וכי היא מיוצגת ע"י ה-11 בדוגמה שלהלן. נהדר באמצעותו את המהדר החדש שכתבנו, ונקבל ⌘מונח{קובץ} ⌘קד{binary} שמכיל ⌘מונח{מהדר} חדש, המטמיע את התוספת החדשה. ניתן באמצעות תוצר זה להדר תכניות שיבצעו תוספת זו.

באופן דומה, אך זהה מבחינה רעיונית, ניתן, לאחר מאמץ מחשבתי ניכר, לתאר נזקים כבירים אף יותר מהופעה של מפלצת (מאיימת ככל שתהיה) על צג המחשב. דוגמה לכך היא פריצה לחשבונות פרטיים במערכות ⌘שי{UNIX}, ע"י הוספת פרצה, לפיה ניתן יהיה להתחבר לכל חשבון באמצעות סיסמא כלשהי (נניח ⌘קד{iAmHackerHoHoHo}). בשלב הבא, נבצע את התהליך כפי שביצענו בדוגמה הקודמת, ובאמצעותו נקבל את מערכת ⌘שי{UNIX} החדשה, בה תהיה קיימת פרצה זו. הפרצה תהיה מקודדת ומוטמעת במערכת החדשה, ללא יכולת זיהוי. זהו ⌘מונח{סוס טרויאני} עמיד בפני התקפות.






