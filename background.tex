§ הגדרות רקורסיביות
נאמר על קבוצה~$S$ שהיא מוגדרת באופן רקורסיבי (או בנוייה באופן רקורסיבי, או
לעיתים גם בנויה באופן אינדוקטיבי) אם ההגדרה של~$S$ מבדילה בין שני סוגים של
איברים: איברים אטומיים ואיברים מורכבים.  איברים מורכבים נוצרים באמצעות בנאי
איברים מאיברים אטומיים ואיברים מורכבים אחרים:
גדרה רקורסיבית מתאפייינת גם בתכונה נוספת:
\begin{itemize}
  ✦ \ע|שלמות ההגדרה|. הגדרה רקורסיבית של הקבוצה~$S$ כוללת תמיד בתוכה מרכיב
  הדורש שאין ב-$S$ איברים אחרים מלבד האיברים האטומיים ואלו שנוצרו באמצעות בנאים.
  בדרך כלל הדרישה שבמרכיב זה של אינה נאמרת במפורש, אלא משתמעת מהניסוח. 
  \end{itemize}

\פסקה{הערות}
\החל{אבגוד}
✦ לעיתים נתייחס לאיברים האטומיים של קבוצה מוגדרת רקורסיבית כבנאים שהם nullary,
כלומר בנאים שאינם מקבלים ארגומנטים.
✦ גדלן של קבוצות המוגדרות רקורסיביות הוא בלתי חסום בדרך כלל, שכן תמיד ניתן
להשתמש בבנאים כדי ליצור איברים נוספים.
✦ קבוצה מוגדרת רקורסיבית יכולה להיות בעלת גודל סופי:
\ציינן
✦ אם הגדרת הקבוצה מכילה יחס שקילות, שגורם לכך שהפעלה אינסופית של בנאים, יוצרת
רק אוסף סופי של איברים שקולים.
✦ אם הבנאים אינם כאלו שתמיד ניתן להפעילם.
===
\סוף
{אבגוד}


§§ הגדרה רקורסיבית של קבוצת הפונקציות הרציונליות

נגדיר לדוגמה באופן רקורסיבי את~$ℚ₁$, קבוצת הפונקציות הרציונליות במשתנה אחד. כל
איבר~$f$ בקבוצה~$ℚ₁$ הוא פונקציה חלקית מ-ℝ (קבוצת המספרים הממשיים) אל~$ℝ$ .
כלומר~$f:ℝ⇸ℝ$. הכוונה במונח פונקציה חלקית היא שייתכן כי קיים ערך מסויים~$ℝ∈x$,
שעבורו ערך הפונקציה~\E|$f(x)$| אינו מוגדר. אנו נשתמש בסימון~$⊥$ כדי לציין את הערך
הלא מוגדר. ניתן לכן לכתוב~$f:ℝ→ℝ∪❴⊥❵$. בניסוח אחר,~$ℚ₁⊆ℝ⇸ℝ$, כלומר~$ℚ₁$ היא
קבוצה חלקית של קבוצת הפונצקיות החלקיות מ-$ℝ$ אל~$ℝ$.

\החל{definition}\label{definition:rationals}
הקבוצה ב-$ℚ₁$, קבוצת הפונקציות הרציונליות במשתנה אחד, מוגדרת על ידי שלושת
התנאים הבאים:
\begin{enumerate}
  ✦ \ע|איברים אטומיים של קבוצת הפונקציות הרציונליות|
  \begin{itemize}
    ✦ הפונקציה~$U$, המעתיקה כל מספר ממשי אל המספר הטבעי~$1$,
    \begin{equation*}
      ∀ x∈ℝ∙ U(x)=1,
    \end{equation*}
    נמצאת בקבוצה~$ℚ₁$,
    כלומר
    \begin{equation}\label{eq:1}
      U∈ℚ₁
    \end{equation}
    ✦ פונקצית הזהות,~$I$, המעתיקה כל מספר ממשי אל עצמו,
    \begin{equation*}
      ∀ x∈ℝ∙ I(x)=x
    \end{equation*}
    נמצאת בקבוצה~$ℚ₁$, כלומר
    \begin{equation}\label{eq:x}
      I∈ℚ₁
    \end{equation}
  \end{itemize}
  ✦ \ע|בנאים של קבוצת הפונקציות הרציונליות|
  \begin{itemize}
    ✦ אם הפונקציה~$f$ שייכת ל-$ℚ₁$ אזי גם הפונקציה~$-f$ שייכת לקבוצה זו, כלומר
    \begin{equation}\label{eq:minus}
-f∈ℚ₁.
    \end{equation}
    ✦ אם שתי הפונקציות~$f₁$ ו-$f₂$ שייכות ל-$ℚ₁$ אזי גם הסכום שלהן, המכפלה
    שלהן, והמנה שלהן שייכות ל-$ℚ₁$, כלומר
    \begin{align}
      f₁+f₂ &∈ℚ₁, \label{eq:plus} ⏎
      f₁·f₂ &∈ℚ₁ \label{eq:times} ⏎
      f₁/f₂ &∈ℚ₁. \label{eq:div}
    \end{align}
  \end{itemize}
  ✦ \ע|שלמות ההגדרה: אין פונקציות רציונליות חוץ מהאטומיות ואלו שנוצרו באמצעות
  הבנאים| ⏎
  הקבוצה~$ℚ₁$ היא הקבוצה הקטנה ביותר של פונקציות המקיימת את התנאים
  \פנה|eq:1|,
  \פנה|eq:x|,
  \פנה|eq:minus|,
  \פנה|eq:plus|,
  \פנה|eq:times|
  ו-\פנה|eq:div|.
\end{enumerate}
\סוף{definition}

§§ כתיב של כללי היסק

ניסוח תמציתי ומדוייק לבנאים הוא ככללי היסק \E|(inference rules)| כפי שהם נהוגים
בתחשיב הפסוקים. כלל היסק האומר שבכל פעם שמתקיימות ההנחות~$P₁,P₂,…,Pₙ$ ניתן
להסיק את המסקנה~$Q$ יכתב כך: \[
  \dfrac{\begin{array}{c}P₁ ⏎P₂ ⏎⋮ ⏎Pₙ\end{array}}{Q}
\] ניתן גם לכתוב את הדרישות בשורה אחת, ובלבד שהן מופרדות זו מזו, \[
  \infer Q{P₁ & P₂ &⋯& Pₙ}
\] לדוגמה, את הבנאי \פנה|eq:plus| של הקבוצה~$ℚ₁$, ניתן לכתוב ככלל היסק:
\begin{equation*}
  \infer{f₁+f₂∈ℚ₁}{f₁∈ℚ₁ & f₂∈ℚ₁}
\end{equation*}
בכלל היסק זה יש שתי הנחות~$P₁=f₁∈ℚ₁$ ו-$P₂=f₂∈ℚ₁$. כל אחת מההנחות צריכה להיקרא
ככמת אוניברסלי כפי שהוא מופיע בתחשיב הפסוקים, כלומר, עבור כל בחירה של
פונקציה~$f₁$ המקיימת~$f₁∈ℚ₁$ ולכל בחירה של פונקציה~$f₂$ המקיים~$f₂∈ℚ₁$ נובעת
המסקנה~$Q=f₁+f₂∈ℚ₁$. בניסוח אחר כלל ההיסק אומר כי \[
  ∀f₁∀f₂❨f₁∈ℚ₁∧f₂∈ℚ₁→f₁+f₂∈ℚ₁❩.
\] ניתן לנסח את ארבעת הבנאים של הקבוצה~$ℚ₁$, כלומר \פנה|eq:minus|,
\פנה|eq:plus|,
\פנה|eq:times|
ו-\פנה|eq:div|,
ככלל היסק אחד:
\begin{equation*}
  \infer{-f₁,f₁+f₂, f₁·f₂,f₁/f₂∈ℚ₁}{f₁∈ℚ₁&f₂∈ℚ₁}
\end{equation*}

ניתן גם לנסח את הגדרת האיברים האטומיים של הקבוצה~$ℚ₁$, כלומר \פנה|eq:1|
ו-\פנה|eq:x|,
כשני כללי היסק אשר קבוצת ההנחות שלהן ריקה,
\begin{equation*}
  \begin{array}{ccc}
    \infer{I∈ℚ₁}{} &  & \infer{1∈ℚ₁}{}
  \end{array}\hfill
\end{equation*}
או בקיצור, ככלל היסק אחד שגוזר שתי מסקנות מקבוצת הנחות ריקה
\begin{equation*}
  \infer{1, I∈ℚ₁}{}
\end{equation*}
לדוגמה, \[
  \frac {I+1}{I·I-3·I+1}
\] הוא איבר ב-$ℚ₁$, שמיייצג את הפונקציה~$f(x)=(x+1)/(x²-3x+1)$.

ניתן להשתמש במבנה ההגדרה הרקורסיבי של קבוצה בהגדרות רקורסיביות נוספות המתייחסות
לקבוצה ולאיבריה.

\begin{definition}[ערך של פונקציה רציונלית]
  עבור פונקציה רציונלית~$f∈ℚ₁$, ועבור כל מספר ממשי~$x∈ℝ$ נגדיר את~$f(x)$
  רקורסיבית
  \begin{equation}\label{eq:value}
    \begin{array}{cc}
      U(x)=1                            & I(x)=x ⏎ ⏎
      \infer{-f(x)=-x₁}{f(x)=x₁}        & \infer{(f₁+f₂)(x)=x₁+x₂}{f₁(x)=x₁ & f₂(x)=x₂} ⏎ ⏎
      \infer{(f₁·f₂)(x)=x₁·x₂}{f₁(x)=x₁ & f₂(x)=x₂}                         &
      \infer{(f₁/f₂)(x)=x₁/x₂}{f₁(x)=x₁ & f₂(x)=x₂}
    \end{array}
  \end{equation}
\end{definition}

§§ אינדוקצית מבנה
הגדרות רקורסיביות מאפשרות לנו להוכיח טענות באינדוקציה הידועה בשם אינדוקצית
מבנה. באינדוקציה כזו, אנו מוכיחים ראשית כי הטענה נכונה עבור כל האיברים האטומיים
של קבוצה. בצעד האינדוקציה נעבור על כל בנאי האיברים: לגבי כל בנאי נניח שהטענה
נכונה לגבי כל האיברים עליהם פועל, ונוכיח כי הטענה נכונה גם עבור האיבר אשר אותו
יצר הבנאי. ניתן גם להסתכל על הוכחות באינדוקצית מבנה כאינדוקציה על מספר
ההפעלות~$n$ של בנאים לשם יצירת~$f$.

נוכיח לדוגמה את הטענה הפשוטה הבאה עבור ההגדרה הרקורסיבית של הקבוצה~$ℚ₁$
(\פנה|definition:rationals|) וההגדרה של ערך הפונקציה מעל \פנה|eq:value|.

\begin{claim}
  עבור כל מספר רציונלי~$q∈ℚ$, ועבור כל פונקציה רציונלית~$f∈ℚ₁$, מתקיים כי
  \begin{equation}\label{eq:Q}
    f(q)∈ℚ∪❴⊥❵
  \end{equation}
  כלומר~$f(q)$ אינו מוגדר, או שהוא מספר רציונלי.
\end{claim}

\begin{proof}
  \mbox{}
  \begin{description}
    ✦ [בסיס האינדוקציה] אם~$n=0$ אז~$f$ הוא איבר אטומי של~$ℚ₁$,
    ואז~$f=1$ או~$f=I$ וברור שאם~$q$ רציונלי, אז גם~$f(q)∈❴1,q❵$. ולכן
    \פנה|eq:Q| מתקיימת עבור~$n=0$.
    ✦ [צעד האינדוקציה] נניח שהטענה \פנה|eq:Q| מתקיימת עבור כל~$n'$, כאשר~$n'<n$
    ונוכיח אותה עבור~$n$.
    נסתכל על איבר~$f∈ℚ₁$ אשר נוצר מהפעלה של~$n$ בנאים, ונניח ש-$n>0$ כלומר~$f$
    נוצר על ידי הפעלה של בנאי. בנאי זה הוא אחד מארבעת הבנאים \פנה|eq:minus|,
    \פנה|eq:plus|, \פנה|eq:times|, או \פנה|eq:div|.
    מכאן, \[
      f(q)∈❴-q₁,q₁+q₂,q₁·q₂,q₁/q₂❵.
\] כיוון שמספר הפעולות הבנאים לשם יצירת הפונקציות~$f₁$ ו-$f₂$ קטן ממש מ-$n$
    הנחת האינדוקציה מתקיימת לגביהן, ולכן, גם~$q₁$ וגם~$q₂$ חייבים להיות רציונליים

    אם הם מוגדרים, ולכן גם~$f(q)$,
    אם הוא מוגדר, חייב
    להיות מספר רציונלי.
  \end{description}
\end{proof}

הגדרות רקורסיביות משמשות לעיתים קרובות באיפיון של שפות תכנות. אוסף הביטויים
המותר לשימוש בשפה, אוסף הפקודות, ואוסף הטיפוסים, כמעט תמיד מוגדרים רקורסיבית.

§ שפות פורמליות וביטויים רגולריים
§§ אלפאבית
אלפאבית הוא קבוצה, בדרך כלל סופית, של איברים הקרויים אותיות או סמלים. לדוגמה
הקבוצה
\begin{equation*}
  ❴⌘a,⌘b,⌘c❵,
\end{equation*}
הינה אלפאבית המכיל שלוש אותיות,~$⌘a$,~$⌘b$ ו-$⌘c$.

לאותיות האלפאבית אין משמעות מלבד העובדה שכולן שונות זו מזו. בפרק זה נשתמש בגופן
שונה כדי להבדיל בין האות עצמה, ובין מה שהאות מציינת: לכן, הכתיב~$⌘a$ מכוון אל
האות הראשונה באלפבית הלטיני, ולא למה שאות זו מציינת, ואילו הכתיב~$a$ יתייחס
למה שהאות הראשונה מציינת:
למשל, במשוואה הריבועית \[
  a x²+bx+c=0
\] הכתיב~$a$ מתייחס למקדם של~$x²$.

\דוגמה |האלפבית של שפת~\CPL|
האלפבית~$Σ_C$ המשמש לכתיבת תכניות בשפת~\CPL מכיל 95 תווים
אותם אפשר לחלק, לשם נוחות, לקבוצות הבאות:
\begin{equation}\label{alpahet:C}
  Σ_C=
  Σ_{\text{upper}}∪Σ_{\text{lower}}∪
  Σ_{\text{digit}}∪
  Σ_{\text{special}}∪
  Σ_{\text{space}}.
\end{equation}
\begin{enumerate}
  ✦ \ע|26 אותיות אנגליות גדולות| \[
    Σ_{\text{upper}}=❴⌘A,⌘B,⌘C,⌘D,⌘E,⌘F,⌘G,⌘H,⌘I,⌘J,⌘K,⌘L,⌘M,⌘N,⌘O,⌘P,⌘Q,⌘R,⌘S,⌘T,⌘U,⌘V,⌘W,⌘X,⌘Y,⌘Z❵.
\] ✦ \ע|26 אותיות אנגליות קטנות| \[
    Σ_{\text{lower}}=
    ❴⌘a,⌘b,⌘c,⌘d,⌘e,⌘f,⌘g,⌘h,⌘i,⌘j,⌘k,⌘l,⌘m,⌘n,⌘o,⌘p,⌘q,⌘r,⌘s,⌘t,⌘u,⌘v,⌘w,⌘x,⌘y,⌘z❵.
\] ✦ \ע|10 ספרות| \[
    Σ_{\text{digit}}=❴⌘0,⌘1,⌘2,⌘3,⌘4,⌘5,⌘6,⌘7,⌘8,⌘9❵.
\] ✦ \ע|29 אותיות מיוחדות| \[
    Σ_{\text{special}}=
    Σ_{\text{punctuation}}∪
    Σ_{\text{wrapping}}∪
    Σ_{\text{arithmetic}}∪
    Σ_{\text{other}}∪
    Σ_{\text{space}}.
\] המתחלקות באופן הבא:
  \begin{enumerate}
    ✦ \ע|8 אותיות פיסוק| \[
      Σ_{\text{punctuation}}=❰⌘., ⌘,, ⌘?, ⌘!, ⌘:, ⌘;, ⌘', ⌘"❱.
\] ✦ \ע|6 אותיות אריתמטיות| \[
      Σ_{\text{arithmetic}}=❰⌘+, ⌘*, ⌘/, ⌘-, ⌘<, ⌘>❱.
\] ✦ \ע|6 אותיות סוגריים| \[
      Σ_{\text{wrapping}}=❰⌘), ⌘), ⌘[ ⌘], ⌘❴, ⌘❵,❱.
\] ✦ \ע|9 אותיות אחרות| \[
      Σ_{\text{other}}=❰⌘＆,⌘\textbackslash, ⌘\textasciicircum, ⌘\_, ⌘|, ⌘∿, ⌘\$,
      ⌘\%, ⌘＃,❱.
\] \end{enumerate}
  ✦ \ע|6 אותיות רווח| \[
    Σ_{\text{space}}=❰\text{space},\text{tab},
    \text{horizontal tab}, \text{new line},
    \text{vertical tab}, \text{form feed}❱.
\] היצוג הגרפי של אותיות אלו הינו בלתי נראה, ולכן
  כתבנו כאן את שמות האותיות, ולא את היצוג הגרפי שלהן.
\end{enumerate}

מילה מעל האלפבית היא סדרה סופית של אותיות מתוך האלפבית. למשל,~$⌘{caba}$ היא
מילה בת ארבע אותיות מעל האלפבית~$❴⌘a,⌘b,⌘c❵$. בהינתן אלפאבית~$Σ$, נסמן
ב-$Σ^*$ את הקבוצה האינסופית המכילה את כל המילים באורך סופי מעל~$Σ$, לרבות
המילה הריקה, אותה בדרך כלל מסמנים ב-$ε$. בדוגמה שלנו
\begin{equation}
  ❴⌘a,⌘b,⌘c❵^*=❴ε,⌘a,⌘b,⌘c,⌘{aa},⌘{ab},⌘{ac},⌘{ba},⌘{bb},⌘{bc},⌘{ca},⌘{cb},⌘{cc},⌘{aaa},⌘{aab},…❵
\end{equation}

ניתן גם להגדיר את~$Σ^*$ רקורסיבית. בהגדרה זו, יהיה איבר אטומי אחד, המילה
הריקה~$ε$, ובנאי אונארי שמאפשר להאריך כל מילה ב-$Σ^*$ באות מתוך~$Σ$:

\החל{definition}[המילים מעל אלפאבית]
בהנתן אלפאבית~$Σ$ אזי~$Σ^*$, קבוצת ה\ע|המילים הפורמליות| מעל~$Σ$, מוגדרת
באמצעות הבנאי הנולארי (המגדיר איבר אטומי אחד ויחיד)
\begin{equation}
  \infer{ε∈Σ^*}{}
\end{equation}
והבנאי האונארי:
\begin{equation}
  \infer{wσ∈Σ^*}{w∈Σ^* &σ∈Σ}
\end{equation}
\סוף{definition}

בהסתמך על הגדרה רקורסיבית זו, נגדיר רקורסיבית את~$|w|$, מספר התווים במילה~$w$:
\החל{definition}[אורך מילה]\label{definition:length}
עבור~$w∈Σ^*$
\begin{equation}
  |w|=\begin{cases}
    |w'|+1 & w=w'σ ⏎
    0      & w=ε. ⏎
  \end{cases}
\end{equation}
\סוף{definition}

כך נקבל ש-$|ε=0|$,~$|⌘a|=1$,~$|⌘{caa}|=3$.

שפה פורמלית~$L$ מעל~$Σ$ היא אוסף של מילים הלקוחות מ-$Σ^*$, כלומר~$L⊆Σ^*$.

\דוגמה|שפת התכנות~\CPL כשפה פורמלית|
שפת התכנות~\CPL מגדירה שפה פורמלית~$L₀$ מעל האלפבית $Σ_C$ \פנה|eq:alphabet:C|:
נאמר על מילה~$w$
(כאשר~$w∈Σ_C^*$),
כי היא שייכת לשפה~$L₀$
אם ורק אם~$w$ היא תכנית חוקית בשפת~\E|\CPL|.

למעשה, כל שפת תכנות מגדירה גם שפה פורמלית. זוהי השפה אשר מילותיה הן תכניות
חוקיות בשפת התכנות. אולם, הגדרת שפת תכנות אינה מצטמצמת להגדרת השפה הפורמלית
הזו. הגדרת שפת התכנות כוללת גם מתן משמעות לכל תכנית חוקית.

§§ קבוצת הפונקציות הרציונליות כשפה פורמלית

נגדיר לדוגמה באופן רקורסיבי את השפה הפורמלית~$L₁$ שכל מילה בה יכולה להתפרש
כאיבר ב-$ℚ₁$.
\אבגד
✦ המילים האטומיות בשפה זו יהיו האותיות הבודדות~⌘U ו-⌘I. כמילים בשפה~$L₁$, לא
תהיה למילים אלו משמעות, כשנגדיר פונקציה המעניקה משמעות לכל מילה בשפה
הפורמלית~$L₁$, המשמעות של~⌘U תהיה פונקצית היחידה, והמשמעות
של~⌘I תהיה פונקצית הזהות.
✦ בנוסף נשתמש בסימנים~⌘/,~⌘*,~⌘+, ו-⌘- בתוך בנאי המילים. בשפה הפורמלית לא תהייה
לסימנים אלו משמעות, אך כשנגדיר פונקציה המעניקה משמעות לכל מילה בשפה
הפורמלית~$L₁$, פונקציה זו תפרש
ארבעה סימנים אלו כאופרטורים האריתמטיים.
✦ על ששת הסימנים האלו נוסיף גם את הסימנים ⌘(ו-⌘) כדי להבטיח שתהיה רק דרך
אחת לתת משמעות למילה בשפה הפורמלית~$L₁$.===

\החל{definition}[השפה הפורמלית של הפונקציות הרציונליות]
\label{definition:L1}
השפה~$L₁$, היא שפה פורמלית מעל האלפבית
\begin{equation}\label{eq:Q:alphabet}
  ❴⌘U, ⌘I, ⌘), ⌘), ⌘/, ⌘*, ⌘+, ⌘-❵
\end{equation}
המוגדרת על ידי שני איברים אטומיים
\begin{align}
   & \infer{⌘U∈L₁}{} ⏎
   & \infer{⌘I∈L₁}{}
\end{align}
ועל ידי ארבעה בנאים:
\begin{align}
   & \infer{⌘)⌘-w⌘)∈L₁}{w∈L} \label{eq:Q:minus}⏎
   & \infer{⌘)w₁⌘+w₂⌘)∈L₁}{w₁∈L₁                 & w₂∈L₁}\label{eq:Q:plus}⏎
   & \infer{⌘)w₁⌘*w₂⌘)∈L₁}{w₁∈L₁                 & w₂∈L₁}\label{eq:Q:times}⏎
   & \infer{⌘)w₁⌘/w₂⌘)∈L₁}{w₁∈L₁                 & w₂∈L₁}\label{eq:Q:div}
\end{align}
\סוף{definition}
כדאי לשים לב להבדלים בין הגדרה זו ובין ההגדרה הקודמת של הקבוצה~$L₁$
(\פנה|definition:rational|). הגדרה הנוכחית אינה מניחה ידע במתימטיקה או בפעולות
החשבון. איבר של הקבוצה היא סדרה ללא משמעות אותיות הלקוחה מהאלפבית
\פנה|eq:Q:alphabet|.
§ חתימות וביטויים פורמליים

אנו רואים באיור שמספר הבנים של צומת המכיל את האות~$a$ אינו קבוע. בחלק
מהעצים לצומת זה אין בנים כלל, ואילו בעצים אחרים יש לצומת זה בן אחד, שני
בנים, ואף שלושה. כדי להגדיר עצים שבהם לכל צומת מסוג מסויים יש תמיד מספר
בנים, נזדקק למושג החתימה.

\החל{definition}[חתימה] חתימה~$Γ$, הינה אלפאבית, (בדרך כלל סופי) עליו מוגדרת
פונקצית ערכיות~$\arity$ המתאימה לכל אות~$γ∈Γ$ מספר שלם אי שלילי,~$\arity:Σ→ℕ⁺$.
עבור חתימה~$Γ$, נסמן ב-$Γₙ$ את תת הקבוצה של איברי~$Γ$
שה-$\arity$ שלהם הוא~$n$
\begin{equation*}
  Γₙ=❴γ∈Γ\,|\,\arity(γ)=n❵.
\end{equation*}
\סוף{definition}

ביטויים פורמליים מעל חתימה דומים לעצים מעל אלפאבית, בצירוף המגבלה שלצומת
המסומנת באות~$n_γ∈Γ$, יש בדיוק~$\arity(γ)$ בנים. פורמלית,

\החל{definition}[ביטויים פורמליים מעל חתימה]
בהנתן חתימה~$Γ$ אזי,~$E(Γ)$, קבוצת הביטויים הפורמליים מעל~$Γ$
מוגדרת באמצעות הבנאי ה-$n$ מקומי,
\begin{equation*}
  \infer{γ(τ₁,⋯,τₙ)∈T(Γ)}{γ∈Γ & n≥0 &γ∈Γₙ&τ₁∈T(Γ) &⋯&τₙ∈T(Γ) }
\end{equation*}
\סוף{definition}
\פסקה{דוגמה: ביטויים סימבוליים כביטויים פורמליים}
בהינתן אלפאבית~$Σ$, נבנה ממנו חתימה~$Γ$ באופן הבא:
\begin{align*}
   & Γ=Γ₀∪Γ₂ ⏎
   & Γ₀=Σ ⏎
   & Γ₂=❴⌘.❵
\end{align*}
קל לראות שהביטויים הפורמליים ב-$E(Γ)$ הם בדיוק בעלי אותו מבנה כמו הביטויים
הסימבוליים בקבוצה~$S(Σ)$.

\פסקה{דוגמה: ביטויים חשבוניים}
נסתכל למשל על החתימה הבאה
\begin{equation}
  \begin{split}
    & Γ=Γ₀∪Γ₁∪Γ₂ ⏎
    & Γ₀=❰⌘0,⌘1,⌘2,⌘3,⌘4,⌘5,⌘6,⌘7,⌘8,⌘9❱^*⏎
    &\quad=❴⌘0,⌘1,⌘2,…,⌘10,⌘11,…,⌘{100},⌘{101},…,⌘{1000},⌘{1001},…❵ ⏎
    & Γ₁=❴⌘-,⌘!❵ ⏎
    & Γ₂=❴⌘+,⌘*,⌘/❵
  \end{split}
\end{equation}
גדלה של חתימה זו הוא אינסופי. ה-arity של הסימנים~$⌘+$,~$⌘*$ ו-$⌘/$
הוא 2, ה-arity של הסימנים ⌘! ו-$⌘-$ הוא 1, וה-arity של קבוצת המספרים
הטבעיים הוא 0. קבוצת הביטויים מעל חתימה זו היא לא אחרת מאשר קבוצת הביטויים
החשבוניים הבנויים ממספרים הטבעיים, האופרטורים הבינאריים של חיבור, כפל וחילוק,
והאופטורים האונאריים של השלילה, העצרת, והוצאת השורש. כמה ביטויים בקבוצה זו
מודגמים באיור הבא:

\begin{figure}[!ht]
  \centering
  \begin{tikzpicture}[every node/.style={shape=circle,
          draw, align=center,
          top color=red!10, bottom color=blue!20}]
    \begin{scope}[yshift=-10ex,start chain=growing right,minimum size=2em]
      \node[on chain,circle,draw]{⌘1};
      \node[on chain,circle,draw]{⌘0};
      \node[on chain,circle,draw]{⌘!} child {node {⌘3}};
      \node[on chain,circle,draw]{⌘!} child {node{⌘*} child{node{⌘a}} child{node{⌘-} child{node{42}}}};
      % \node[on chain,circle,draw,xshift=5ex]{⌘√{}}
      child {node{⌘/}
          child {node{5}}
          child {node{3}}
        }
      ;
    \end{scope}
  \end{tikzpicture}
  \כיתוב|ביטויים חשבוניים כעצים מעל חתימה|
\end{figure}

נשים לב שההגדרה במובן זה שהיא קובעת את מבנה העצים, ולא את המשמעות שלהם. אין שום
דבר בהגדרה הנותן משמעות של חיבור לסימן ה-⌘+. ההגדרה גם אינה מעניקה משמעות
לקבוצת המספרים הטבעיים. לדידה של ההגדרה, מספר טבעי הוא סדרת ספרות
נטולת משמעות.

§ ביטויים רגולריים

ביטויים רגולריים הם מכשיר חשוב להגדרת שפות פורמליות מעל אלפאבית נתון. ביטויים
רגולריים דומים במבנה שלהם לביטויים חשבוניים: הם עצים, אשר בצמתים פנימיים נמצא
אופרטורים בעלי arity ידוע, כאשר בעלים נמצאים סימנים מתוך האלפאבית.

§§ ביטויים רגולריים כביטויים מעל חתימה
בהינתן אלפאבית~$Σ$, נבנה מעליו חתימה~$Γ$, כאשר~$Γ=Γ₀∪Γ₁∪Γ₂$ וכן
\begin{equation*}
  \begin{split}
    Γ₀ &=Σ^* ⏎
    Γ₁ &=❴⌘*❵ ⏎
    Γ₂ &=❴⌘;,⌘|❵
  \end{split}
\end{equation*}
נגדיר כעת את~$\RE(Σ)$ קבוצת הביטויים הרגולריים מעל האלפאבית~$Σ$ כקבוצת
הביטויים מעל החתימה~$Γ$,
\begin{equation*}
  \RE(Σ)=E(Γ)
\end{equation*}
עלים של ביטויים אלו הם מילים מהאלפאבית~$Σ$ ובכלל אלו המילה הריקה~$ε$.
לצמתים פנימיים המסומנים ב-⌘* יש בן אחד בדיוק. לצמתים פנימיים המסומנים ב-⌘;
או ב-⌘| יש שני בנים בדיוק.

\פנה|figure:regexp| מראה כמה ביטויים רגולריים הנבנים כביטויים מעל
האלפאבית~$❴⌘a,⌘b,⌘c❵$
\begin{figure}
  \centering
  \begin{tikzpicture}[every node/.style={shape=circle,
          draw, align=center,
          top color=red!10, bottom color=blue!20}]
    \usetikzlibrary{trees,chains}
    \begin{scope}[start chain=growing right,minimum size=2em]
      \node[on chain,circle,draw]{$⌘;$}
      child {%
          node{$⌘*$}
          child{%
              node{$⌘|$}
              child{node{$⌘a⌘b$}}
              child{node{$⌘c$}}
            }
      }
      child{%
        node{$⌘*$}
        child{node{$⌘b$}}
      };
      \node[on chain,circle,draw,xshift=8ex]{$⌘*$}
      child {%
          node{$⌘|$}
          child {node{$⌘a$}}
          child {node{$⌘|$} child{node{$ε$}} child{node{$⌘c$}}}
        }
      ;
    \end{scope}
  \end{tikzpicture}
  \caption[ביטויים רגולריים כביטויים מעל חתיחה]{ביטויים רגולריים כביטויים מעל החתימה~$Γ=Γ₀∪Γ₁∪Γ₂$, הכוללת את
  העלים~$Γ₀=❴⌘a, ⌘b, ⌘c❵^*$, האופראטור האונארי~$Γ₁=❴⌘*❵$ ושני האופראטורים
  הבינאריים,~$Γ₂=❴⌘;,⌘|❵$}.
  \label{figure:regexp}
\end{figure}
§ ביטויי~\E|S|
\תגית|פרק:S|

§§ ביטויי~\E|S| כשפה פורמלית

ביטויי~\E|S| הוצגו כבר ב\פנה|פרק:S0| כעצים בינאריים מלאים אשר העלים שלהם נושאים
תגיות. הנה הגדרה מדוית יותר: נשתמש במונח \ע|אלפאבית| לציון קבוצה, סופית או
אינסופית, של סימבולים אשר אין להם משמעות לבד כך שהם שונים זה מזה. בהינתן
אלפאבית~$Γ$ נסמן ב- \[
𝓢=𝓢(Γ)
\]
את \textbf{קבוצת ביטויי ה-\E|S| מעל~$Γ$}. כזכור, ביטוי~\E|S|
יכול להיות אטומי, כלומר כזה שאינו ניתן לפירוק לביטויי~S אחרים. ביטוי אטומי חייב
להיות סימבוך מתוך~$Γ$. ביטוי~\E|S| שאינו אטומי נקרא ביטוי מורכב, ואז הוא בהכרח
זוג סדור של שני ביטויי~\E|S| אחרים, שיכולים להיות אטומיים או מורכבים. הזוג
הסדור נכתב עטוף בזוג סוגריים כאשר שני ביטויי ה-\E|S| שבו מופרדים בסימן הנקודה.

כמה ביטויי~\E|S| מעל האלפאבית (הסופי)~$Γ=❴a,b,c❵$ הם \[
  a,b,(a.b),(c.(b.a)),((a.b).(a.c))∈𝓢❨❴a,b,c❵❩.
\] לעומת זאת,~$(a.b.c)$ אינו שייך ל~$𝓢(Γ)$ משום שהוא שלשה סדורה ולא זוג סדור,
ואילו~$(a(b(c)))$ אינו שייך לקבוצה, משום שהוא אינו עונה על הדרישה שבין פריטים
ימצא סימן הנקודה.

ניתן לאפיין את הקבוצה~$𝓢(Γ)$ באמצעות שני כללי היסק:

\begin{definition}[ביטויי~S מעל אלפאבית]
  \תגית|הגדרה:S| בהנתן אלפאבית~$Γ$ אזי,~$𝓢(Γ)$, קבוצת
  \ע|ביטויי ה-S מעל אלפאבית~$Γ$|, היא הקבוצה הנוצרת באמצעות שני בנאים
  \begin{enumerate}
    ✦ הבנאי הנולארי, המגדיר את הביטוים ה\ע|אטומיים|, כלומר, ביטויי~\E|S| אשר
    אינם ניתנים לפירוק לביטויי~\E|S| אחרים. בנאי זה מוגדר באמצעות כלל היסק שיש
    לו הנחה אחת בלבד,~$γ∈Γ$.
    \begin{equation*}
      \infer{γ∈𝓢(Γ)}{γ∈Γ}.
    \end{equation*}
    לפי בנאי זה, כל אות ב-$Γ$ היא ביטוי~\E|S| אטומי. הבנאי נקרא נולארי, משום
    שעל פי בנאי זה ניתן "ליצור" איברים של הקבוצה~$𝓢(Γ)$ ללא "שימוש" באיברים
    אחרים של הקבוצה.
    ✦ הבנאי הבינארי, המתאר את המבנה של ביטויי~\E|S| \ע|מורכבים|:
    \begin{equation*}
      \infer{(s₁.s₂)∈𝓢(Γ)}{s₁∈𝓢(Γ) & s₂∈𝓢(Γ)}.
    \end{equation*}
    לפי בנאי זה, אם~$s₁$ ו-$s₂$ הם ביטויי~\E|S| (שיכולים להיות אטומיים או
    מורכבים) אזי~$(s₁.s₂)$ הוא ביטוי~\E|S| (מורכב). בנאי זה נקרא בנאי
    בינארי, משום שבכלל ההיסק המתאר אותו
    יש שתי הנחות, וכל אחת מתייחסת לאיברים של~$𝓢(Γ)$. במילים אחרות, על פי בנאי
    זה ניתן "ליצור" איבר חדש של הקבוצה~$𝓢(Γ)$ מתוך "שימוש" ב-\ע|שני| איברים
    קיימים של הקבוצה.
  \end{enumerate}
\end{definition}


§§ עצים פורמאליים
קבוצת \ע|העצים הפורמאליים| מעל אלפאבית~$Γ$, המסומנת~$𝓣(Γ)$ מכילה את העצים שבהם
הדרגה אינה חסומה, בהם כל צומת נושא תגית שהיא איבר של~$Γ$. עץ כזה יכול להיות עץ
אטומי, ואז העץ מצטמצם לכדי עלה בודד, המתוייג באיבר כלשהו של~$Γ$. עץ ב-$𝓣(Γ)$
יכול להיות גם עץ מורכב, ובמקרה זה שורש העץ הוא צומת פנימי המתוייג באחד מבין
האיברים של~$Γ$ אשר לו מספר כלשהו של בנים שכולם עצים ב-\E|$𝓣(Γ)$|.

\begin{definition}[עצים מעל אלפאבית]
  בהנתן אלפאבית~$Γ$ אזי,~\E|$𝓣(Γ)$|, קבוצת העצים מעל~$Γ$ מוגדרת באמצעות הבנאי
  ה-$n$ מקומי
\begin{equation}
    \label{infer:tree}
    \infer{γ(t₁,…,tₙ)∈𝓣(Σ)}{γ∈Γ & n≥0 & t₁∈𝓣(Γ) & t₂∈𝓣(Γ)&⋯& tₙ∈𝓣(Σ)}
  \end{equation}
\end{definition}

כמה איברים של קבוצת העצים מעל האלפאבית בן שלוש האותיות~$❴a,b,c❵$ הם \[
  a(),b(c()),a(b(),c()), a(b(a())), a(a(),b(),c())
\]

כלל ההיסק~\ref{infer:tree} שבהגדרה הוא הבנאי היחיד של קבוצת העצים הפורמאליים,
והוא מתאר הן עצים אטומיים והן עצים מורכבים. לפי כלל זה עץ אטומי הוא עץ נולארי,
כלומר עץ "ערירי" אשר אין לו בנים, אשר צריך להיכתב לכן כ-~$γ()$. בכל זאת, מקובל
להשמיט את סימני הסוגריים עבור עצים ותתי-עצים שאין להם בנים, ולכתוב עץ כזה כ-$γ$
במקום~$γ()$. 

בכתיב מקוצר זה, העץ הפורמאלי
\begin{equation}
  a(a(a(),ab(),abc()),b(b(),ab(c())),c(c(a(ab())))
\end{equation}
מעל האלפאבית האינסופי~$❴a,b,c❵^*$ יכתב כך 
\begin{equation}
  a(a(a,ab,abc),b(b,ab(c)),c(c(a(ab)))
\end{equation}
\cref{figure:tree} מדגים את הטופולוגיה של עץ זה. 

\begin{figure}[H]
  \centering
  \scriptsize
  \forestset{%
    x tree/.style={%
        for tree={%
            math content,
            s sep'+=-3pt,
            circle,
            fit=band,
          },
      },
  }
  \begin{forest}
    s tree [a
          [a,[a][ab][abc]]
          [b,[b][ab[c]]]
          [c,[c[a[ab]]]]
      ]
  \end{forest}
\caption[עץ פורמאלי מעל האלפאבית~$❴a,b,c❵^*$]
  {העץ הפורמאלי~$a(a(a,ab,abc),b(b,ab(c)),c(c(a(ab))))$ מעל האלפאבית~$❴a,b,c❵^*$}
  \label{figure:tree}
\end{figure}

נוכל להגדיר את הקבוצה~$𝓣(Γ)$ גם כשפה פורמלית מעל אלפאבית מורחב~$Γ'$, הכולל גם
את זוג סימני הסוגריים ואת סימן הפסיק.
\begin{equation}
  Γ'=Γ∪❴⌘{(},⌘{.},⌘{)}❵.
\end{equation}



§§ קבוצת הביטויים הרגולריים כשפה פורמלית

למעלה הצגנו את קבוצת הביטויים הרגולרים כסוג של עצים מעל חתימה שנבנתה מעל אלפאבית
נתון. אולם, ניתן להציג את קבוצת הביטויים הרגולריים באופן ישיר כשפה
פורמלית.
יהי~$Σ=❴σ₁,…,σₙ❵$ ונניח כי ארבעת סימני הפיסוק ⌘|, ⌘*, ⌘(ו-⌘) אינם שייכים ל-$Σ$.
נגדיר אלפאבית מורחב~$Σ'=Σ∪❴⌘|,⌘*,⌘),⌘($ ונגדיר את~$\RE(Σ)$ כשפה פורמלית
מעל~$Σ'$, כלומר,
$\RE(Σ) ⊂❨Σ'❩^*$.
\החל{definition}[ביטויים רגולריים כשפה פורמלית]
\label{definition:re}
הקבוצה~$\RE(Σ)$, \ע|השפה הפורמלית של הביטויים הרגולריים מעל~$Σ$|, היא השפה
פורמלית מעל האלפבית המורחב~$Σ'$ המוגדרת רקורסיבית באמצעות חמשת כללי ההיסק
הבאים:
\begin{align}
  \infer{σ∈\RE(Σ)}{σ∈Σ} ⏎
  \infer{⌘{()}∈\RE(Σ)}{} ⏎
  \infer{⌘)r₁r₂⌘)∈\RE(Σ)}{r₁∈S(Σ)   & r₂∈\RE(Σ)} ⏎
  \infer{⌘)r₁⌘|r₂⌘)∈\RE(Σ)}{r₁∈S(Σ) & r₂∈\RE(Σ)} ⏎
  \infer{⌘)r⌘*⌘)∈\RE(Σ)}{r∈\RE(Σ)}
\end{align}
\סוף{definition}
שני כללי ההיסק הראשונים בהגדרה זו מגדירים את הביטויים הרגולריים האטומיים
הכוללים כל אות~$σ$,~$σ∈Σ$, וגם את המילה בת שתי האותיות~$⌘{()}$ הלקוחה
מתוך~$❨Σ'❩^*$. שלושת הכללים הבאים אחריהם מגדירים את בנאי הביטויים.

\begin{english}
  \begin{tabularx}\textwidth{lX}
    $r₁=a$ ⏎
    $r₂=()$ ⏎
    $r₃=(r₁b)=(ab)~$ ⏎
    $r₄=(r₂|r₃)=(()|(ab))~$ ⏎
    $r₅=(r₄*)$
  \end{tabularx}
\end{english}

§§ קבוצת הביטויים הרגולריים כעץ פורמלי
§§ המשמעות של ביטויים רגולריים
כדי לתת משמעות לשפה הפורמלית של הביטויים הרגולריים, נגדיר פונקצית המעניקה
משמעות לכל ביטוי רגולרי מעל~$Σ$. משמעות זו תהיה בעצמה שפה פורמלית, או קבוצת
מילים. כדי להבחין בין ביטוי רגולרי שהוא מילה מעל~$Σ'$, ובין המשמעות של הביטוי,
נשתמש ב-$r$ לציון הביטוי הרגולרי כמילה, וב-$⟦r⟧$ לציון משמעותה של מילה זו.

נסכם את הסימונים שבהם השתמשנו עד כה ואת היחסים ביניהם.

\begin{tabularx}\textwidth{lX}
  $Σ$                  & האלפבית הנתון, למשל~$Σ=❴⌘a,⌘b,⌘c❵$ ⏎
  $r∈\RE(Σ)$           & הסימון~$r$ מתייחס למילה בשפה הפורמלית~$\RE(Σ)$, ולא למשמעות
  המילה. ⏎
  $\RE(Σ)⊆❨Σ'❩^*$      & הקבוצה~$\RE(Σ)$ היא שפה פורמלית מעל האלפבית~$Σ'$. ⏎
  $Σ'=Σ∪❴⌘),⌘),⌘|,⌘*❵$ & האלפבית~$Σ'$ מתקבל מהאלפבית המקורי בתוספת ארבעה
  סימני פיסוק שלא היו בו. ⏎
  $⟦r⟧⊆Σ^*$            & הסימון~$⟦r⟧$ מתייחס למשמעות של המילה~$r$, שהיא קבוצה של מילים
  מעל האלפבית הנתון~$Σ$. ⏎
  $⟦r⟧∈℘Σ^*$           & $⟦r⟧$ שייכת לקבוצת השפות הפורמליות מעל~$Σ$. ⏎
  $⟦·⟧:\RE(Σ)→℘Σ^*$    & הפונקציה~$⟦·⟧$, כפונקציה של ארגומנט אחד, היא פונקציה
  מהשפה הפורמלית~$\RE(Σ)$ (שפה אשר מוגדרת מעל האלפבית המורחב~$Σ'$) אל קבוצת
  השפות הפורמליות מעל~$Σ$ (האלפבית המקורי). ⏎
  $⟦·⟧:❨Σ'❩^*⇸℘Σ^*$    &
  הפונקציה~$⟦·⟧$ היא פונקציה חלקית מקבוצות המילים מעל האלפבית המורחב, אל קבוצת
  השפות הפורמליות מעל~$Σ$ (האלפבית המקורי). הפונקציה היא חלקית, כי לא כל מילה
  הכתובה באלפבית~$Σ'$, היא ביטוי רגולרי חוקי, כלומר ניתנת להתקבל באמצעות
  ההגדרה \פנה|definition:regular|.
\end{tabularx}

גם הגדרת~$⟦r⟧$, פונקצית המשמעות של ביטוי רגולרי היא רקורסיבית, ורקורסיה זו
תואמת את הרקורסיה שבהגדרה \פנה|definition:re|.

\החל{definition}[פונקצית המשמעות של ביטויים רגולריים]
\label{definition:regular}
בהינתן ביטוי רגולרי~$r$, חמשת כללי ההיסק הבאים קובעים את משמעותו
\begin{enumerate}
  ✦ \[
    \infer{⟦r⟧=❴r❵}{r=σ & σ∈Σ}
\] כלומר, המשמעות של ביטוי רגולרי שהוא אות~$σ$
  באלפבית~$Σ$ היא השפה הפורמלית המכילה את המילה~$σ$ בלבד.
  ✦ \[
    \infer{⟦⌘{()}⟧=❴ε❵}{}
\] כלומר, המשמעות של הביטוי הרגולרי ⌘(⌘) היא השפה
  הפורמלית המכילה בתוכה את המילה הריקה בלבד.
  ✦ \[
    {\infer{⟦(r₁|r₂)⟧=⟦r₁⟧∪⟦r₂⟧}{r₁∈\RE(Σ)&r₂∈\RE(Σ)}}
\] כלומר, אם~$r₁$ ו-$r₂$
  הם ביטויים רגולריים, אזי~$⟦⌘)r₁⌘|r₂⌘)⟧$, המשמעות של הביטוי הרגולרי~$⌘)r₁⌘|r₂⌘)$, היא
  קבוצה המילים המתקבלת מאיחוד קבוצות המילים שהן המשמעויות של~$r₁$ ושל~$r₂$.
  ✦ \[
    \infer{⟦⌘(r₁r₂⌘)⟧=❴w₁w₂\,|\,w₁∈⟦r₁⟧∧w₂∈⟦r₂⟧❵}{r₁∈\RE(Σ) & r₂∈\RE(Σ)}
\] כלומר, אם~$r₁$ ו-$r₂$ הם ביטויים רגולריים, אזי~$⟦⌘)r₁r₂⌘)⟧$, המשמעות של
  הביטוי הרגולרי~$⌘)r₁⌘r₂⌘)$ היא הקבוצה של כל המילים שאפשר לחלק אותן לשתי מילים
  עוקבות, כך שהאחת נמצאת בתוך~$⟦r₁⟧$, השפה שהיא המשמעות של הביטוי~$r₁$, ואילו
  המילה האחרת נמצאת בתוך~$⟦r₂⟧$, השפה הפורמלית שהיא המשמעות של הביטוי~$r₂$.
  ✦ \[
    \infer
    {⟦⌘)r⌘*⌘)⟧=⟦ε⟧∪⟦r⟧∪⟦⌘)rr⌘)⟧∪⟦⌘)⌘)rr⌘)r⌘(⟧∪⋯}
    {r∈\RE(Σ)},
\] כלומר, אם~$r$ הוא ביטוי רגולרי, אזי~$⟦⌘)r⌘*⌘)⟧$, המשמעות של הביטוי
  הרגולרי~$⌘(r⌘*⌘)$, היא קבוצת כל המילים המילים שאפשר לחלק אותן ל-$0≤n$ מילים
  עוקבות שכל אחת מהן לקוחה מתוך~$⟦r⟧$, השפה הפורמלית שהיא המשמעות של הביטוי
  הרגולרי~$r$. \end{enumerate}
\סוף{definition}

נסתכל לדוגמה על הביטוי הרגולרי~$r$, \[
  r=⌘{(((a)((a|(b|c)))*)(c))}.
\] כדי למצוא את המשמעות של~$⟦r⟧$, עלינו לבדוק כיצד~$r$ נבנה רקורסיבית.

מציין את השפה~$L₃$, השפה של כל המילים המתחילות באות~$a$ ומסתיימות באות~$c$
\פסקה{דוגמאות}
המש הרגולרי \[
  ((a)((a|(b|c)))*)(c)
\] \[
  ⟦((a)((a|(b|c)))*)(c)⟧=L₃.
\] הביטוי הרגולרי \[
  ((a*)(b*))(c*)
\] מציין את השפה~$L₄$, שפת המילים שהאותיות שלהן מופיעות בסדר אלפאביתי לא יורד \[
  ⟦ (((a)*);((b)*));((c*))⟧=L₄.
\] §§ כתיב מקוצר לביטויים רגולריים
הכתיב שהוצע ב\פנה|definition:re| הוא ארכני, שכן כל הפעלה של בנאי מוסיפה זוג של
סוגריים לביטוי. נהוג להשתמש בכתיב מקוצר המסתמך על שלוש מוסכמות:
\ספרר
✦ יש שימוש באסוציאטיביות של ⌘| ושל השרשור כדי להשמיט סוגריים. כך למשל, במקום
$(a|(b|c))$
כותבים בקיצור
$(a|b|c)$
✦ כללי קדימות, לפיהם הסימן \* הוא בעל הקדימות הגבוהה ביותר, והסימן ⌘| בעל
הקדימות הנמוכה ביותר מאפשרים להשמיט סימני סוגריים נוספים. כך למשל, במקום
$(a*);(b*)$
נכתוב~$a*b*$.
✦ סימן השרשור (⌘;) מושמט. במקום
$a;b;c$
נכתוב בקיצור~$abc$.
===


הנה עוד כמה שפות פורמליות מעל האלפבית~$❴⌘a,⌘b,⌘c❵$:
שלא תשתננה גם אם תיקראנה מסופן.
\ספרר
✦ השפה~$L₄$ שפת המילים שהאותיות שלהן מופיעות בסדר אלפאביתי לא יורד.
✦ השפה~$L₅$ שפת המילים שמכילות חמש אותיות או יותר שאף אחת מהן אינה~$⌘b$.
✦ השפה~$L₆$ שפת המילים שכל אותיותיהן שונות.
===

\begin{editing}
  §§ ההיררכיה של חומסקי

  שפה פורמלית יכולה להיות סופית או אינסופית. שפה סופית ניתנת תמיד לתאור מדוייק
  באמצעות מניית כל המילים בשפה. ברשימה לעיל כל השפות הן שפות אינסופיות מלבד השפה
  האחרונה~$L₆$ המכילה בדיוק 13 מילים
  \begin{equation}\label{eq:L6}
    L₆=❴ε,⌘a,⌘b,⌘c,⌘{ab},⌘{ac},⌘{ba},⌘{bc},⌘{ca},⌘{cb},⌘{abc},⌘{acb},⌘{bac},⌘{bca},⌘{cab},⌘{cba}❵.
  \end{equation}
  את השפה האינסופית~$L₅$ ניתן להגדיר תוך שימוש ב\פנה|definition:length|
  \begin{equation}\label{eq:L5}
    L₅=❴w \,|\, w∈Σ^*, |w|≥5❵.
  \end{equation}

  כל ההגדרות המדוייקות של השפות הפורמליות
  $L₆$ \cref{eq:L6},
  $L₅$ \cref{eq:L5},
  ו-~$L₁$
  (\cref{definition:L1})
  היו שונות זו מזו, וכולן היו, במובן מסויים אד-הוק. כלומר, בחרנו בעבור כל שפה
  פורמלית, בשיטת הגדרה המתאימה לה. הגדרות של שפות תכנות משתמשות לעיתים קרובות
  בהגדרות אד-הוק, אבל לעיתים קרובות יותר, הן משתמשות במנגנונים כלליים להגדרת
  שפות פורמליות.
  ארבעת המנגנונים העיקריים הם:
  \begin{enumerate}
    ✦ \ע|ביטויים רגולריים| (\E|regular expressions|)
    אותם נכיר ב-\cref{section:regular}.
    ✦ \ע|שפות חסרות הקשר| (\E|regular expressions|)
    אותם נכיר ב-\cref{section:regular}.

    קבוצת כל השפות מעל~$Σ$ היא לכן קבוצת כל הקבוצות החלקיות של~$Σ^*$, כלומר
    קבוצת החזקה של~$Σ^*$, אותה נסמן ב-$𝒫Σ^*$. נסמן ב-\textbf{Finite} את קבוצת
    כל השפות הסופיות. ראינו כבר כי \[
      L₆∈\text{\textbf{Finite}}.
\] נסמן ב-\textbf{Regular} את קבוצת כל השפות הפורמליות הרגולריות, כלומר
    השפות שאותן ניתן לתאר באמצעות ביטוי רגולרי.
    כאמור \[
      L₃,L₄,L₅∈\text{\textbf{Regular}}.
\] נסמן ב-\textbf{CFG} את קבוצת כל השפות הפורמליות חסרות ההקשר, כלומר אותן
    השפות שאותן ניתן לתאר באמצעות דקדוק חסר הקשר.
    כאמור \[
      L₁,L₂∈\text{\textbf{CFG}}.
\] מתברר כי:
    \begin{equation*}
      \text{\bfseries Finite}⊊\text{\bfseries Regular}⊊\text{\bfseries CFG}⊊
      \text{\bfseries CSG}⊊𝒫Σ^*.
    \end{equation*}
    כלומר, ניתן לתאר את כל השפות הסופיות באמצעות ביטוויים רגולריים, אך לא כל
    השפות שאפשר לתאר אותן בביטוי רגולרי הן סופיות. בנוסף, כל שפה שאפשר לתאר
    באמצעות ביטויים רגולריים, ניתן גם לתאר באמצעות דקדוק חסר הקשר, אך יש שפות
    שניתן לתאר באמצעות דקדוקים חסרי הקשר, ושאי אפשר לתאר באמצעות ביטויים
    רגולריים. יתירה מכך, ישנן שפות אותן לא ניתן לתאר באמצעות דקדוקים חסרי הקשר.

    עוד מתברר כי
    \begin{equation}
      L₀∉\text{\bfseries CFG}
    \end{equation}
    כלומר, לא ניתן לתאר את שפת~\CPL באמצעות דקדוקים חסרי הקשר.

    ביטויים רגולריים, אותם נכיר ב\cref{section:regular} מאפשרים להגדיר שפות
    פשוטות כגון~$L₄$ ו-$L₅$.
    ✦ \ע|דקדוקים חסרי הקשר רגולריים|
    ✦ \ע|דקדוקים תלויי הקשר|
    ✦ \ע|הגדרה באמצעות תכנית|
  \end{enumerate}

  הגדרה פורמלית של השפות~$L₁$ ו-$L₂$ דורשת שימוש במנגנון שנכיר בהמשך, דקדוקים
  חסרי הקשר (\E|context free grammars|). הגדרה מדיוקת של השפות~$L₃$ ו-$L₄$
  דורשת שימוש במנגנון אחר, ביטויים רגולריים מרבית השימושים בפועל מוסיפים תַּחְבִּירִי
  סֻכָּר כגון:

  \begin{figure}[H]
    \centering
    \input TikZ/Chomsky.tikz
    \caption{ההיררכיה של חומסקי}
  \end{figure}
\end{editing}

בכתיב זה הביטוי הרגולרי המתאר את השפה~$L₄$ נכתב כ-$a*b*c*$. עוד נהוג שלא
להקפיד על ההבדלה בין הביטוי כמילה, ובין המשמעות שלו, ולכן, בדרך כלל כותבים
בקיצור~$L₄=a*b*c*$ במקום~$L₄=⟦a*b*c*⟧$. בכתיב המקוצר, הביטוי
הרגולרי~$(a|c)(a|c)(a|c)(a|c)(a|c)*$ מתאר את השפה השפה~$L₅$ המכילה את כל המילים
בנות חמש אותיות או יותר שאף אחת מהן אינה האות ⌘b.

ישנם כלים רבים המאפשרים לבצע חיפוש והחלפה בטקסט תוך שימוש בביטויים רגולריים.
כלים אלו מוסיפים קיצורים משלהם, אך כמה קיצורים מופיעים באורח זהה כמעט בכל כלי
המאפשר למשתמש בו להגדיר ביטויים רגולריים.

\ספרר
✦ עבור~$σ₁,σ₂,…σₖ∈Σ$, הסימון
$[σ₁σ₂⋯σₖ]$
הוא קיצור לביטוי
$(σ₁|σ₂|⋯|σₖ)$
כלומר, ביטוי המתאים לכל מילה שהיא תו אחד בדיוק מבין
$σ₁,σ₂,…,σₖ$.
כך למשל ⌘{+|-}
יכתב כ-⌘{[+-]}.

✦ אם~$r$ הוא ביטוי רגולרי, אזי~$r?$ הוא קיצור לביטוי הרגולרי~$(r|ε)$. כך למשל
השפה המתאימה לביטוי הרגולרי ⌘{?[+-]} מכילה שלוש מילים~$❴ε, ⌘a, ⌘b❵$.

✦ אם~$r$ הוא ביטוי רגולרי, אזי~$r+$ הוא קיצור לביטוי הרגולרי~$rr*$, כלומר מילה
המכילה מופע אחד או יותר של~$r$.

✦ בהנחה שיש סדר מוסכם של התווים באלפבית~$Σ$, הסימון~$σ₁-σ₂$ כשהוא מופיע בתוך
סוגריים מרובעים, הוא קיצור של רשימת כל התווים בין~$σ₁$ ובין~$σ₂$.
כך למשל הביטוי הרגולרי
\begin{quote}
  ⌘{[0-9]+}
\end{quote}
מתאר סדרה לא ריקה של ספרות עשרוניות, ואילו
\begin{quote}
  ⌘{[-+]?[0-9]+}
\end{quote}
הסימן "." (נקודה) מתאר את הביטוי הרגולרי שמכיל אות אחת בדיוק מהאלפבית.
====

כדאי לדעת כי ניתן לכתוב ביטוי רגולרי עבור חיתוך של השפות של שני ביטויים
רגולרייים, וגם עבור השפה של כל הסדריות של ביטוי רגולרי אחד אשר אינן מצויות בשפה
של ביטוי רגולרי אחר, וזאת בעבור כל שני ביטויים רגולריים שרירותיים. לשימוש
בביטויים רגולריים בתיאורה של שפה פורמלית יש גם השלכה מעשית: ישנם כלים אוטומטיים
אשר הקלט שלהם הוא ביטוי רגולרי ואשר מיייצרים תכניות המסוגלות לזהות
מופעים של ביטויים רגולריים בטקסט. כלים אלו מועילים מאוד בכתיבת מהדרים עבור שפות
תכנות.

\begin{editing}
  בהינת אלפאבית~$Σ$ של סימנים יסודיים, נגדיר כ-$Σ*$ את אוסף כל הסדריות
  (Strings) הסופיות שניתן לכתוב בעזרתו, ובכלל אלו את המילה הריקה אשר מסומנת
  בדרך כלל כ-𝜺. במנוחים אלו שפה פורמלית היא פשוט תת-קבוצה של~$Σ*$ ביטויים
  רגולריים (regular expressions), הם מכשיר להגדרת שפות פורמליות. קבוצת הביטויים

  כדאי לדעת כי ניתן לכתוב ביטוי רגולרי עבור חיתוך של השפות של שני ביטויים
  רגולרייים, וגם עבור השפה של כל הסדריות של ביטוי רגולרי אחד אשר אינן מצויות
  בשפה של ביטוי רגולרי אחר, וזאת בעבור כל שני ביטויים רגולריים שרירותיים.
  השימוש בביטויים רגולריים בתיאור הדקדוק של שפה, אינו חשוב רק למען הדיוק. ישנם
  כלים אוטומטיים אשר הקלט שלהם הוא ביטוי רגולרי ואשר מיייצרים תכניות המסוגלות
  לזהות מופעים של ביטויים רגולריים בטקסט. כלים אלו מועילים מאוד בביטויים בכתיבת
  מהדרים עבור שפות תכנות.

\end{editing}

§§§ דקדוקים חסרי הקשר

כוח ההבעה של בביטויים רגולריים מוגבל כיוון שביטויים רגולריים אינם מאפשרים
רקורסיה: כלומר, לא ניתן בהגדרה של ביטוי רגולרי מסויים, בתוך ההגדרה עצמה. לעומת
ביטויים רגולריים ניצבים דקדוקים \E|(grammars)|, אשר תומכים בהגדרות רקורסיביות.

הגדרות של שפות תכנות עושות שימוש נרחב בדקדוקים, ובמיוחד בסוג מיוחד של דקדוקים,
הלא הם הדקדוקים חסרי ההקשר \RL{(context free grammars)}. יתירה מכך, הסכימה
הכללית של ניתוח תכנית בשפת תכנות בלתי מסויימת, היא של ניתוח לקסיקלי של הקלט
לאסימונים, כאשר מבנה האסימונים מוגדר על ידי ביטויים רגולריים, ולאחר מכן, ניתוח
דקדוקי של האסימונים, תוך שימוש בדקדוק מתאים.

בפרק זה יתברר כי עיקרו של כל דקדוק הוא אוסף של כללי דקדוקיים הידועים גם בשם
כללי גזירה. כל כלל גזירה מאפשר להחליף צורת משפט אחת באחרת. נגדיר לכן בפרק זה
מהי צורת משפט, ובאמצעות הגדרה זו, מהו כלל גזירה, וכיצד מפעילים אותו. בנוסף
לכללים, הדקדוק גם קובע צורת משפט התחלתית. השפה הפורמלית המוגדרת על ידי דקדוק
היא אוסף כל המילים שאפשר להגיע אליהן מצורת המשפט ההתחלתית, תוך הפעלת הכללים
הדקדוקיים.

נדגים את המושגים עוד לפני הגדרתם המדוייקת. לשם כך, נסתכל על שפת הסוגריים כשפה
הפורמלית מעל האלפבית בן שתי האותיות~$Σ=❴⌘), ⌘(❵$ כאוסף כל המילים~$w$,
המכילות מספר שווה
של שני סימני האלאפבית, ואשר בכל רישא שלהן אין יותר מופעים של~$⌘($, סימן סגור
הסוגרים, מאשר מופעים של~$⌘)$, סימן סגור הסוגריים.
הנה דקדוק חסר הקשר המתאר שפה זו
הסוגריים \דוגמה|שפת הסוגריים|
$Σ=❴⌘), ⌘(❵$,~$N=❴S❵$
\begin{equation}
  \label{eq:parenthesis}
  \begin{split}
    S &→ε ⏎
    S &→⌘(S⌘)⏎
    S &→SS ⏎
  \end{split}
\end{equation}
בדקדוק זה ישנם שלושה כללים, וכל אחת מסדרות הסימנים משמאל או מימין של החץ המופיע
בכל אחד מכללים אלו היא צורת משפט. אפשר לראות את הרקורסיה הטמונה בכללי הגזירה,
בעובדה שכלל הגזירה השני מחליף את צורת המשפט~$S$ בצורת המשפט~$⌘(S⌘)$,
הכוללת את הסימן~$S$. גם כלל הגזירה השלישי מדגים רקורסיה, כאשר צורת המשפט~$S$
מוחלפת בצורת המשפט~$SS$. הדקדוק אינו מציין במפורש מהי צורת המשפט ההתחלתית, אבל
מי שמיומן בקריאת דקדוקים, יוכל לנחש כי צורה זו היא~$S$.

\begin{editing}
\subsection{דקוקים חסרי הקשר}
נהוג להגדיר דקדוקים חסרי הקשר כרביעיה,
המכילה את המרכיבים הבאים:
\begin{description}
  ✦ ]סימבולים[ זוהי קבוצה של סימנים, הקרויים לעיתים non-terminal symbols,
  non-terminal characters, variables, syntactical categories, וגם verbs.
  אנו נסמן קבוצה זו ב-$𝕍$. יש הדורשים כי~$𝕍$ תהיה סופית,
  אולם דרישה זו מיותרת.
  ✦ ]סימנים סופיים[ זוהי קבוצה של סימנים, השונים מהסימבולים. קבוצה זו נקראת
  לעיתים גם קבוצת ה-terminal symbols, או קבוצת ה-terminals. הגדרת הדקדוק מגדירה
  שפה פורמלית של מילים שכל אות בהן היא סימן סופי. אנו נסמן את
  קבוצה זו ב-$Σ$.
  ✦ ]כללי גזירה[
  ✦ ]סימן התחלה[
\end{description}
\end{editing}

\subsection{דוגמאות}

\דוגמה|שפת הסוגריים|
$Σ=❴⌘), ⌘(❵$,~$N=❴S❵$
\begin{equation}
  \label{eq:parenthesis}
  \begin{split}
    S &→ε ⏎
    S &→⌘(S⌘)⏎
    S &→SS ⏎
  \end{split}
\end{equation}

\דוגמה|שפת הפלינדרומים|
$Σ=❴⌘a, ⌘b, ⌘c❵$,~$N=❴S❵$
\begin{equation}
  \label{grammar:palindroms}
  \begin{split}
    S &→ε ⏎
    S &→⌘aS⌘a ⏎
    S &→⌘bS⌘b ⏎
    S &→⌘cS⌘c
  \end{split}
\end{equation}

\דוגמה|שפת הפונקציות הרציונליות|
\label{example:rationals}
$❴⌘1, ⌘I, ⌘), ⌘(, ⌘/, ⌘*, ⌘+, ⌘-❵$ \cref{eq:Q:alphabet}
\begin{equation}
  \label{eq:parenthesis}
  \begin{split}
    S &→⌘1 ⏎
    S &→⌘I ⏎
    S &→⌘(-S⌘)⏎
    S &→⌘(S⌘+S⌘)⏎
    S &→⌘(S⌘*S⌘)⏎
  \end{split}
\end{equation}

\דוגמה|הדקדוק של שפת העצים|
\label{example:grammar:re}
$\RE(Σ)$, השפה הפורמלית של הביטויים הרגולריים
מעל אלפאבית~$Σ=❴σ₁,σ₂,…,σₙ❵$
כפי שהוגדרה באמצעות כללי היסק
ב\פנה|definition:re| ניתנת להגדרה גם באמצעות דקדוק
מעל האלפבית
$❴σ₁,σ₂,…,σₙ, ⌘., ⌘), ⌘(❵$
\begin{equation}
  \label{eq:parenthesis}
  \begin{split}
    R &→σ₁ ⏎
    R &→σ₂ ⏎
    ⋮ ⏎
    R &→σₙ ⏎
    R &→⌘(R⌘.R⌘)
  \end{split}
\end{equation}

\דוגמה|הדקדוק של שפת הביטויים הרגולריים|
\label{example:grammar:re}
$\RE(Σ)$, השפה הפורמלית של הביטויים הרגולריים
מעל אלפאבית~$Σ=❴σ₁,σ₂,…,σₙ❵$
כפי שהוגדרה באמצעות כללי היסק
ב\פנה|definition:re| ניתנת להגדרה גם באמצעות דקדוק
מעל האלפבית
$❴σ₁,σ₂,…,σₙ, ⌘|, ⌘;, ⌘*, ⌘), ⌘(❵$
\begin{equation}
  \label{eq:parenthesis}
  \begin{split}
    R &→σ₁ ⏎
    R &→σ₂ ⏎
    ⋮ ⏎
    R &→σₙ ⏎
    R &→⌘(⌘)⏎
    R &→⌘(R R⌘)⏎
    R &→⌘(R ⌘| R⌘)⏎
    R &→⌘(R ⌘*⌘)
  \end{split}
\end{equation}
אינטואיטיבית, ד
ניתן להתסכל על
דקדוקי BNF
כוח הביטוי של ביטויים רגולריים הוא מוגבל ביותר. כך למשל, לא ניתן לבטא
באמצעות ביטוי רגולרי את הדרישה שהסוגריים בתכנית מאוזנים. לפיכך, השימוש
בביטויים
רגולריים מוגבל להגדרות פשוטות של אבני הבנין של השפה: משתנים, הערות, מספרים
וכו'. להגדרות מורכבות יותר, יש להשתמש במנגנון הידוע בשם דקדוק חסר הקשר
(Context Free Grammar), אשר נכתב בדרך כלל בשיטת הסימון הידועה בשם Backus Naur
Form או \E|BNF|. כתיב אחר לדקדוקים אלו הוא הדיאגרמות שתוארו לעיל.

הגדרת דקדוק בשיטת סימון זו מורכבת מארבעה חלקים:
\begin{enumerate}
  ✦ קבוצה של סימנים סופיים, Terminals. (ה-Terminals קרויים
  לעיתים גם Tokens או אסימונים). הדקדוק מתאר שפה מעל האלפבית
  ✦ שיוצרים הסימנים הסופיים.
  ✦ קבוצה של סימנים לא סופיים, Non Terminal Symbols, המשמשים
  ככלי עזר להגדרת הדקדוק. סימני עזר אלו דומים מעט לשימוש בשמות
  לביטויים רגולריים חלקיים, אלא, שהגדרתם של סימני העזר הללו
  יכולה להיות רקורסיבית, וניתן להגדירן יותר מאשר פעם אחת.
  ✦ קביעה של אחד מהסימנים הלא סופיים כסימן התחלה: Start Symbol
  ✦ אוסף של כללי גזירה, כאשר לכלל גזירה יש שני חלקים: ראש הכלל
  הכתוב בצד שמאל של הכלל, הוא תמיד סימן לא סופי, ואילו גוף הכלל
  הכתוב בצידו הימני, הוא מילה (היכולה להיות ריקה) של סימנים
  סופיים ולא סופיים. כללי הגזירה נכתבים כך שישנו חץ המוביל מראש
  הכלל אל גופו. בפועל, נוהגים להשמיט את המרכיבים 1 עד 3 של
  הגדרת הדקדוק ולהסתפק בכללי הגזירה לבדם. קל להבחין בין סימנים
  סופיים ולא סופיים בכללי הגזירה, משום שסימן סופי לא יופיע
  לעולם בראש כלל. גם סימן ההתחלה ברור בדרך כלל מההקשר.
  הנה דוגמא:
  \begin{align}
    S &→E ⏎
    E &→a E b ⏎
    E &→𝜺 ⏎
  \end{align}
\end{enumerate}

נבחין בין דקדוקים
חסרי הקשר \E|(context free grammar (CFG))| ודקדוקים תלויי הקשר (כמו למשל
הדקדוק של שפת הסוגריים) ובין
\E|(context sensitive grammar (CSG))|, שהם חזקים יותר מ-CFG, אבל, השימוש בהם
אינו כה נפוץ בהגדרות שפות תכנות (אך נפוץ יותר בניסיון להגדרות פורמליות של
הדקדוק של שפות טבעיות כמו עברית(.

נתאר גם את שיטת הכתיבה הנפוצה לדקדוקים הידועה בשם
Backus Naur ואת ההכללה שלה, הידועה כשם ENBF \E|(extended BNF)|.

\subsection{צורות משפט}
נזכר בכלל ההיסק \פנה|eq:Q:minus| בו נכתב
\begin{equation*}
  \infer{⌘(⌘-w⌘)∈L₁}{w∈L}⏎
\end{equation*}
אולם כדאי לשים לכך ש-$⌘(⌘-w⌘)$ אינה בעצמה מילה מתוך האלפבית
\פנה|eq:Q:alphabet|, ולכן היא בוודאי גם אינה מילה בשפה~$L₁$.
סדרה כמו~$⌘(⌘-w⌘)$, המערבת אותיות מהאלפבית ואותיות שאינן לקוחות ממנו,
נקראת \ע|צורת משפט|
(sentential forms).
לאות המופיעה בצורת משפט ואשר אינה לקוחה מהאלפבית, קוראים סמל
(symbol).

צורת המשפט~$⌘(⌘-w⌘)$, מציינת את כל המילים מעל האלפבית \פנה|eq:Q:alphabet|
המתקבלות אם הסימבול~$w$ יוחלף במילה כלשהי מתוך אלפאבית זה, כלומר, כל המילים
המתחילות בסימן ⌘(, שמייד אחריו בא הסימן ⌘-, ומסתיימות בסימן ⌘).  

התנאי המגולם בכלל ההיסק
\begin{equation*}
  \infer{⌘(⌘-w⌘)∈L₁}{w∈L}⏎
\end{equation*}
אומר שהמילה המתקבלת מצורת המשפט~$⌘(⌘-w⌘)$ שייכת לשפה~$L₁$ אם הסמל~$w$ יוחלף
במילה שגם היא שייכת לשפה~$L₁$.

צורות משפט מופיעות גם בכללי ההיסק \cref{eq:Q:plus}, \cref{eq:Q:times}
ו-\cref{eq:Q:times}. נשים לב לכך שצורות המשפט המופיעות בכללים אלו מכילות שני
סמלים ולא אחד. באופן כללי יותר, נבחר קבוצה אינסופית~$𝕊$ של סמלים, שהם סימנים
שאינם מופיעים באף אלפאבית, ונגדיר

\begin{definition}[צורות משפט מעל אלפאבית]
  \label{definition:sentential}
  צורת משפט מעל אלפאבית~$Σ$ היא מילה מתוך~$❨Σ∪𝕊❩^*$.
\end{definition}

כל צורת משפט~$α$ מעל אלפאבית~$Σ$ מגדירה, באופן טריביאלי, שפה פורמלית מעל~$Σ$.
זוהי השפה הפורמלית של כל המילים המתקבלות מ-$α$ על ידי בחירת מילה מ~$Σ^*$ בעבור
כל אחד מהסמלים המופיע ב-$α$ והחלפת כל מופע של סמל במילה המתאימה.

כך למשל, צורת המשפט~$www$ מתארת את השפה הפורמלית~$L₃$ של כל המילים שאפשר לחלק
אותן לשלוש מילים רצופות, זרות, וזהות. כמה מילים בשפה זו (מעל
האלפבית~$❴⌘a,⌘b,⌘c❵$) הן:
\begin{equation}
  \label{eq:L3}
  L₃=❴ε, ⌘{aaa}, ⌘{bbb}, ⌘{ccc}, ⌘{aaaaaa}, ⌘{ababab}, ⌘{acacac}, ⌘{bababa},…❵.
\end{equation}

שימוש חשוב יותר בצורות משפט הוא בכללי גזירה. אם~$α$ ו~$β$, הן צורות משפט אזי
\begin{equation*}
  α→β
\end{equation*}
הוא כלל גזירה שמשמעו החלפת צורת המשפט~$α$ בצורת המשפט~$β$. הפעלה של כלל גזירה
על צורת משפט~$ϕ$ יכולה להעשות אם ניתן למצוא בתוך~$ϕ$ מופע של צורת המשפט~$α$.
אם מופע כזה אכן נמצא, שכתוב של~$ϕ$ באמצעות כלל הגזירה~$α→β$, נעשה באמצעות
החלפת המופע האמור בצורת המשפט~$β$.

למשל
\begin{equation*}
  ⌘(Q⌘*⌘U⌘)→Q
\end{equation*}
הוא כלל גזירה המחליף את~$α=⌘(Q⌘*⌘U⌘)$, צורת משפט באורך~4, בצורת
משפט~$α₂=Q$ באורך~1. כלל זה יכול להיות
מופעל על צורת המשפט
\begin{equation*}
  ϕ=⌘(⌘-⌘(Q⌘*⌘U⌘)⌘),
\end{equation*}
משום שהיא מכילה בתוכה כמילה חלקית את צורת המשפט~$α=⌘(Q⌘*⌘U⌘)$.

מעט פורמלית יותר נאמר שניתן לחלק את~$ϕ$ לשלוש מילים רצופות,~$ϕ=ϕ₁ϕ₂ϕ₃$, כשהמילה
האמצעית שבהן היא צד שמאל של הכלל, כלומר~$ϕ₂=α$. בעבור הדוגמה שלנו, מתקיים
כי~$ϕ₀=⌘(⌘-$, ו-$ϕ₁=⌘)⌘($.

הפעלת הכלל
במקרה זה תחזיר את צורת המשפט
\begin{equation*}
  ⌘)⌘-Q⌘).
\end{equation*}
ובאופן כללי, הפעלת הכלל~$α→β$ על המופע של~$α$ בתוך צורת המשפט~$ϕ$ המוגדר על ידי
הפירוק~$ϕ₁αϕ₃=ϕ$ מחזירה את צורת המשפט~$ϕ₁βϕ₃$.

נדגיש כי החיפוש אחר מופע של~$α$ בתוך~$ϕ$ אינו מסתכל על~$α$ כעל תבנית היכולה
להתאים למילים שונות, אלא כמילה שחייבת להימצא ככתבה וכלשונה. מסיבה זו, כלל
הגזירה
$⌘)Q⌘*⌘U⌘)→Q$ המכיל את הסמל~$Q$ בתוך צורת המשפט המצוייה בצידו השמאלי,
אינו יכול לפעול על המילה
\begin{equation*}
  ⌘)⌘)⌘-⌘)⌘I⌘*⌘U ⌘(⌘(⌘*⌘U⌘(
\end{equation*}
שהיא, צורת משפט שאינה מכילה אף לא סמל אחד, ובוודאי לא את הסמל~$Q$.

יתכן כי הצד השמאלי של כלל גזירה יופיע יותר מאשר פעם אחת בצורת
המשפט אותה הוא משכתב. כך למשל, ניתן להפעיל את כלל הגזירה
\begin{equation}
  \label{eq:parenthesis:rewrite}
  S→⌘) S ⌘)
\end{equation}
בשלושה מקומות שונים על צורת המשפט~$SSS$, ולקבל שלוש צורות משפט שונות.
\ע|גזירה שמאלית| היא גזירה בה כלל הגזירה מופעל במופע הראשון של~$α$ בתוך~$ϕ$.
באופן דומה, ניתן גם להגדיר \ע|גזירה ימנית| כגזירה בה כלל הגזירה מופעל במופע
הראשון של~$α$ בתוך~$ϕ$. גזירה שמאלית של~$SSS$ באמצעות כלל הגזירה~$S→⌘)S⌘)$ תיתן
\begin{equation*}
  ⌘)S⌘)SS
\end{equation*}
ואילו גזירה ימנית תיתן
\begin{equation*}
  SS ⌘) S ⌘).
\end{equation*}

§ דקדוקים
בדוגמא זו בדקדוק ישנם שלושה כללי גזירה, אשר מקריאתם מתגלה כי:
\begin{enumerate}
  ✦
  הסימנים הלא סופיים הם S וְ E
  סימן ההתחלה הוא S
  ✦
  הסימנים הלא סופיים הם a וְ b
\end{enumerate}

השפה המוגדרת על ידי הדקדוק חסר ההקשר הזה היא פשוטה ביותר, והיא מכילה את
כל הסדריות שבראשן יש מספר n (שיכול להיות 0) של a ואחריהם n מופעים של
הסימן b.
ניתן להוכיח (ולא נעשה זאת כאן), כי לא ניתן להגדיר שפה זו באמצעות ביטויים
רגולריים.

הנה דוגמא המהווה קטע של הדקדוק של שְׂפַת פסקל:

\begin{derivation}
  \begin{align}
    pascal-program→program identifier program-heading ; block . ⏎
    program-heading→𝜺 ⏎
    program-heading→(identifier-list) ⏎
    identifier-list→identifier ⏎
    identifier-list→identifier-list, identifier ⏎
    block→block1 ⏎
    block→label-declaration ; block1 ⏎
    block1→block2 ⏎
    block1→constant-declaration ; block2 ⏎
    block2→block3 ⏎
    block2→type-declaration ; block3 ⏎
    block3→block4 ⏎
    block3→variable-declaration ; block4 ⏎
    block4→block5 ⏎
    block4→proc-and-func-declaration ; block5 ⏎
    block5→begin statement-list end ⏎
 …⏎
    type-declaration→type type-declarator ⏎
    type-declaration→type-declaration ; type-declarator ⏎
    type-declarator→identifier=type ⏎
 …⏎
    type→identifier ⏎
    type→record field-list \=end=⏎
    field-list→𝜺 ⏎
  \end{align}
\end{derivation}

קל לזהות בהגדרת דקדוק זו את סימן ההתחלה. לשם הנוחות סימנו את הסימנים
הסופיים כגופן וצבע מיוחדים. מהגדרת הדקדוק הזו אנו למדים למשל:
\begin{itemize}
  ✦ תכנית Pascal מתחילה תמיד במילה program ומסתיימת בסימן ". "
  ✦ לתכנית יש שם שאחריו יכולה להופיע רשימת מזהים העטופה בסוגריים עגולים.
  ✦ בראש התכנית יש ארבעה פרקי הגדרות החייבים להופיע בסדר קבוע: הגדרת תוויות,
  ✦ הגדרת קבועים, הגדרת טיפוסים והגדרת משתנים. כל אחד מארבעת מפרקי ההגדרות הוא
  אופציונלי.
  ✦ בהגדרת פרק הטיפוסים אם מופיעה המילה type אזי אחריה חייבת להופיע הגדרת טיפוס
  אחת לפחות.
  ✦ הגדרות הטיפוסים חייבות להיות מופרדות בסימן ";" כל הגדרת טיפוס בודדת מכילה
  מזהה, סימן שיווין, ואחריו גוף הטיפוס, שיכול להיות מזהה או רשומה.

  והנה דוגמא לתכנית פשוטה (וחסרת טעם) המצייתת לדקדוק לעיל:

\end{itemize}
\begin{PASCAL}
program p;
type
  shalem=integer;
  student=record
end;
begin
end.
\end{PASCAL}

הגדרת הדקדוק של שְׂפַת תכנות באמצעות דקדוק חסר הקשר לא נועדה למען הדיוק
בלבד. ישנם כלים אוטומטיים המאפשרים תרגום של דקדוק חסר הקשר כזה לתכנית
ניתוח, אשר לוקחת טכסט נתון, ובונה בעבורו את אופן גזירתו מהדקדוק. אופן
הגזירה הזה נקרא "עץ גזירה" (ַParse Tree) אשר מהווה הוכחה כי הטכסט אמנם
נגזר מהדקדוק. הפורמליזם של דקדוק BNF חזק יותר מהפורמליזם של ביטויים
רגולריים שכן הוא מתיר הגדרות רקורסיביות. כך למשל, בהגדרת הדקדוק של Pascal
נמצא הגדרות רקורסיביות שבהן הסימן הלא סופי statement-list מוגדר באמצעות
הסימן הלא סופי statement ולהיפך:

\begin{align}
  statement-list→statement ⏎
  statement-list→statement-list ; statement⏎
  statement→𝜺⏎
  statement→variable :=expression⏎
  statement→begin statement-list end⏎
  statement→if expression then statement⏎
  statement→if expression then statement else statement⏎
  statement→case expression of case-list end⏎
  statement→while expression do statement⏎
  statement→repeat statement-list until expression⏎
  statement→for varid :=for-list do statement⏎
  statement→procid⏎
  statement→procid(expression-list)⏎
  statement→goto label⏎
  statement→with record-variable-list do statement⏎
  statement→label : statement⏎
\end{align}

הגדרות רקורסיביות מעין אלו הינן חיוניות בהגדרת שפות תכנות מודרניות, אך הן אינן
ניתנות להיעשות בביטויים רגולריים. דקדוקי EBNF EBNF הוא קיצור של Extended BNF.
פורמליזם זה דומה בעיקרו לפורמליזם של דקדוק BNF, אלא שגופו של כלל הגזירה יכול
להיות ביטוי רגולרי מעל אוסף הסימנים, הסופיים והלא סופיים כאחד. שימוש בביטויים
רגולריים כאלו הוא בבחינת תַּחְבִּירִי סֻכָּר לדקדוקי BNF. ההרחבה עצמה אינה מאפשרת
הגדרת שפות פורמליות נוספות פרט לאלו הניתנות להגדרה בדקדוק BNF, אך ניתן באמצות
הרחבה זו להגדיר שפות פורמליות ביתר תמציתיות.

הנה שכתוב של קטע הדקדוק הראשון של Pascal שהבאנו כאן, תוך שימוש בשיטות הסימון
של EBNF.

\begin{align}
  Pascal-program→program identifier [(identifier {,identifier})] ; block .
  block→[label-declaration;]
  [constant-declaration;]
  [type-declaration;]
  [variable-declaration ;]
  begin statement-list end
…
  type-declaration→type ַtype-declarator {; type-declaration}
  type-declarator→identifier=type
  type→identifier | record field-list end
  field-list→𝜺
\end{align}
\endinput
כדאי לשים לב לכך שהכתיב של ביטויים רגולריים בגוף כלל הגזירה של EBNF הוא מעט
שונה. למעלה, בדוגמא הזו השתמשנו בכתיב על פיו * חזרה אפס או יותר פעמים מסומנת על
ידי עטיפה הביטוי החוזר בסוגריים מסולסלים, המעוצבים טיפוגרפית בדוגמא כך: {} כך
למשל תת הביטוי המופיע בגופו של כלל הגזירה הראשון לעיל
identifier {,identifier}
מציין רשימה של אחד או יותר מזהים המופרדים בפסיקים.
\begin{description}
  ✦ ביטוי אופציונלי עטוף בסוגריים מרובעים, המעוצבים טיפוגרפית בדוגמא כך: [] כך למשל תת הביטוי
  [label-declaration;]
  מציין שה label-declaration שאחריו יש סימן ; הוא אופציונלי.
  עוד נשים לכך שהדוגמא מניחה כללי קדימות של האופרטורים היוצרים את הביטוי הרגולרי, בפרט
  identifier | record field-list end
  מתפרש כך:
  identifier | (record field-list end)
  ולא כך:
  (identifier | record) field-list end
\end{description}

דקדוק ה-EBNF של שְׂפַת תכנות מסוימת עשוי להשתמש בשיטת סימון מעט אחרת ואולי אף כללי
קדימות אחרים. בדרך כלל, יכול הקורא הנבון להסיק את שיטת הסימון מתוך הקריאה,
ואילו הקורא הסכל יאלץ לעיין בנספח, בהקדמה או בתוספת אחרת למסמך הראשי, ואשר בהם
אולי תימצא הגדרה מדוייקת של שיטת הסימון.
\eject
\pagecolor{yellow

§ דקדוקים
אוסף השפות הפורמליות הניתנות להגדרה על ידי ביטויים רגולריים הוא מוגבל.

דקדוק חסר הקשר הוא

\החל{definition}
דקדוק חסר הקשר~$G$ הוא רביעיה~$G=⟨V,Σ,R,S⟩$
כאשר~$V$ היא קבוצה של \ע|משתנים|, הקרויים גם
V is called a nonterminal character or a variable. Each variable represents a
different type of phrase or clause in the sentence. Variables are also
sometimes called syntactic categories. Each variable defines a sub-language
of the language defined by G. Σ is a finite set of terminals, disjoint from
V, which make up the actual content of the sentence. The set of terminals is
the alphabet of the language defined by the grammar G.
R is a finite relation from V to~${\displaystyle (V∪Σ)^*}(V∪Σ)^*,~$ן where the
asterisk represents the Kleene star operation. The members of R are called
the (rewrite) rules or productions of the grammar. (also commonly symbolized
by a P) S is the start variable (or start symbol), used to represent the
whole sentence (or program). It must be an element of V.
\סוף{definition}

\endinput
כוח ההבעה של ביטויים רגולריים הוא מוגבל. כך למשל, לא ניתן להביע באמצעות ביטוי
רגולרי את הדרישה שהסוגריים בתכנית מאוזנים. לפיכך, השימוש בביטויים רגולריים
מוגבל להגדרות פשוטות של אסימונים- אבני הבנין של השפה: משתנים, הערות,
מספרים וכו'.

ב§§ הגדרת שפות להגדרת שפה פורמלית באמצעות עצמן

פורמלית, כל שפת תכנות היא שפה פורמלית. ישנן שפות פורמליות שאינן שפות תכנות.
שפות תכנות אינן מכניזם נוח להגדרת שפה פורמלית. מכניזמים להגדרת שפות פורמליות.
מתברר שגם מכניזמים אלו הם שפה פורמלית.

 בדרך כלל, קל הרבה יותר להגדיר שפה פורמלית, מאשר לכתוב מהדר של השפה בעזרת
 עצמה. הנה דוגמאות.
 \ציינן
     ✦ הגדרת BNF בעזרת עצמו
     ✦ הגדרת EBNF בעזרת עצמו
     ✦ ביטוי רגולרי המגדיר מהו ביטוי רגולרי חוקי
===

קל להגדיר את
 משפחת ה-BNF באמצעות ביטוי רגולרי. קל להשתמש ב-BNF כדי להגדיר מהו ביטוי
 רגוליר. אבל, ניתן להגדיר ביטוי רגולרי באמצעות ביטוי רגולרי? לא! רקורסיה.
 טבלת סיכום, הגדרה הדדית.

 מסיבה זו, השפות BNF וְ-EBNF הן אלגנטיות יותר מביטוים רגולריים.

§§ עצים פורמאליים
קבוצת \ע|העצים הפורמאליים| מעל אלפאבית~$Γ$, המסומנת~$𝓣(Γ)$ מכילה את העצים שבהם
הדרגה אינה חסומה, בהם כל צומת נושא תגית שהיא איבר של~$Γ$. עץ כזה יכול להיות עץ
אטומי, ואז העץ מצטמצם לכדי עלה בודד, המתוייג באיבר כלשהו של~$Γ$. עץ ב-$𝓣(Γ)$
יכול להיות גם עץ מורכב, ובמקרה זה שורש העץ הוא צומת פנימי המתוייג באחד מבין
האיברים של~$Γ$ אשר לו מספר כלשהו של בנים שכולם עצים ב-\E|$𝓣(Γ)$|.

\begin{definition}[עצים מעל אלפאבית]
  בהנתן אלפאבית~$Γ$ אזי,~\E|$𝓣(Γ)$|, קבוצת העצים מעל~$Γ$ מוגדרת באמצעות הבנאי
  ה-$n$ מקומי
\begin{equation}
    \label{infer:tree}
    \infer{γ(t₁,…,tₙ)∈𝓣(Σ)}{γ∈Γ & n≥0 & t₁∈𝓣(Γ) & t₂∈𝓣(Γ)&⋯& tₙ∈𝓣(Σ)}
  \end{equation}
\end{definition}

כמה איברים של קבוצת העצים מעל האלפאבית בן שלוש האותיות~$❴a,b,c❵$ הם \[
  a(),b(c()),a(b(),c()), a(b(a())), a(a(),b(),c())
\]

כלל ההיסק~\ref{infer:tree} שבהגדרה הוא הבנאי היחיד של קבוצת העצים הפורמאליים,
והוא מתאר הן עצים אטומיים והן עצים מורכבים. לפי כלל זה עץ אטומי הוא עץ נולארי,
כלומר עץ "ערירי" אשר אין לו בנים, אשר צריך להיכתב לכן כ-~$γ()$. בכל זאת, מקובל
להשמיט את סימני הסוגריים עבור עצים ותתי-עצים שאין להם בנים, ולכתוב עץ כזה כ-$γ$
במקום~$γ()$. 

בכתיב מקוצר זה, העץ הפורמאלי
\begin{equation}
  a(a(a(),ab(),abc()),b(b(),ab(c())),c(c(a(ab())))
\end{equation}
מעל האלפאבית האינסופי~$❴a,b,c❵^*$ יכתב כך 
\begin{equation}
  a(a(a,ab,abc),b(b,ab(c)),c(c(a(ab)))
\end{equation}
\cref{figure:tree} מדגים את הטופולוגיה של עץ זה. 

\begin{figure}[H]
  \centering
  \scriptsize
  \forestset{%
    x tree/.style={%
        for tree={%
            math content,
            s sep'+=-3pt,
            circle,
            fit=band,
          },
      },
  }
  \begin{forest}
    s tree [a
          [a,[a][ab][abc]]
          [b,[b][ab[c]]]
          [c,[c[a[ab]]]]
      ]
  \end{forest}
\caption[עץ פורמאלי מעל האלפאבית~$❴a,b,c❵^*$]
  {העץ הפורמאלי~$a(a(a,ab,abc),b(b,ab(c)),c(c(a(ab))))$ מעל האלפאבית~$❴a,b,c❵^*$}
  \label{figure:tree}
\end{figure}

נוכל להגדיר את הקבוצה~$𝓣(Γ)$ גם כשפה פורמלית מעל אלפאבית מורחב~$Γ'$, הכולל גם
את זוג סימני הסוגריים ואת סימן הפסיק.
\begin{equation}
  Γ'=Γ∪❴⌘{(},⌘{.},⌘{)}❵.
\end{equation}


