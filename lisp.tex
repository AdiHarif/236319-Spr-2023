שפת LISP (ראשי תיבות של \E|LIst PRocessing|), היתה, יחד עם שפת Fortran (ראשי
תיבות של \E|FORmula TRANslation|) אחת משתי שפות התכנות הראשונות. ליספ פותחה
ב-MIT על ידי \E|John McCarthy| עוד ב-1956. מלכתחילה, ליספ לא נתפסה על ידי
ממציאה כשפת תכנות, אלא כתחשיב מתימטי המיועד לכתיבת אלגוריתמים, הדומה לתחשיב
ה-$λ$.  בתחשיב זה, כל תכנית נקראת "ביטוי S", והרצת התכנית קרויה "שיערוך"
(\E|Evaluate|) של הביטוי. 

בנוסף לתחשיב McCarthy הציג גם אלגוריתם אוניברסלי, \E|eval| המסוגל להריץ תכניות
בליספ.  ליספ הפכה לשפת תכנות כאשר האלגוריתם הזה מומש בשפת תכנות.  רק לאחר מכן,
מומש התחשיב כשפת תכנות.  מאז, זכתה ליספ לגלגולים רבים: התחשיב המקורי הפך לשפת
תכנות של ממש, וזכה להרחבות רבות. פותחו ניבים רבים לשפה, והיא מצוייה בשימוש
נרחב.  מאוחר יותר, נמצא מי שכתב מימוש של \E|eval| בשפת ליספ עצמה.

פרק זה איננו עוסק בליספ כשפת תכנות, וגם לא באף אחד מהניבים שלה, אלא  מתרכז רק
בהצגת הגלעין (\E|core|) של השפה. הגלעין שיוצג כאן הוא מינימלי ביותר, 
והוא כולל הגדרה של כתריסר שמות בלבד: 
\begin{itemize}
  \item \ע|2 קבועים (פונקציות ללא פרמטרים)|: \E|t| ו-\E|nil|. 
  \item \ע|3 פונקציות מבניות|: \E|car|, \E|cdr|, ו-\E|cons|. 
  \item \ע|3 פונקציות לוגיות|: \E|eq|, \E|atom|, ו-\E|null|. 
    (הפונקציה \E|null| אינה חיונית, והיא ניתנת למימוש באמצעות פונקציות אחרות
    בגלעין.)
  \item \ע|5 פונקציות המסייעות בכתיבת הגדרות|: 
\E|set|, \E|quote|, \E|cond|, \E|lambda|, ו-\E|defun|.
(הפונקציה \E|defun| אינה חיונית, והיא ניתנת למימוש באמצעות פונקציות אחרות
בגלעין.) 
\end{itemize}

הגלעין של ליספ, בניגוד לכמעט כל הדיאלקטים שלה, אינו תומך במספרים ובפעולות
אריתמטיות. רוב הדיאלקטים של ליספ, יודעים להדר, באופן חלקי או מלא, תכניות ליספ
לשפת מכונה. גם הידור כזה אינו נחוץ בגלעין של השפה. על אף המינימליות של הגלעין,
הוא טיורינג שלם: כל תכנית שאפשר לכתוב בכל שפת תכנות, אפשר לכתוב גם בגלעין של
ליספ. בפרט, כפי שנראה כאן, ניתן לממש את הפונקציה את \E|eval| בגלעין.  באופן
כללי יותר, אין מקום בגלעין לתמוך בשום תכונה של ליספ שאינן נחוצות כדי לממש את
הפונקציה \E|eval|. 

הגלעין של ליספ מעניין שכן הוא מציג בצורה פשוטה וקלה רעיונות יסודיים, כגון עיבוד
רקורסיבי של רשימות, קישור של שמות לערכים, העברת פרמטרים, ועוד.

כל הערכים בשפת ליספ הם ביטויי S \E|(S-Expressions)|.  המונח S-Expression בא
לעולם כקיצור למונח \E|symbolic expression| (ביטוי סימבולי). המילה "סימבולי" באה
להדגיש שמדובר שאין מדובר בביטוי מתימטי
כמו~$13+41/2$.  

תכנית בשפת ליספ היא פונקציה שיכולה לקבל כארגומנטים ביטויי~S והיא מחזירה
ביטוי~S. כל פונקציה כזו, היא בעצמה ביטוי S.

§§ ביטויי S

\newcommand\SX{\ensuremath{S_{\text{exp}}}}

בהינתן אלפבית~$Σ$, נגדיר את~$\SX(Σ)$, קבוצת "ביטויי ה-S", מעל~$Σ$.
אינטואיטיבית, ביטוי~S יכול להיות אטומי, ואז הוא חייב להיות מילה מתוך~$Σ^*$.
ביטוי S שאינו אטומי הוא בהכרח זוג סדור של שני ביטויי~S אחרים. הזוג הסדור נכתב
עטוף בזוג סוגריים ושני הביטויים הסימבוליים שבו מופרדים בסימן הנקודה.

כמה ביטויי~S מעל האלפבית~$Σ=❴a,b,c❵$ הם \[
  a,b,(a.b),(c.(b.a)),((a.b).(a.c))∈\SX❨❴a,b,c❵❩.
\] לעומת זאת,~$(a.b.c)$ אינו שייך ל~$\SX(Σ)$ משום שהוא שלשה סדורה ולא זוג סדור,
ואילו~$(a(b(c)))$ אינו שייך לקבוצה, משום שהוא אינו עונה על הדרישה שבין פריטים
ימצא סימן הנקודה.

הקבוצה~$\SX(Σ)$ היא שפה פורמלית מעל אלפבית מורחב, המתקבל מהוספת סימן הנקודה ואת
שני סימני הסוגריים לאלפבית~$Σ$ (אנו מניחים, בלי הגבלת הכלליות, ששלושת הסימנים
הללו אינם מצוים ב-$Σ$.)

ניתן לאפיין את השפה~$\SX(Σ)$ באמצעות כללי היסק:
\begin{definition}[ביטויי S מעל אלפבית]
  בהנתן אלפבית~$Σ$ אזי,~$\SX(Σ)$, קבוצת ביטויי ה-S מעל~$Σ$
  מוגדרת באמצעות הבנאי הנולארי (כלומר איברים אטומיים):
  \begin{equation*}
    \infer{w∈\SX(Σ)}{w∈Σ^*}
  \end{equation*}
  והבנאי הבינארי:
  \begin{equation*}
    \infer{(τ₁.τ₂⟩∈\SX(Σ)}{τ₁∈\SX(Σ) &τ₂∈\SX(Σ)}
  \end{equation*}
\end{definition}

ניתן להגדיר את~$\SX(Σ)$ גם באמצעות דקדוק חסר הקשר
\begin{equation}
  \begin{split}
    S &→(S.S)⏎
    S &→A ⏎
    A &→ε⏎
    A &→Aσ₁ ⏎
    A &→Aσ₂ ⏎
    ⋮ ⏎
    A &→Aσₙ ⏎
  \end{split}
\end{equation}
כאשר~$Σ=❴σ₁,σ₂,…,σₙ❵$.

נוח לחשוב על ביטויי S כעצים בינאריים מלאים (כלומר, שלכל צומת שאינה עלה יש בדיוק
שני בנים(כאשר צומת פנימית של עץ כזה אינו נושא מידע, ואילו עלה מכיל מילה
מתוך~$Σ^*$.  הנה כמה ביטויי S והתיאור שלהם כעץ בינארי מלא.

  \begin{LTR}
    \begin{tabular}{cccccc}
      $(ab.cd)$ &
      $(abcd.ε)$ &
      $(ab.(c.d))$ &
      $((a.b).(c.d))$ &
      $(a.(b.(c.d)))$ &
      $(((a.b).c).d)$ ⏎
      \scriptsize \Forest{s tree [{},cons[$ab$,atom][$cd$,atom]]} &
      \scriptsize \Forest{s tree [{},cons[$abcd$,atom][$ε$,atom]]} &
      \scriptsize \Forest{s tree [{},cons[$ab$,atom][{},cons[$c$,atom][$d$,atom]]]} &
      \scriptsize \Forest{s tree [{},cons[{},cons[$a$,atom][$b$,atom]][{},cons[$c$,atom][$d$,atom]]]} &
      \scriptsize \Forest{s tree
      [{},cons
      [{},cons
      [{},cons[a,atom][b,atom]]
      [c,atom]
      ]
      [d,atom]
      ]
      } &
      \scriptsize \Forest{s tree
      [{},cons
      [{}, cons
        [{}, cons [a,atom][b,atom]]
        [c,atom]
      ]
      [d,atom]]
      }
    \end{tabular}
  \end{LTR}

§§ ביטויי S בשפת ליספ וכתיב הרשימות

שפת ליספ מרחיבה מעט את ההגדרה של ביטויי-S כפי שהצגנו אותה למעלה, אבל, בסופו של
דבר, ביטויי S בליספ היא הקבוצה~$\SX$ מעל אלפבית הכולל בתוכו את האותיות
\texttt{A} עד \texttt{Z}, ספרות, וגם מרבית הסימנים המיוחדים, כולל \texttt{-},
\texttt{+} ועוד.

לביטוי S מורכב קוראים בשפת ליספ \E|cons|. לאיבר הראשון ב-\E|cons|, קוראים
\E|car|, ולאיבר השני ב-cons קוראים \E|cdr|. לזוג כולו קוראים \E|cons|.

לביטוי S אטומי בשפת ליספ קוראים אטום \E|(atom)|. דוגמאות לאטומים הן \A|A|,
\A|12B|, \A|ZZZ| ו-\A|+|. מסיבות היסטוריות, האלפבית של אטומים בליספ אינו מכיל
אותיות קטנות. מערכות ליספ מתרגמת את האותיות הקטנות לאותיות גדולות כשהן מופיעות
בתוך אטומים.

סדרת התווים המגדירה אטום יכולה להיות גם~$ε$, הסידרה הריקה. השם \A|nil| מציין את
האטום שסדרת התווים שלו היא~$ε$. כפי שנראה בהמשך, גם הכתיב \A|()| מציין את האטום
הזה.  סדרת התווים המגדירה אטום היא חסרת משמעות בדרך כלל, אולם המתכנת בליספ יכול
להעניק לאטומים נבחרים משמעות. בנוסף, יש מספר אטומים שהמשמעות שלהם מוגדרת מראש
בשפה. 

\ע|רשימה| \E|(list)| בליספ היא סדרה של פריטים המופרדים ברווחים והעטופה
בסוגריים. כל פריט ברשימה יכול להיות ביטוי~\E|S|, או רשימה בעצמו.

כך, \A|(A B C D)| היא הרשימה המכילה ארבעה פריטים: האטומים \A|A|, \A|B|, \A|C|
ו-\A|D|.  הרשימה הריקה, זו שאינה מכילה אף פריט, נכתבת כ-\A|()|, ואילו
\A|((A.C) C)| היא רשימה המכילה שני פריטים, שהראשון בהם הוא ביטויי~S
מורכב, \A|(A.C)|, והשני הוא האטום \A|C|.

כל רשימה היא כתיב מקוצר לביטוי~\E|S|. הכתיב מוגדר באינדוקציה על אורך הרשימה:
הרשימה ריקה \A|()| היא כתיב אחר לאטום \A|NIL|. רשימה שאינה ריקה, היא כתיב מקוצר
לביטוי~S מורכב, כלומר זוג של ביטויי~\E|S|. האיבר הראשון בזוג הוא האיבר הראשון
ברשימה. האיבר השני בזוג, הוא הייצוג של שארית הרשימה.

לפיכך, הרשימה \A|(A B C D)| היא כתיב אחר לביטוי~S
\begin{LTR}
  \A|(A.(B.(C.(D.NIL))))|
\end{LTR}
כלומר, העץ הבינארי המלא הבא
\begin{LTR}
\forestset{%
  xil/.style={circle,inner sep=-6pt,fill=white,nice empty nodes,tikz={\draw [rotate=-160,scale=0.44]
% \pgfsetlinewidth{6\pgflinewidth} % thickness
  ($(.center)!0.2!(!parent)$)
  coordinate (o)
 % (o)++(-0.520,0)--++(1.04,0)
 % (o)++(-4,1)--++(8,0)
 % (o)++(-0.380,.180)--++(.760,0)
 % (o)++(-2,3)--++(4,0)
 %% (o)++(-0.180,0.360)--++(0.360,0)
;}},
} \begin{forest}
    s tree [{},cons [A,atom]
    [{},cons [B,atom]
    [{},cons [C,atom]
    [{},cons [D,atom]
    [$ε$,atom]
    ]
    ]
    ]
    ]
  \end{forest}
\end{LTR}
הפריטים ברשימה הם ביטויי~\E|S|, אבל כיוון שרשימה גם היא ביטוי~\E|S|, רשימה
יכולה להכיל בתוכה רשימות. למשל,
\begin{LTR}
  \A|((A B) C)|
\end{LTR}
היא רשימה המכילה בתוכה שני פריטים, הראשון שבהם הוא רשימה בת שני אטומים, והשני
שבהם הוא אטום. כביטוי~\E|S|, רשימה זו נכתבת
\begin{LTR}
  \A|((A.(B.NIL)).(C.NIL))|
\end{LTR}
והעץ הבינארי המתאים לה הוא
\begin{LTR}
  \begin{forest}
    s tree [{},cons
    [{},cons
    [B, atom]
    [{},cons[C,atom] [$\epsilon$,atom] ]
    ]
    [{},cons
    [C,atom]
    [$\epsilon$,atom]
    ]
    ]
  \end{forest}
\end{LTR}

לא כל ביטוי~S ניתן להיכתב בכתיב הרשימות. למשל הביטוי \A|(A.B)| אינו ניתן להכתב
כרשימה. אבל כל רשימה ניתנת להיכתב כביטוי~\E|S|. נהוג לכתוב ביטויי~S בכתיב
הרשימות בכל אימת שניתן לעשות זאת.

§§ פעולות על ביטויי~S

הגלעין של ליספ תומך בפעולות מבניות אלמנטריות על ביטויי \E|S|.  המשמעות של שלושת
האטומים \A|CONS|, \A|CAR|, ו-\A|CDR| מוגדרת מראש לציין פעולות מבניות אלו:  


\begin{enumerate}
  ✦ האטום \A|CONS| מציין פונקציה המקבלת שני ביטויי~\E|S|, ומחזירה ביטוי~S
  שהוא זוג בו האיבר הראשון הוא הארגומנט הראשון לפונקציה, ואילו האיבר השני של
  הזוג הוא הארגומנט השני לפונקציה.

  נשים לב לכך שאם הארגומנט השני לפונקציה זו הוא רשימה, אז הפונקציה מחזירה
  רשימה חדשה שבה הפריט הראשון הוא הארגומנט הראשון לפונקציה ושאר
  הפריטים הם כמו אלו שהיו ברשימה שהיא הארגומנט הראשון.

  ✦ האטום \A|CAR| מציין פונקציה המקבלת כארגומנט ביטוי~S אחד. אם ביטוי זה הוא
  ביטוי מורכב, הפונקציה מחזירה ביטוי~S שהוא האיבר הראשון בזוג ממנו הארגומנט
  בנוי. 

  לעומת זאת, אם הארגומנט לפונקציה הוא אטום, הפונקציה נכשלת. כשלון זה דומה
  לכשלון של ניסיון לחלוקה באפס. ממש כשם שלא כל הפעולות האריתמטיות מוגדרות על כל
  המספרים, לא כל הפונקציות המבניות מוגדרות על כל כל ביטויי~\E|S|.

  אם הארגומנט לפונקציה הוא רשימה שאיננה ריקה, אז הפונקציה מחזירה את הפריט
  הראשון ברשימה. כאמור, אם הארגומנט ל-\E|CAR| הוא אטום, ואפילו יהא זה
  האטום \A|NIL|, כלומר הרשימה הריקה, הפונקציה נכשלת.

  ✦ האטום \A|CDR| מציין פונקציה המקבלת כארגומנט ביטוי~S אחד. אם ביטוי זה הוא
  ביטוי מורכב, הפונקציה מחזירה ביטוי~S שהוא האיבר השני בזוג ממנו הארגומנט בנוי.
  אם הארגומנט לפונקציה הוא אטום, הפונקציה נכשלת.

  אם הארגומנט לפונקציה הוא רשימה שאינה ריקה, אז הפונקציה מחזירה את
  שארית הרשימה, כלומר, הרשימה בלעדי האיבר הראשון שבה.
\end{enumerate}


הגלעין של ליספ תומך גם בפונקציות לוגיות המאפשרות לבדוק את תוכנו של
ביטויי~\E|S|.  המשמעות של שלושת האטומים \A|ATOM|, \A|NULL|, ו-\A|EQ| מוגדרת
מראש לפונקציות המאפשרות בדיקות כאלו: 

\begin{enumerate}
  ✦ האטום \A|ATOM| מציין פונקציה המקבלת ביטוי~S אחד ומחזירה את האטום \A|T| אם
  ארגומנט זה הוא אטום, ואחרת את האטום \A|NIL|.

  ✦ האטום \A|NULL| מציין את הפונקציה המקבלת ביטויי~S אחד ומחזירה את האטום
  \A|T|.

  אם ארגומנט זה הוא האטום \A|NIL| ואחרת את האטום \A|T| אם הארגומנט לפונקציה הוא
  רשימה, אז הפונקציה מחזירה \A|T| אם ורק אם הרשימה ריקה ו-\A|NִִIL| בכל
  מקרה אחר.

  ✦ האטום \A|EQ| מציין את הפונקציה המקבלת שני ביטויי~S ומחזירה את האטום \A|T|
  אם שני הארגומנטים לפונקציה הם אטומים, ושני האטומים הללו שווים. בכל מקרה אחר,
  הפונקציה מחזירה את האטום \A|NIL|. 
  \end{enumerate}

ניתן לחשוב על האטום \A|NIL| כמסמן את הערך של שלילה לוגית, כלומר \E|false|, ועל
האטום \A|T| כמסמן את ערך האמת, \E|true|.

§§ ביטויי S כעצים מעל אלאפבית

ראינו שביטויי S ניתנים להצגה כעץ בינארי שבו העלים, והעלים בלבד, מכילים
סימבולים. אם ביטוי S ניתן להכתב כרשימה של רשימות, אז ניתן להציג את הביטוי הזה
כעץ חישוב, שבו קיים סימבול בכל צומת פנימית ובכל עלה. ומספר הבנים של כל צומת
פנימית יכול להיות כלשהו.

בהנתן אלפבית~$Σ$, נגדיר את~$T(Σ)$, קבוצת העצים שבכל צומת שלהם ישנו איבר של~$Σ$.
עץ כזה יכול להיות עץ אטומי, ואז העץ מצטמצם לכדי עלה בודד, שחייב להכיל איבר
של~$Σ^*$. עץ ב-$T(Σ)$ יכול להיות גם עץ מורכב, ובמקרה זה הוא מורכב מצומת פנימי
שבו יש אות של~$Σ$ ומספר כלשהו של בנים שכולם עצים ב-\E|$T(S)$|. בניסוח זה, אנו
רואים שעץ אטומי הוא עץ מורכב שיש לו אפס בנים.

נוכל להגדיר את הקבוצה~$T(Σ)$ כשפה פורמלית מעל אלפבית מורחב, הכולל גם את זוג
סימני הסוגריים ואת סימן הפסיק בא בהנתן אלפבית~$Σ$ אזי,~$T(Σ)$,
\begin{definition}[עצים מעל אלפבית]
  בהנתן אלפבית~$Σ$ אזי,~\E|$T(Σ)$|, קבוצת העצים מעל~$Σ$ מוגדרת באמצעות הבנאי
  ה-$n$ מקומי
  \begin{equation*}
    \infer{w(t₁,…,tₙ)∈\SX(Σ)}{w∈Σ^* & n≥0 & t₁∈T(Σ) & t₂∈T(Σ)&⋯& tₙ∈T(Σ)}
  \end{equation*}
\end{definition}

כמה איברים פשוטים של קבוצת העצים מעל האלפבית בן שלוש האותיות~$Σ=❴a,b,c❵$ הם \[
  a, b, c, a(b,c), a(b(a)), a(a,b,c)∈T(❴a, b, c❵)
\]
\cref{figure:tree} מדגים את הטופולגיה של העץ המורכב יותר
$a(a(a,ab,abc),b(b,ab(c)),c(c(a(ab)))∈T(❴a, b, c❵)
)$
\begin{figure}[h]
  \centering
  \forestset{%
  x tree/.style={
    for tree={
      math content,
      s sep'+=-3pt,
      fit=band,
    },
  },
}
\begin{forest}
    s tree [a
      [a,[a][ab][abc]]
      [b,[b][ab[c]]]
      [c,[c[a[ab]]]]
    ]
\end{forest}
\caption{העץ~$a(a(a,ab,abc),b(b,ab(c)),c(c(a(ab))))$.}
\label{fig:tree}
\end{figure}

אם ביטוי S הוא רשימה של רשימות, אזי ניתן להציגו כעץ. התרגום מתבצע על ידי הפיכת
כל רשימה בביטוי לתת-עץ: האיבר הראשון ברשימה הוא שורש תת-העץ. שאר האיברים
ברשימה, הם הבנים של תת העץ. לדוגמה, בעבור הרשימה  
\begin{english}
  \A|(a b (car x) (+ b x))|
\end{english}
יבנה כך העץ
\begin{english}
  \forestset{%
  x tree/.style={
    for tree={
      math content,
      s sep'+=-3pt,
      fit=band,
    },
  },
}
\begin{forest}
    x tree [a, 
        [a, [car, [x]]]
        [+, [b] [x]]
    ]
\end{forest}
\end{english}


§§ המפרש של ליספ
המפרש (interpreter) של ליספ, עובד בדרך הידועה בשם \E|REPL|, שהם ראשי תיבות של
\begin{description}
  ✦ [READ] המפרש קורא ביטוי~\E|S|, הנכתב, בדרך כלל, בכתיב הרשימות.
  ✦ [EVALUATE] המפרש משערך את ערכו של הביטוי שקרא.
  ✦ [PRINT] אם השיערוך של הקלט מצליח, אז המפרש מדפיס את תוצאת השיערוך. אחרת, 
המפרש ינסה להדפיס הודעת שגיאה מתאימה.
  ✦ [LOOP] המפרש חוזר לצעד הראשון, לקריאת הביטוי הבא
\end{description}

§§§ שערוך של אטומים 
השיערוך של ביטויי-S מוגדר רקורסיבית.  בסיס הרקורסיה הוא בשיערוך של אטומים. אם 
האטום הוא אחד מבין
\A|CAR|, \A|CDR|, \A|CONS|, \A|EQ| ושאר
הפונקציות שבגלעין של ליספ, אזי משמעות האטום
היא פונקציה זו. 

לשם שיערוכם של אטומים אחרים ליספ מחזיקה טבלת סמלים, הקושרת בין אטומים ובין
משמעותם.  אם אטום נמצא בטבלת הסמלים הזו, השיערוך שלו יחזיר את הערך שטבלת הסמלים
קושרת לאטום.  כזכור, כל אטום הוא מלכתחילה סדרת תווים שהיא חסרת משמעות כשלעצמה.
לכן, השיערוך של אטום שאינו שמה של פונקציה בגלעין, ושאינו נמצא בטבלת הסמלים,
יכשל.

טבלת הסמלים בליספ מאורגנת במבנה נתונים הידוע בליספ בשם \E|association list| או
בקיצור \E|a-list|.  ה-\E|a-list| היא רשימה של פריטים אשר כל אחד מהם מבטא קישור
של שם לערך: כל פריט הוא ביטוי S מורכב, כלומר cons. ה-car של הפריט הוא שם
(המיוצג כאטום) ואילו ה-cdr של הפריט הוא משמעותו של השם (שהיא \E|S-Expression|,
אטומי או מורכב: אם משמעותו של האטום foo היא העץ $ϕ$ אז הפריט הנשמר ב-\E|a-list|
הוא $(foo.φ)$.  הקישור בין השם והישות הוא בדיוק בעובדה ששני אלו מחוברים ברשומת
\E|cons|.

רשימה ה-\E|a-list| מנוהלת כמחסנית, כלומר פריטים מתווספים ומוסרים ממנה  רק
בתחילתה. החיפוש אחר משמעות ברשימה נעשה סדרתית, בסריקה המתחילה בתחילת הרשימה.
חיפוש המשמעות של האטום foo נעצר
בזוג הראשון שבו מרכיב השם הוא foo. החיפוש נכשל אם לא נמצא זוג כזה.  

כאשר המפרש של ליספ מתחיל את עבודתו, ה-\E|a-list| מכילה קישורים בעבור מספר קטן
שני הקבועים המצויים בגרעין:  
\begin{english}
  \begin{quote}
    \A|((T.T) (NIL.NIL))
  \end{quote}
\end{english}
הפריט הראשון ברשימה אומר שמשמעות של האטום \A|T| היא אטום זה עצמו.  הפריט השני
ברשימה אומר שמשמעותו של האטום \A|NIL| היא אטום זה עצמו גם כן.
מתכנת בליספ יכול להוסיף פריטים לרשימה באמצעות הפונקציות \E|set|
ו-\E|defun|. 


\begin{english}
  \begin{quote}
    \A|(
      (CAAR.(LAMBDA (X) (CAR (CAR X))  \\
      (T.T)  \\
      (NIL.NIL)
    )|
  \end{quote}
\end{english}

§§§ שיערוך ביטוי מורכב 
השיערוך של הביטוי המורכב~$s=(s₁.s₂)$
נעשה בשלושה שלבים:
\begin{enumerate}
  ✦ שיערוך רקורסיבי של ה-CAR של הביטוי, כלומר שיערוך של~$s₁$. אם השיערוך
  של~$s₁$ נכשל, אזי גם השיערוך של~$s$ נכשל. אחרת, שיערוך זה מחזיר ביטוי \E|S|
  שנסמן~$s₁'$.

  ✦ שיערוך רקורסיבי של ה-\E|CּּּּDR|, כלומר של הביטוי~$s₂$, אשר מתבצע באופן הבא:
  מסתכלים על~$s₂$ כעל רשימה של~$n$ ביטויי \E|S|: $s₂=(a₁ a₂⋯aₙ)$, בעבור~$0≥n$.
  משערכים את הביטויים~\E|$a₁$,~$a₂$,…,~$aₙ$|, ומסמנים את תוצאות השיערוך הללו
  ב-\E|$a₁'$,~$a₂'$,…,$aₙ'$|, ומסמנים~\E|$s₂'=(a₁' a₂'⋯aₙ')$|.

  אם השיערוך של אחד מבין~$a₁$,~$a₂$,…,~$aₙ$ נכשל, אז גם השיערוך של~$s$ נכשל.

  ✦ תוצאת השיערוך של הביטוי~$s$ היא תוצאת הפעלת~$s₁'$, כאשר מסתכלים עליו
  כפונקציה המקבלת כפרמטרים $n$ ביטויי S ומחזירה ביטוי \E|S| אחד, על $n$ האיברים
  שברשימה המשוערכת~$s₂'$.

  אם~$s₁'$ אינו פונקציה המקבלת $n$  פרמטרים, או שהפעלת פונקציה זו על
  הרשימה~$s₂'$ נכשלת, גם השיערוך של הביטוי~$s$ נכשל.
\end{enumerate}

§§§ אטומים שהם מספרים

ניזכר שבביטויי~S כל אטום הוא סדרת סימנים נטולת משמעות. בעבור הגלעין של ליספ,
מספיק להניח כי גם האטום 42 הוא סדרה (בת שתי אותיות) שאין לה משמעות מיוחדת. בכל
זאת, במרבית המימושים של ליספ, מסיבות של יעילות בעיקר, האטום 42 מייצג ערך שהוא
מספר שלם, והמימוש תומך בפעולות אריתמטיות על מספרים שלמים. במרבית המימושים, ישנם
גם אטומים שהם מספרים ממשיים בייצוג של נקודה צפה, כמו גם תמיכה ישירה באריתמטיקה
המתאימה.
 

תמיכה בחישובים אריתמטיים נעשית על ידי שינוי שיטת השערוך: אם האטום אותו יש לשערך
הוא סדרת ספרות הנחזית להיות מספר, אז השערוך של האטום נעשה ללא היוועצות בטבלת
הסמלים. באופן דומה, פעולות אריתמטיות נעשות באמצעות הגדרה מראש של קישור בין
האטום \A|+| לפעולת החיבור של מספרים, בין \A|*| ובין פעולת הכפל, וכו'.
ניבים של ליספ התומכים במספרים. 

הרחבות אלו אינן נחוצות לשם הבנה של ליספ, שכן ניתן לקודד בתוך ביטויי~S טהורים את
המספרים הטבעיים, את המספרים הממשיים, ולמעשה כל מבנה נתונים שניתן להעלות על
הדעת, וזאת על אף העובדה שהגלעין של ליספ אינו מסוגל לבדוק את תוכנה של סדרת
הסימנים היוצרת אטום. הפעולה היחידה המותרת על אטום בגלעין של ליספ היא השוואתו
לאטום אחר.

שיערוך
\begin{enumerate}
    \item אם האטום המשוערך הוא \A|NIL|, אז תוצאת השיערוך היא האטום \A|NIL|.
    \item אם האטום המשוערך הוא \A|T|, אז תותאצת השיערוך היא האטום \A|NIL|.
    \item אחרת, המנוע של ליספ מחפש את "
\end{enumerate}
כזה שיש לו CּARבשפת ליספ כל אטום הוא שם או סימבול,
ושיערוך של אטום
הוא ה.
המשמעות של אטום נקבעת על ידי חיפוש בטבלת סמלים. בשפת ליספ, רק אטומים הם שמות.

שפת LISP
ישור ושיערוך בשפת LISP
בשפת ליספ, שיערוך של רשימה מוגדר באופן רקורסיבי:
\begin{enumerate}
  ✦ שיערוך של כל אחד מהאיברים ברשימה.
  ✦ התייחסות לאיבר הראשון (\E|car|) ברשימה המשוערכת כאל פונקציה.
  ✦ התייחסות אל שארית (cdr) הרשימה המשוערכת כאל רשימת ארגומנטים (פרמטרים
  אקטואליים) לפונקציה
  ✦ קישור של הארגומנטים האקטואליים לפרמטרים הפורמליים
  ✦ חישוב הפונקציה
  ✦ הסרת הקישור שנעשה בשלב 4
  ✦ החזרה של תוצאת הפונקציה.
\end{enumerate}
הצעד הראשון בשבעת הצעדים של שיערוך רשימה הוא קריאה רקורסיבית, שבה משוערכים כל
אחד מאיברי הרשימה. בקריאה הרקורסיבית הזו תיתכנה ארבע אפשרויות:
\begin{enumerate}
  ✦
  קריאה רקורסיבית
  לשיערוך של nil מחזירה nil.
  ✦ קריאה רקורסיבית לשיערוך של רשימה, שתפעיל ברקורסיה את שבעת הצעדים של שיערוך רשימה.
  ✦ קריאה רקורסיבית לשיערוך של אטום, כמו foo, שתחפש את המשמעות של foo
\end{enumerate}

​6.7.4​ הגדרת פונקציה והפעלתה באמצעות ה-a-list
הגדרה של הפונקציה foo
(
defun
foo (x)
(
cons (cdr x) (car x)
)
)

תביא להוספת זוג לרשימת ה-a-list. זוג זה מייצג את הקישור בין השם foo ובין גוף
הפונקציה. וגוף הפונקציה גם הוא ביטוי בליספ, כלומר רשימה של דברים שכל אחד מהם או
אטום או רשימה.  המבנה המדוייק של גוף הפונקציה הוא:
(
LAMBDA-CLOSURE () () ()
(X)
(CONS (CDR X) (CAR X))
)
ממרבית הפרטים של הייצוג אפשר להתעלם. הפרטים החשובים הם:
רשימת הפרמטרים הפורמליים (שורה 3)
גוף הפונקציה (שורה 4)

אם נתרכז בגוף הפונקציה

(CONS (CDR X) (CAR X))
נזהה בו ארבעה אטומים:
CONS
CDR
x
CAR
שיערוך של גוף הפונקציה, מצריך שיערוך של ארבת האטומים. לכן, בעת הפעלת הפונקציה
יש לחפש אותם במחסנית ה-a-list לפי ערכה בזמן הקריאה לפונקציה. כדי לממש את העברת
הפרמטרים, מנגנון השיערוך של פונקציה מוסיף זוגות כמספר הפרמטרים של הפונקציה. (אם
בזמן הפעלת הפונקציה מספר הארגומנטים אינו מתאים למספר הפרמטרים הפורמליים, מנגנון
השיערוך מודיע על שגיאה, ועוצר.) בהפעלה של הפונקציה,
\begin{english}
(foo '((a b) (c d)))
\end{english}
יש לקשור את הארגומנט ((a b) (c d)) אל הפרמטר הפורמלי \E|x|. קישור זה נעשה על
ידי הוספת הזוג שחלק השם שלו הוא x וחלק המשמעות שלו הוא ((a b) (c d)) לתחילת
רשימת
ה-a-list. אחרי הוספה זו, ניתן לבצע את גוף הפונקציה. בכל פעם שגוף הפונקציה יפנה
לשערך את x הוא ימצא ערך זה. בכל פעם שגוף הפונקציה יפנה לשערך את השמות \E|CONS|,
CDR ו-\E|CAR|, הוא ימצא ברשימת ה-a-list את משמעותן של שלוש פונקציות אלו. לאחר
ביצוע
הפונקציה, יש להסיר את הזוג הזה שהוספנו, ובאופן כללי, את כל הזוגות היוצרים קשר
בין שם הפרמטר הפורמלי, ובין ערכו האקטואלי.  ראינו אם כן שהפעולה של שיערוך שם
(אטום), היא חיפוש במחסנית ה-\E|a-list|. לאחר מציאת המשמעות, אם האטום הוא האיבר
הראשון ברשימה, יש להתייחס אליו כפונקציה, שגורמת להוספת זוגות, כגודל שארית
הרשימה, למחסנית זו, ואחר כך, ביצוע הגוף בסביבה החדשה שנוצרה.

Lisp evaluator code Here is a test case you can use to demonstrate your
improved evaluator. It does not use def.

\begin{english}
(finkel-eval '(((lambda (x) (function (lambda (y) (cons x y)))) 3) 4) nil)
\end{english}

You need to fix a minor bug in the evaluator so that the following yields (1 .
2): (finkel-eval '(((lambda (x) (lambda (y) (cons 1 2))) 3) 4) nil) ; (1 . 2)

Bill Dieter typed in the code for eval from the book, but had to make some changes to make it work. Here is what he ended up with. He renamed eval and apply to finkel-eval and finkel-apply so they will not conflict with the builtin eval and apply.
Note that the common lisp error function takes a string as a parameter rather than a symbol. He also added cases in eval for numbers, strings, and t. Without these cases, you cannot use numbers, strings, or t.

\begin{LISP}
(defun finkel-eval (list env) ; evaluate list in env
(cond
((null list) nil)
((numberp list) list) ; Dieter added this
((stringp list) list) ; Dieter added this
((eq t list) list) ; Dieter added this
((atom list) (lookup list env)) ; Raphael removed Lisp-1.5 code
((eq (car list) 'quote) (car (cdr list)))
((eq (car list) 'cond) (evalcond (cdr list) env))
(t (finkel-apply (car list) (evallist (cdr list) env) env))))

(defun finkel-apply (fct parms env) ; apply fct to parms
(cond
((atom fct) (cond
((eq fct 'car) (car (car parms)))
((eq fct 'cdr) (cdr (car parms)))
((eq fct 'cons) (cons (car parms) (car (cdr parms))))
((eq fct 'get) (get (car parms) (car (cdr parms))))
((eq fct 'atom) (atom (car parms)))
((eq fct 'error) (error (string parms)))
((eq fct 'eq) (eq (car parms) (car (cdr parms))))
(t (cond
((get fct 'EXPR)
(finkel-apply (get fct 'EXPR) parms env) parms env)
(t (finkel-apply (lookup fct env) parms env))))))
((eq (car fct) 'lambda)
(finkel-eval (car (cdr (cdr fct)))
(update (car (cdr fct)) parms env)))
(t (finkel-apply (finkel-eval fct env) parms env))))

(defun evalcond (conds env) ;evaluate cond
(cond
((null conds) nil)
((finkel-eval (car (car conds)) env)
(finkel-eval (car (cdr (car conds))) env))
(t (evalcond (cdr conds) env))))

(defun evallist (list env) ;evaluate list
(cond
((null list) nil)
(t (cons (finkel-eval (car list) env)
(evallist (cdr list) env)))))

(defun lookup (id env) ; lookup id
(cond
((null env) (error "Unbound variable:~S" id))
((eq id (car (car env))) (car (cdr (car env))))
(t (lookup id (cdr env)))))

(defun update (formals vals env) ; bind parameters
(cond
((null formals)
(cond ((null vals) env)
(t (error "bad argument count"))))
((null vals) (error "bad argument count"))
(t (cons (cons (car formals)
(cons (car vals) nil))
(update (cdr formals) (cdr vals) env)))))
\end{LISP}במונחים שלנו, כל זוג כזה הוא קישור של שם לישות. במקרה זה, הישות אותה ניתן לשיים
היא עץ בצורה של S-Expression. המחסנית היא מבנה
נתונים המתאר במדויק את ה-Environment בכל רגע בביצוע התכנית. קריאה לפונקציה
תוסיף הגדרות (המאורגנות בזוגות) לתחילת ה-a-list. סיום הביצוע של פונקציה, וחזרה
לפונקציה הקוראת תסיר הגדרות אלו.

החיפוש אחרי משמעות של
אטום ב-\E|a-list| נעשה על ידי סריקת הרשימה עד אשר נמצא בה ביטוי-S שה-CAR שלו
זהה לאטום המבוקש. המשמעות של האטום היא ה-CDR של ביטוי זה.


