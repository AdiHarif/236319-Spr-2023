שפת LISP (ראשי תיבות של \E|LIst PRocessing|), היתה, יחד עם שפת Fortran (ראשי
תיבות של \E|FORmula TRANslation|) אחת משתי שפות התכנות הראשונות. ליספ פותחה
ב-MIT על ידי \E|John McCarthy| עוד ב-1956. מלכתחילה, ליספ לא נתפסה על ידי
ממציאה כשפת תכנות, אלא כתחשיב מתימטי המיועד לכתיבת אלגוריתמים, הדומה לתחשיב
ה-$λ$. רק לאחר מכן, מומש התחשיב כשפת תכנות.

בתחשיב זה, כל תכנית נקראת "\ע|ביטוי S|", והרצת התכנית קרויה "שיערוך"
(\E|Evaluate|) של הביטוי.

בנוסף לתחשיב McCarthy הציג גם אלגוריתם אוניברסלי, \E|eval| המסוגל להריץ תכניות
בליספ. ליספ הפכה לשפת תכנות כאשר האלגוריתם הזה מומש בשפת תכנות. מאז, זכתה
ליספ לגלגולים רבים: התחשיב המקורי הפך לשפת תכנות של ממש, וזכה להרחבות רבות.
פותחו ניבים רבים לשפה, והיא מצוייה בשימוש נרחב. מאוחר יותר, נמצא מי שכתב מימוש
של \E|eval| בשפת ליספ עצמה.

פרק זה איננו עוסק בליספ כשפת תכנות, וגם לא באף אחד מהניבים שלה, אלא מתרכז רק
בהצגת הגלעין (\E|core|) של השפה. הגלעין שיוצג כאן הוא מינימלי ביותר,
והוא כולל הגדרה של כתריסר שמות בלבד:
\begin{itemize}
  ✦ \ע|2 קבועים (פונקציות ללא פרמטרים)|: \E|t| ו-\E|nil|.
  ✦ \ע|3 פונקציות מבניות|: \E|car|, \E|cdr|, ו-\E|cons|.
  ✦ \ע|3 פונקציות לוגיות|: \E|eq|, \E|atom|, ו-\E|null|.
  (הפונקציה \E|null| אינה חיונית, והיא ניתנת למימוש באמצעות פונקציות אחרות
  בגלעין.)
  ✦ \ע|2 פונקציות המסייעות בכתיבת פונקציות|:
  \E|lambda|, ו-\E|nlambda|.
  (הפונקציה \E|defun| אינה חיונית, והיא ניתנת למימוש באמצעות פונקציות אחרות
  בגלעין.)
  ✦ \ע|3 פונקציות המסייעות במתן משמעות לשמות|:
  \E|set|, \E|quote|, ו-\E|defun|.
(הפונקציות \E|defun| ו-\E|quote| אינן חיוניות, והן ניתנות למימוש באמצעות
פונקציות אחרות בגלעין.)
\end{itemize}

הגלעין של ליספ, בניגוד לכמעט כל הדיאלקטים שלה, אינו תומך במספרים ובפעולות
אריתמטיות. רוב הדיאלקטים של ליספ, יודעים להדר, באופן חלקי או מלא, תכניות ליספ
לשפת מכונה. גם הידור כזה אינו נחוץ בגלעין של השפה. על אף המינימליות של הגלעין,
הוא טיורינג שלם: כל תכנית שאפשר לכתוב בכל שפת תכנות, אפשר לכתוב גם בגלעין של

ליספ. בפרט, כפי שנדגים כאן, ניתן לממש את הפונקציה את \E|eval| בגלעין. באופן
הגלעין נמנע מלתמוך בשום תכונה של ליספ שאינן נחוצות כדי לממש את
הפונקציה \E|eval|.

הגלעין של ליספ מעניין שכן הוא מציג בצורה פשוטה וקלה רעיונות יסודיים, כגון עיבוד
רקורסיבי של רשימות, קישור של שמות לערכים, העברת פרמטרים, הסתכלות על תכנית כמבנה
נתונים, ועוד.

לא רק תכניות הם ביטויי \E|S|. כל הערכים בשפת ליספ הם ביטויי S
\E|(S-Expressions)|. המונח S-Expression בא לעולם כקיצור למונח \E|symbolic
expression| (ביטוי
סימבולי). המילה "סימבולי" באה להדגיש שמדובר שאין מדובר בהכרח בביטוי מתימטי
כגון~$13+41/2$, שבו המשמעות של כל הסימנים ידועה בדרך כלל, אלא בביטוי כללי
שיכול להכיל סימבולים שמשמעותם דורשת הגדרה מפורשת, כגון
\begin{equation*}
  (\amalg ⊙ ℶ) ⊘ (\Re ≀ \Game)
\end{equation*}
בביטוי זה, קל לזהות את האופרנדים
($\amalg$,~$ℶ$,~$\Re$ ו-$\Game$)
ואת האופרטורים
($⊙$,~$⊘$ ו-$≀$)
אולם משמעותם של אלו דורשת הגדרה מפורשת.

תכנית בשפת ליספ היא פונקציה שיכולה לקבל כארגומנטים ביטויי~S והיא מחזירה
ביטוי~\E|S|. כאמור, כל פונקציה כזו, היא בעצמה ביטוי \E|S|.

§§ ביטויי S

\newcommand\SX{\ensuremath{S_{\text{exp}}}}

בהינתן אלפבית~$Σ$, נגדיר את~$\SX(Σ)$, קבוצת "ביטויי ה-S", מעל~$Σ$.
אינטואיטיבית, ביטוי~S יכול להיות אטומי, ואז הוא חייב להיות מילה מתוך~$Σ^*$.
ביטוי S שאינו אטומי הוא בהכרח זוג סדור של שני ביטויי~S אחרים. הזוג הסדור נכתב
עטוף בזוג סוגריים ושני הביטויים הסימבוליים שבו מופרדים בסימן הנקודה.

כמה ביטויי~S מעל האלפבית~$Σ=❴a,b,c❵$ הם \[
  a,b,(a.b),(c.(b.a)),((a.b).(a.c))∈\SX❨❴a,b,c❵❩.
\] לעומת זאת,~$(a.b.c)$ אינו שייך ל~$\SX(Σ)$ משום שהוא שלשה סדורה ולא זוג סדור,
ואילו~$(a(b(c)))$ אינו שייך לקבוצה, משום שהוא אינו עונה על הדרישה שבין פריטים
ימצא סימן הנקודה.

הקבוצה~$\SX(Σ)$ היא שפה פורמלית מעל אלפבית מורחב, המתקבל מהוספת סימן הנקודה ואת
שני סימני הסוגריים לאלפבית~$Σ$ (אנו מניחים, בלי הגבלת הכלליות, ששלושת הסימנים
הללו אינם מצוים ב-$Σ$.)

ניתן לאפיין את השפה~$\SX(Σ)$ באמצעות כללי היסק:
\begin{definition}[ביטויי S מעל אלפבית]
  בהנתן אלפבית~$Σ$ אזי,~$\SX(Σ)$, קבוצת ביטויי ה-S מעל~$Σ$
  מוגדרת באמצעות הבנאי הנולארי (כלומר איברים אטומיים):
  \begin{equation*}
    \infer{w∈\SX(Σ)}{w∈Σ^*}
  \end{equation*}
  והבנאי הבינארי:
  \begin{equation*}
    \infer{(τ₁.τ₂⟩∈\SX(Σ)}{τ₁∈\SX(Σ) &τ₂∈\SX(Σ)}
  \end{equation*}
\end{definition}

ניתן להגדיר את~$\SX(Σ)$ גם באמצעות דקדוק חסר הקשר
\begin{equation}
  \begin{split}
    S &→(S.S)⏎
    S &→A ⏎
    A &→ε⏎
    A &→Aσ₁ ⏎
    A &→Aσ₂ ⏎
    ⋮ ⏎
    A &→Aσₙ ⏎
  \end{split}
\end{equation}
כאשר~$Σ=❴σ₁,σ₂,…,σₙ❵$.

נוח לחשוב על ביטויי S כעצים בינאריים מלאים (כלומר, שלכל צומת שאינה עלה יש בדיוק
שני בנים(כאשר צומת פנימית של עץ כזה אינו נושא מידע, ואילו עלה מכיל מילה
מתוך~$Σ^*$. הנה כמה ביטויי S והתיאור שלהם כעץ בינארי מלא.

\begin{LTR}
  \begin{tabular}{cccccc}
    $(ab.cd)$ &
    $(abcd.ε)$ &
    $(ab.(c.d))$ &
    $((a.b).(c.d))$ &
    $(a.(b.(c.d)))$ &
    $(((a.b).c).d)$ ⏎
    \scriptsize \Forest{s tree [{},cons[$ab$,atom][$cd$,atom]]} &
    \scriptsize \Forest{s tree [{},cons[$abcd$,atom][$ε$,atom]]} &
    \scriptsize \Forest{s tree [{},cons[$ab$,atom][{},cons[$c$,atom][$d$,atom]]]} &
    \scriptsize \Forest{s tree [{},cons[{},cons[$a$,atom][$b$,atom]][{},cons[$c$,atom][$d$,atom]]]} &
    \scriptsize \Forest{s tree
    [{},cons
    [{},cons
    [{},cons[a,atom][b,atom]]
    [c,atom]
    ]
    [d,atom]
    ]
    } &
    \scriptsize \Forest{s tree
    [{},cons
    [{}, cons
      [{}, cons [a,atom][b,atom]]
      [c,atom]
    ]
    [d,atom]]
    }
  \end{tabular}
\end{LTR}

§§ ביטויי S בשפת ליספ וכתיב הרשימות

שפת ליספ מרחיבה מעט את ההגדרה של ביטויי-S כפי שהצגנו אותה למעלה, אבל, בסופו של
דבר, ביטויי S בליספ היא הקבוצה~$\SX$ מעל אלפבית הכולל בתוכו את האותיות
\texttt{A} עד \texttt{Z}, ספרות, וגם מרבית הסימנים המיוחדים, כולל \texttt{-},
\texttt{+} ועוד.

לביטוי S מורכב קוראים בשפת ליספ \E|cons|. לאיבר הראשון ב-\E|cons|, קוראים
\E|car|, ולאיבר השני ב-cons קוראים \E|cdr|. לזוג כולו קוראים \E|cons|.

לביטוי S אטומי בשפת ליספ קוראים אטום \E|(atom)|. דוגמאות לאטומים הן \T|A|,
\T|12B|, \T|ZZZ| ו-\T|+|. מסיבות היסטוריות, האלפבית של אטומים בליספ אינו מכיל
אותיות קטנות. מערכות ליספ מתרגמת את האותיות הקטנות לאותיות גדולות כשהן מופיעות
בתוך אטומים.

סדרת התווים המגדירה אטום יכולה להיות גם~$ε$, הסידרה הריקה. השם \T|nil| מציין את
האטום שסדרת התווים שלו היא~$ε$. כפי שנראה בהמשך, גם הכתיב \T|()| מציין את האטום
הזה. סדרת התווים המגדירה אטום היא חסרת משמעות בדרך כלל, אולם המתכנת בליספ יכול
להעניק לאטומים נבחרים משמעות. בנוסף, יש מספר אטומים שהמשמעות שלהם מוגדרת מראש
בשפה.

\ע|רשימה| \E|(list)| בליספ היא סדרה של פריטים המופרדים ברווחים והעטופה
בסוגריים. כל פריט ברשימה יכול להיות ביטוי~\E|S|, או רשימה בעצמו.

כך, \T|(A B C D)| היא הרשימה המכילה ארבעה פריטים: האטומים \T|A|, \T|B|, \T|C|
ו-\T|D|. הרשימה הריקה, זו שאינה מכילה אף פריט, נכתבת כ-\T|()|, ואילו
\T|((A.C) C)| היא רשימה המכילה שני פריטים, שהראשון בהם הוא ביטויי~S
מורכב, \T|(A.C)|, והשני הוא האטום \T|C|.

כל רשימה היא כתיב מקוצר לביטוי~\E|S|. הכתיב מוגדר באינדוקציה על אורך הרשימה:
הרשימה ריקה \T|()| היא כתיב אחר לאטום \T|NIL|. רשימה שאינה ריקה, היא כתיב מקוצר
לביטוי~S מורכב, כלומר זוג של ביטויי~\E|S|. האיבר הראשון בזוג הוא האיבר הראשון
ברשימה. האיבר השני בזוג, הוא הייצוג של שארית הרשימה.

לפיכך, הרשימה \T|(A B C D)| היא כתיב אחר לביטוי~S
\begin{LTR}
  \T|(A.(B.(C.(D.NIL))))|
\end{LTR}
כלומר, העץ הבינארי המלא המוצג ב\פנה|איור:NIL|.

\begin{figure}{H}
\caption{יצוג הרשימה \T|(A B C D)|
  כעץ בינארי.
}
\label{איור:רשימה}
\begin{LTR}
  \forestset{%
    xil/.style={circle,inner sep=-6pt,fill=white,nice empty nodes,tikz={\draw [rotate=-160,scale=0.44]
            % \pgfsetlinewidth{6\pgflinewidth} % thickness
            ($(.center)!0.2!(!parent)$)
            coordinate (o)
            % (o)++(-0.520,0)--++(1.04,0)
            % (o)++(-4,1)--++(8,0)
            % (o)++(-0.380,.180)--++(.760,0)
            % (o)++(-2,3)--++(4,0)
            %% (o)++(-0.180,0.360)--++(0.360,0)
            ;}},
  } \begin{forest}
    s tree [{},cons [A,atom]
    [{},cons [B,atom]
    [{},cons [C,atom]
    [{},cons [D,atom]
    [$ε$,atom]
    ]
    ]
    ]
    ]
  \end{forest}
\end{LTR}
\end{figure}

הפריטים ברשימה הם ביטויי~\E|S|, אבל כיוון שרשימה גם היא ביטוי~\E|S|, רשימה
יכולה להכיל בתוכה רשימות. למשל,
\begin{LTR}
  \T|((A B) C)|
\end{LTR}
היא רשימה המכילה בתוכה שני פריטים, הראשון שבהם הוא רשימה בת שני אטומים, והשני
שבהם הוא אטום. רשימה זו ניתנת לתיאור באמצעות ביטוי \E|S|,
\begin{LTR}
  \T|((A.(B.NIL)).(C.NIL))|
\end{LTR}
העץ הבינארי המתאים לרשימה מקוננת זו מוצג ב\פנה|איור:רשימה:זוג|
\begin{figure}{H}
  \caption{הרשימה המקוננת \T|((A B) C)| כעץ}
  \label{איור:רשימה:מקוננת}
\begin{LTR}
  \begin{forest}
    s tree [{},cons
    [{},cons
    [B, atom]
    [{},cons[C,atom] [$ε$,atom] ]
    ]
    [{},cons
    [C,atom]
    [$ε$,atom]
    ]
    ]
  \end{forest}
\end{LTR}
\end{figure}

לא כל ביטוי~S ניתן להיכתב בכתיב הרשימות. למשל הביטוי \T|(A.B)| אינו ניתן להכתב
כרשימה. אבל כל רשימה ניתנת להיכתב כביטוי~\E|S|. נהוג לכתוב ביטויי~S בכתיב
הרשימות בכל אימת שניתן לעשות זאת.

§§ פעולות על ביטויי~S

הגלעין של ליספ תומך בפעולות מבניות אלמנטריות על ביטויי \E|S|. המשמעות של שלושת
האטומים \T|CONS|, \T|CAR|, ו-\T|CDR| מוגדרת מראש לציין פעולות מבניות אלו:

\begin{enumerate}
  ✦ האטום \T|CONS| מציין פונקציה המקבלת שני ביטויי~\E|S|, ומחזירה ביטוי~S
  שהוא זוג בו האיבר הראשון הוא הארגומנט הראשון לפונקציה, ואילו האיבר השני של
  הזוג הוא הארגומנט השני לפונקציה.

  נשים לב לכך שאם הארגומנט השני לפונקציה זו הוא רשימה, אז הפונקציה מחזירה
  רשימה חדשה שבה הפריט הראשון הוא הארגומנט הראשון לפונקציה ושאר
  הפריטים הם כמו אלו שהיו ברשימה שהיא הארגומנט הראשון.

  ✦ האטום \T|CAR| מציין פונקציה המקבלת כארגומנט ביטוי~S אחד. אם ביטוי זה הוא
  ביטוי מורכב, הפונקציה מחזירה ביטוי~S שהוא האיבר הראשון בזוג ממנו הארגומנט
  בנוי.

  לעומת זאת, אם הארגומנט לפונקציה הוא אטום, הפונקציה נכשלת. כשלון זה דומה
  לכשלון של ניסיון לחלוקה באפס. ממש כשם שלא כל הפעולות האריתמטיות מוגדרות על כל
  המספרים, לא כל הפונקציות המבניות מוגדרות על כל כל ביטויי~\E|S|.

  אם הארגומנט לפונקציה הוא רשימה שאיננה ריקה, אז הפונקציה מחזירה את הפריט
  הראשון ברשימה. כאמור, אם הארגומנט ל-\E|CAR| הוא אטום, ואפילו יהא זה
  האטום \T|NIL|, כלומר הרשימה הריקה, הפונקציה נכשלת.

  ✦ האטום \T|CDR| מציין פונקציה המקבלת כארגומנט ביטוי~S אחד. אם ביטוי זה הוא
  ביטוי מורכב, הפונקציה מחזירה ביטוי~S שהוא האיבר השני בזוג ממנו הארגומנט בנוי.
  אם הארגומנט לפונקציה הוא אטום, הפונקציה נכשלת.

  אם הארגומנט לפונקציה הוא רשימה שאינה ריקה, אז הפונקציה מחזירה את
  שארית הרשימה, כלומר, הרשימה בלעדי האיבר הראשון שבה.
\end{enumerate}

הגלעין של ליספ תומך גם בפונקציות לוגיות המאפשרות לבדוק את תוכנו של
ביטויי~\E|S|. המשמעות של שלושת האטומים \T|ATOM|, \T|NULL|, ו-\T|EQ| מוגדרת
מראש לפונקציות המאפשרות בדיקות כאלו:

\begin{enumerate}
  ✦ האטום \T|ATOM| מציין פונקציה המקבלת ביטוי~S אחד ומחזירה את האטום \T|T| אם
  ארגומנט זה הוא אטום, ואחרת את האטום \T|NIL|.

  ✦ האטום \T|NULL| מציין את הפונקציה המקבלת ביטויי~S אחד ומחזירה את האטום
  \T|T|.

  אם ארגומנט זה הוא האטום \T|NIL| ואחרת את האטום \T|T| אם הארגומנט לפונקציה הוא
  רשימה, אז הפונקציה מחזירה \T|T| אם ורק אם הרשימה ריקה ו-\T|NִִIL| בכל
  מקרה אחר.

  ✦ האטום \T|EQ| מציין את הפונקציה המקבלת שני ביטויי~S ומחזירה את האטום \T|T|
  אם שני הארגומנטים לפונקציה הם אטומים, ושני האטומים הללו שווים. בכל מקרה אחר,
  הפונקציה מחזירה את האטום \T|NIL|.
\end{enumerate}

ניתן לחשוב על האטום \T|NIL| כמסמן את הערך של שלילה לוגית, כלומר \E|false|, ועל
האטום \T|T| כמסמן את ערך האמת, \E|true|.

§§ ביטויי S כעצים מעל אלאפבית

ראינו שביטויי S ניתנים להצגה כעץ בינארי שבו העלים, והעלים בלבד, מכילים
סימבולים. אם ביטוי S ניתן להכתב כרשימה של רשימות, אז ניתן להציג את הביטוי הזה
כ\ע|עץ|, שבו קיים סימבול בכל צומת פנימית ובכל עלה. ומספר הבנים של כל צומת
פנימית יכול להיות כלשהו.

בהנתן אלפבית~$Σ$, נגדיר את~$T(Σ)$, קבוצת העצים שבכל צומת שלהם ישנו איבר של~$Σ$.
עץ כזה יכול להיות עץ אטומי, ואז העץ מצטמצם לכדי עלה בודד, שחייב להכיל איבר
של~$Σ^*$. עץ ב-$T(Σ)$ יכול להיות גם עץ מורכב, ובמקרה זה הוא מורכב מצומת פנימי
שבו יש אות של~$Σ$ ומספר כלשהו של בנים שכולם עצים ב-\E|$T(S)$|. בניסוח זה, אנו
רואים שעץ אטומי הוא עץ מורכב שיש לו אפס בנים.

נוכל להגדיר את הקבוצה~$T(Σ)$ כשפה פורמלית מעל אלפבית מורחב, הכולל גם את זוג
סימני הסוגריים ואת סימן הפסיק בא בהנתן אלפבית~$Σ$ אזי,~$T(Σ)$,
\begin{definition}[עצים מעל אלפבית]
  בהנתן אלפבית~$Σ$ אזי,~\E|$T(Σ)$|, קבוצת העצים מעל~$Σ$ מוגדרת באמצעות הבנאי
  ה-$n$ מקומי
  \begin{equation*}
    \infer{w(t₁,…,tₙ)∈\SX(Σ)}{w∈Σ^* & n≥0 & t₁∈T(Σ) & t₂∈T(Σ)&⋯& tₙ∈T(Σ)}
  \end{equation*}
\end{definition}

כמה איברים פשוטים של קבוצת העצים מעל האלפבית בן שלוש האותיות~$Σ=❴a,b,c❵$ הם \[
  a, b, c, a(b,c), a(b(a)), a(a,b,c)∈T(❴a, b, c❵)
\] \cref{figure:tree} מדגים את הטופולגיה של העץ המורכב יותר
$a(a(a,ab,abc),b(b,ab(c)),c(c(a(ab)))∈T(❴a, b, c❵)
)$
\begin{figure}[H]
  \centering
  \forestset{%
    x tree/.style={
        for tree={
            math content,
            s sep'+=-3pt,
            fit=band,
          },
      },
  }
  \begin{forest}
    s tree [a
          [a,[a][ab][abc]]
          [b,[b][ab[c]]]
          [c,[c[a[ab]]]]
      ]
  \end{forest}
  \caption{העץ~$a(a(a,ab,abc),b(b,ab(c)),c(c(a(ab))))$.}
  \label{fig:tree}
\end{figure}

אם ביטוי S הוא רשימה של רשימות, אזי ניתן להציגו כעץ. התרגום מתבצע על ידי הפיכת
כל רשימה בביטוי לתת-עץ: האיבר הראשון ברשימה הוא שורש תת-העץ. שאר האיברים
ברשימה, הם הבנים של תת העץ. לדוגמה, בעבור הרשימה
\begin{LTR}
  \T|(a b (car x) (+b x))|
\end{LTR}
יבנה כך העץ
\begin{LTR}
  \scriptsize
  \forestset{%
    x tree/.style={
        font=\ttfamily,
        for tree={
            s sep'+=-3pt,
            fit=band,
          },
      },
  }
  \begin{forest}
    x tree [a,
        [a, [car, [x]]]
          [+, [b] [x]]
      ]
  \end{forest}
\end{LTR}

נשים לב לכך שהפונקציה \E|car|, כשהיא מופעלת על עץ מעל אלאפבית מחזירה את תוכנו
של הצומת שבשורש העץ, ואילו הפונקציה \E|cdr| מחזירה את רשימת הבנים של הצומת, שכל
אחד מהם הוא עץ כזה בעצמו.

§§ עצי שיערוך

ניתן להסתכל על עץ מעל אלאפבית, שבו יש סימבול בכל צומת, ושבו הדרגה אינה מוגבלת,
כעץ "שיערוך". נסתכל למשל על הביטוי הבא בשפת~\CPL
\begin{CPP}
  f(2) ? g(++a,--b,-sin(c)) : 10+h()
\end{CPP}
חישוב ביטוי כגון זה, דורש ראשית הבנה של המונחים שבו. חישוב הכולל הבנת מונחים
פיענוח משמעות הסימבולים אנו קוראים שיערוך \E|(evaluation)|.
נתאר את השיערוך של הביטוי הזה על ידי הצגתו כעץ השיערוך המתואר ב\פנה|איור:עץ|.

\begin{figure}[H]
  \caption{
    עץ החישוב של הביטוי \T|f(2) ? g(++a,--b,-sin(c)) : 10+h()|.
}
\label{איור:עץ}
  \begin{english}
    \scriptsize
    \forestset{%
      x tree/.style={
          for tree={
              font=\ttfamily\scriptsize,
              s sep'+=-3pt,
              l sep'+=-3pt,
              fit=band,
            },
        },
    }
    \begin{forest}
      x tree [\E|?:|,
      [$f()$ [$2$]]
      [$g()$
      [\T|++|[$a$]]
      [\T|--|[$b$]]
      [$-$ [$\sin()$ [$c$]]]
      ]
      [$+$[$10$][$h()$]]
      ]
    \end{forest}
  \end{english}
\end{figure}
שיערוך הביטוי בשפת~\CPL ניתן לתיאור רקורסיבי באמצעות העץ שבאיור.
כדי לשערך עלה, יש להבין ראשית את משמעותו: בעץ שבאיור יש שישה עלים:
\begin{itemize}
  ✦ משמעות העלים המסומנים ב-$2$ וב-$10$ היא המספרים~$2$ ו-$10$, שכן בשפת~\CPL
  סדרות התווים \T|2| ו-\T|10| הן ליטרלים, כלומר סדרות אלו מציינות ערך הנקבע
  באופן יחיד על ידי תוכן הסדרה, ללא תלות בטבלת סימבולים כלשהי.
  ✦ משמעות העלים המסומנים ב-$a$, \E|$b$| וב-$c$ נעשית על ידי חיפוש השמות הללו
  בטבלת הסמלים, שכן בשפת~\CPL סדרות התווים \T|a|, \T|b| ו-\T|c| הם מזהים. מזהים
  אלו מתייחסים, ככל הנראה, למשתנים אשר הוגדרו קודם.
  ✦ משמעות העלה המסומן ב-$h()$ גם היא נעשית באמצעות חיפוש השם~$h$
  בטבלת הסמלים, אלא שנדרש שהחיפוש בטבלה יקשור את השם לפונקציה.
  אם על פי החיפוש, משמעות השם~$h$ היא משתנה, אזי השיערוך של הביטוי יכשל.
\end{itemize}

שערוך של צומת פנימית, מתחיל באופן דומה. ראשית יש לברר את משמעות הסימבול אשר
נמצא בתוך הצומת. בדוגמה שלנו, הסימבולים \T|+|, \T|-|, \T|++|, \T|--| ו-\T|?:|
הם אופרטורים של שפת~\CPL. כלומר, המשמעות שלהם קבועה מראש בשפה, ולכן אין לחפש את
משמעותם בטבלת שמות. לעומת זאת, \T|f|, \T|g| ו-\T|sin| הם שמות שהוגדרו על ידי
מתכנת†{נזכר שהפונקציה~$\sin$ אינה בנויה בשפת~\CPL, אלא היא מוגדרת באחת
מהסיפריות.} לאחר פענוח משמעותה של צומת פנימית, יש לחשב את ערכי תתי העצים של
הצומת, ולהעביר אתוצאות החישוב של תתי העצים כארגומנטים לפונקציה.

ניתן להבין באופן מדוייק יותר את תהליך השיערוך באמצעות בדיקה של האופן שבו הוא
מתבצע בשפת ליספ.

§§ שיערוך בליספ
המפרש (interpreter) של ליספ, עובד בדרך הידועה בשם \E|REPL|, שהם ראשי תיבות של
\begin{description}
  ✦ [READ] המפרש קורא ביטוי~\E|S|, הנכתב, בדרך כלל, בכתיב הרשימות.
  ✦ [EVALUATE] המפרש משערך את ערכו של הביטוי שקרא.
  ✦ [PRINT] אם השיערוך של הקלט מצליח, אז המפרש מדפיס את תוצאת השיערוך. אחרת,
  המפרש ידפיס הודעת שגיאה מתאימה.
  ✦ [LOOP] המפרש חוזר לצעד הראשון, לקריאת הביטוי הבא
\end{description}

נתאר כעת כיצד המפרש משערך ביטוים.

§§§ שערוך של אטומים
השיערוך של ביטויי-S מוגדר רקורסיבית. בסיס הרקורסיה הוא בשיערוך של אטומים. אם
האטום הוא אחד מבין
\T|CAR|, \T|CDR|, \T|CONS|, \T|EQ| ושאר
הפונקציות שבגלעין של ליספ, אזי משמעות האטום
היא פונקציה זו.

לשם שיערוכם של אטומים אחרים ליספ מחזיקה טבלת סמלים, הקושרת בין אטומים ובין
משמעותם. אם אטום נמצא בטבלת הסמלים הזו, השיערוך שלו יחזיר את הערך שטבלת הסמלים
קושרת לאטום. כזכור, כל אטום הוא מלכתחילה סדרת תווים שהיא חסרת משמעות כשלעצמה.
לכן, השיערוך של אטום שאינו שמה של פונקציה בגלעין, ושאינו נמצא בטבלת הסמלים,
יכשל.

טבלת הסמלים בליספ מאורגנת במבנה נתונים הידוע בליספ בשם \E|association list| או
בקיצור \E|a-list|. ה-\E|a-list| היא רשימה של פריטים אשר כל אחד מהם מבטא קישור
של שם לערך: כל פריט הוא ביטוי S מורכב, כלומר cons. ה-car של הפריט הוא שם
(המיוצג כאטום) ואילו ה-cdr של הפריט הוא משמעותו של השם (שהיא \E|S-Expression|,
אטומי או מורכב: אם משמעותו של האטום foo היא העץ~$ϕ$ אז הפריט הנשמר ב-\E|a-list|
הוא~$(\text{foo}.φ)$. הקישור בין השם והישות הוא בדיוק בעובדה ששני אלו מחוברים
ברשומת \E|cons|.

רשימה ה-\E|a-list| מנוהלת כמחסנית, כלומר פריטים מתווספים ומוסרים ממנה רק
בתחילתה. החיפוש אחר משמעות ברשימה נעשה סדרתית, בסריקה המתחילה בתחילת הרשימה.
חיפוש המשמעות של האטום foo נעצר בזוג הראשון שבו מרכיב השם הוא foo. החיפוש נכשל
אם לא נמצא זוג כזה.

כאשר המפרש של ליספ מתחיל את עבודתו, ה-\E|a-list| מכילה קישורים בעבור אטומים
המוגדרים מראש בשפה.
כאמור, בגלעין של ליספ יש משמעות מוגדרת מראש לאטומים הבאים: \E|t|, \E|nil|,
\E|car|, \E|cdr|, \E|cons|, \E|eq|, \E|atom|, \E|null|, \E|set|, \E|quote|,
\E|cond|, \E|lambda|, ו-\E|defun|.
מתוך אלו, \E|car|, \E|cdr|, \E|cons|, \E|eq|, \E|atom|, \E|set|, \E|quote|,
\E|cond|, ו-\E|lambda| הם פונקציות פרימיטיביות, אשר לא ניתן לכתוב אותן כביטויי
\E|S|, ולכן אטומים אלו לא יופיעו בדרך כלל בתוך ה-\E|a-list|.

לעומת זאת, האטומים \E|t| ו-\E|nil| מייצגים פונקציות 0-מקומיות, כלומר קבועים,
והם ניתנים לייצוג בשפה. התוכן המינימלי של ה-\E|a-list| הוא על כן
\begin{english}
  \begin{quote}
    \T|((T.T) (NIL.NIL))|
  \end{quote}
\end{english}
הפריט הראשון ברשימה אומר שמשמעות של האטום \T|T| היא אטום זה עצמו. הפריט השני
ברשימה אומר שמשמעותו של האטום \T|NIL| היא אטום זה עצמו גם כן.
לפיכך, כאשר המפרש של ליספ יקרא את האטום \T|T| הוא ידפיס בתגובה \T|T|, וכאשר הוא
יקרא את האטום \T|NִִִIL| הוא ידפיס בתגובה \T|NIL|.
אין לדעת מה תהיה התגובה של המפרש של ליספ יקרא אטום כגון
\T|CAR| המייצג פונקציה פרימיטיבית, שכן שערוך האטום
\T|CAR| מחזיר דבר מה שאינו ביטוי S.

מתכנת בליספ יכול להוסיף פריטים ל-\E|a-list| באמצעות הפונקציות \E|set|
ו-\E|defun|.

§§§ שיערוך ביטוי מורכב

אם המפרש של ליספ נתקל בביטוי מורכב \E|$s$|, הוא מנסה להציג אותו כרשימה בת~$n+1$
איברים \[
  s=(s₀\;\;s₁\;\;⋯\;\;sₙ).
\] אם הרשימה ריקה, תוצאת השערוך היא האטום \E|NIL|.
אחרת, המפרש מסתכל על הרשימה כעל עץ שיערוך: כלומר, קריאה לפונקציה~$s₀$
המקבלת~$n$ ארגומנטים \E|$s₁$,…,$sₙ$| ומנסה לשערך
את~$s$ על פי הסתכלות זו. לשם כך, ממשיך המפרש בצעדים הבאים:
\begin{enumerate}
  ✦ שיערוך רקורסיבי של~$s₀$, הפונקציה אותה יש להפעיל. אם השיערוך של~$s₀$ נכשל,
  אזי גם השיערוך של~$s$ נכשל. אחרת, שיערוך זה מחזיר ביטוי \E|S| שנסמן~$s₀'$.

  השיערוך של~$s$ נכשל גם אם~$s₀'$ אינו פונקציה, או שהוא פונקציה, אך כזו שאינה
  מצפה ל-$n-1$ ארגומנטים בדיוק.

  ✦ המפרש ממשיך כעת לשערך רקורסיבית את הארגומנטים לפונקציה~$s₀'$, הלא הם
  הביטויים~\E|$s₁$~,…,~$sₙ$|. נסמן את תוצאות השיערוך הללו ב-\E|$s₁'$,…,$sₙ'$|.
  אם השיערוך הרקורסיבי של אחד מבין~\E|$s₁$,…,~$sₙ$| נכשל, אז גם השיערוך של~$s$
  כולו נכשל.

  ✦ תוצאת השיערוך של הביטוי~$s$ היא תוצאת הפעלת הפונקציה~$s₀'$ על~$n$ הביטויים
  $s₁'$,…,~$sₙ'$. אם הפעלת זו נכשלת, השיערוך של הביטוי~$s$ כולו נכשל.
\end{enumerate}

§§§ אטומים שהם מספרים

ניזכר שבביטויי~S כל אטום הוא סדרת סימנים נטולת משמעות. בעבור הגלעין של ליספ,
מספיק להניח כי גם האטום 42 הוא סדרה (בת שתי אותיות) שאין לה משמעות מיוחדת. בכל
זאת, במרבית המימושים של ליספ, מסיבות של יעילות בעיקר, האטום 42 מייצג ערך שהוא
מספר שלם, והמימוש תומך בפעולות אריתמטיות על מספרים שלמים. במרבית המימושים, ישנם
גם אטומים שהם מספרים ממשיים בייצוג של נקודה צפה, כמו גם תמיכה ישירה באריתמטיקה
המתאימה.

תמיכה בחישובים אריתמטיים נעשית על ידי שינוי שיטת השערוך: אם האטום אותו יש לשערך
הוא סדרת ספרות הנחזית להיות מספר, אז השערוך של האטום נעשה ללא היוועצות בטבלת
הסמלים. באופן דומה, פעולות אריתמטיות נעשות באמצעות הגדרה מראש של קישור בין
האטום \T|+| לפעולת החיבור של מספרים, בין \T|*| ובין פעולת הכפל, וכו'.

מסיבה זו, בכמעט כל הניבים של ליספ, ניתן לכתוב ביטויים אריתמטיים בכתיב
הרשימות, והשערוך שלהם יביא לתוצאה הצפוייה,

\begin{english}
\begin{verbatim}
> (+2 (* 3 5))
17
\end{verbatim}
\end{english}

הרחבות אלו אינן נחוצות לשם הבנה של ליספ, שכן ניתן לקודד בתוך ביטויי~S את
המספרים הטבעיים, את המספרים הממשיים)ולמעשה כל מבנה נתונים שניתן להעלות על
הדעת(, וניתן באמצעות הגלעין של ליספ לממש את כל הפונקציות האריתמטיות. אבל, כיוון
שהגלעין של ליספ אינו מסוגל לבדוק את תוכנה של סדרת הסימנים היוצרת אטום)הפעולה
היחידה המותרת על אטום בגלעין היא השוואתו לאטום אחר(הגלעין אינו יכול להפוך את
אטום כמו \T|43217| לליטרל אשר משמעותו היא המספר הטבעי \E|$43,217$|,
דהיינו, ארבעים ושלושה אלפים ומאתיים ושבע עשרה.

§§ דחיית שיערוך

אם ננסה להפעיל את פרוצדורת השיערוך, כפי שתוארה עד כה, על אינו מספיק כדי לשערך
את העץ ב\פנה|איור:עץ| כהלכה. הסיבה היא שהאופרטור הטרנארי \T|?:|)אשר מצוי בשורש
העץ(, מחשב את הארגומנט הראשון שלו, ובהתאם לתוצאת החישוב, מחשב את הארגומנט השני
או השלישי, אבל לא את שניהם גם יחד. בפרודצורת השיערוך שתוארה למעלה, יש לחשב את
כל הארגומנטים לפונקציה)או אופרטור(, טרם שמפעילים את הפונקציה עצמה.

גם בגלעין של ליספ יש לעיתים צורך בפונקציות מבלי לחשב לפני כן את הארגומנטים שלה.
נסתכל למשל על האטום \T|SET| שמשמעותו היא הוספת קישור בין אטום לבין ביטוי S
ל-\E|a-list|.
אם ננסה להזין למפרש של ליספ את הביטוי
\begin{quote}
  \T|(set foo (bar baz))|
\end{quote}
כבקשה לקשור את האטום \T|FOO| לרשימה
\T|(BAR BAZ)|
נתקל בשגיאות, שכן המפרש ינסה לשערך את שני הארגומנטים של הפונקציה \T|SET| טרם
שהוא יפעיל פונקציה זו. אלא ששיערוך זה יכשל, שכן לאף אחד מהאטומים המופיעים
בביטוי אין משמעות מלכתחילה.

בכדי להתגבר על מכשלה זו יש להשתמש באטום \T|QUOTE|
שמשמעותו היא פונקציה של ארגומנט אחד אשר \ע|אינה| משערכת את
הארגומנט שלה, אלא מחזירה אותו כמות שהוא.
כך למשל
\begin{LTR}
\begin{verbatim}
> (quote foo)
FOO
> (quote (bar baz))
(BAR BAZ)
\end{verbatim}
\end{LTR}
קשירת האטום \T|FOO| לרשימה
\T|(BAR BAZ)| צריכה להעשות באמצעות
\begin{LTR}
\begin{verbatim}
> (set (quote foo) (quote (bar baz)))
(BAR BAZ)
> a
(BAR BAZ)
\end{verbatim}
\end{LTR}

כ
ניסיון להזין את הרשימה

\begin{enumerate}
  ✦ אם האטום המשוערך הוא \T|NIL|, אז תוצאת השיערוך היא האטום \T|NIL|.
  ✦ אם האטום המשוערך הוא \T|T|, אז תותאצת השיערוך היא האטום \T|NIL|.
  ✦ אחרת, המנוע של ליספ מחפש את "
\end{enumerate}
כזה שיש לו CּARבשפת ליספ כל אטום הוא שם או סימבול,
ושיערוך של אטום
הוא ה.
המשמעות של אטום נקבעת על ידי חיפוש בטבלת סמלים. בשפת ליספ, רק אטומים הם שמות.

שפת LISP
ישור ושיערוך בשפת LISP
בשפת ליספ, שיערוך של רשימה מוגדר באופן רקורסיבי:
\begin{enumerate}
  ✦ שיערוך של כל אחד מהאיברים ברשימה.
  ✦ התייחסות לאיבר הראשון (\E|car|) ברשימה המשוערכת כאל פונקציה.
  ✦ התייחסות אל שארית (cdr) הרשימה המשוערכת כאל רשימת ארגומנטים (פרמטרים
  אקטואליים) לפונקציה
  ✦ קישור של הארגומנטים האקטואליים לפרמטרים הפורמליים
  ✦ חישוב הפונקציה
  ✦ הסרת הקישור שנעשה בשלב 4
  ✦ החזרה של תוצאת הפונקציה.
\end{enumerate}
הצעד הראשון בשבעת הצעדים של שיערוך רשימה הוא קריאה רקורסיבית, שבה משוערכים כל
אחד מאיברי הרשימה. בקריאה הרקורסיבית הזו תיתכנה ארבע אפשרויות:
\begin{enumerate}
  ✦
  קריאה רקורסיבית
  לשיערוך של nil מחזירה nil.
  ✦ קריאה רקורסיבית לשיערוך של רשימה, שתפעיל ברקורסיה את שבעת הצעדים של שיערוך רשימה.
  ✦ קריאה רקורסיבית לשיערוך של אטום, כמו foo, שתחפש את המשמעות של foo
\end{enumerate}

​6.7.4​ הגדרת פונקציה והפעלתה באמצעות ה-a-list
הגדרה של הפונקציה foo
(
defun
foo (x)
(
cons (cdr x) (car x)
)
)

תביא להוספת זוג לרשימת ה-a-list. זוג זה מייצג את הקישור בין השם foo ובין גוף
הפונקציה. וגוף הפונקציה גם הוא ביטוי בליספ, כלומר רשימה של דברים שכל אחד מהם או
אטום או רשימה. המבנה המדוייק של גוף הפונקציה הוא:
(
LAMBDA-CLOSURE () () ()
(X)
(CONS (CDR X) (CAR X))
)
ממרבית הפרטים של הייצוג אפשר להתעלם. הפרטים החשובים הם:
רשימת הפרמטרים הפורמליים (שורה 3)
גוף הפונקציה (שורה 4)

אם נתרכז בגוף הפונקציה

(CONS (CDR X) (CAR X))
נזהה בו ארבעה אטומים:
CONS
CDR
x
CAR
שיערוך של גוף הפונקציה, מצריך שיערוך של ארבת האטומים. לכן, בעת הפעלת הפונקציה
יש לחפש אותם במחסנית ה-a-list לפי ערכה בזמן הקריאה לפונקציה. כדי לממש את העברת
הפרמטרים, מנגנון השיערוך של פונקציה מוסיף זוגות כמספר הפרמטרים של הפונקציה. (אם
בזמן הפעלת הפונקציה מספר הארגומנטים אינו מתאים למספר הפרמטרים הפורמליים, מנגנון
השיערוך מודיע על שגיאה, ועוצר.) בהפעלה של הפונקציה,
\begin{english}
  (foo '((a b) (c d)))
\end{english}
יש לקשור את הארגומנט ((a b) (c d)) אל הפרמטר הפורמלי \E|x|. קישור זה נעשה על
ידי הוספת הזוג שחלק השם שלו הוא x וחלק המשמעות שלו הוא ((a b) (c d)) לתחילת
רשימת
ה-a-list. אחרי הוספה זו, ניתן לבצע את גוף הפונקציה. בכל פעם שגוף הפונקציה יפנה
לשערך את x הוא ימצא ערך זה. בכל פעם שגוף הפונקציה יפנה לשערך את השמות \E|CONS|,
CDR ו-\E|CAR|, הוא ימצא ברשימת ה-a-list את משמעותן של שלוש פונקציות אלו. לאחר
ביצוע
הפונקציה, יש להסיר את הזוג הזה שהוספנו, ובאופן כללי, את כל הזוגות היוצרים קשר
בין שם הפרמטר הפורמלי, ובין ערכו האקטואלי. ראינו אם כן שהפעולה של שיערוך שם
(אטום), היא חיפוש במחסנית ה-\E|a-list|. לאחר מציאת המשמעות, אם האטום הוא האיבר
הראשון ברשימה, יש להתייחס אליו כפונקציה, שגורמת להוספת זוגות, כגודל שארית
הרשימה, למחסנית זו, ואחר כך, ביצוע הגוף בסביבה החדשה שנוצרה.

Lisp evaluator code Here is a test case you can use to demonstrate your
improved evaluator. It does not use def.

\begin{english}
  (eval '(((lambda (x) (function (lambda (y) (cons x y)))) 3) 4) nil)
\end{english}

You need to fix a minor bug in the evaluator so that the following yields (1 .
2): (eval '(((lambda (x) (lambda (y) (cons 1 2))) 3) 4) nil) ; (1 . 2)

Bill Dieter typed in the code for eval from the book, but had to make some
changes to make it work. Here is what he ended up with. He renamed eval and
apply to eval and apply so they will not conflict with the
builtin eval and apply. Note that the common lisp error function takes a
string as a parameter rather than a symbol. He also added cases in eval for
numbers, strings, and t. Without these cases, you cannot use numbers, strings,
or t.

\begin{LISP}
  (defun eval (expression a-list) ; evaluate expression in a-list
  (cond
  ((null expression) nil)
  ((numberp expression) expression) ; Dieter added this
  ((stringp expression) expression) ; Dieter added this
  ((eq t expression) expression) ; Dieter added this
  ((atom expression) (lookup expression a-list))
  ((eq (car expression) 'quote) (car (cdr expression)))
  ((eq (car expression) 'cond) (evalcond (cdr expression) a-list))
  (t (apply (car expression) (evallist (cdr expression) a-list) a-list))))
\end{LISP}
\begin{LISP}
(defun apply (function parms a-list) ; apply function to parms
  (cond
    ((atom function) (cond
  ((eq function 'car) (car (car parms)))
  ((eq function 'cdr) (cdr (car parms)))
  ((eq function 'cons) (cons (car parms) (car (cdr parms))))
  ((eq function 'get) (get (car parms) (car (cdr parms))))
  ((eq function 'atom) (atom (car parms)))
  ((eq function 'error) (error (string parms)))
  ((eq function 'eq) (eq (car parms) (car (cdr parms))))
  (t (cond
  ((get function 'EXPR)
  (apply (get function 'EXPR) parms a-list) parms a-list)
  (t (apply (lookup function a-list) parms a-list))))))
  ((eq (car function) 'lambda)
  (eval (car (cdr (cdr function)))
  (update (car (cdr function)) parms a-list)))
  (t (apply (eval function a-list) parms a-list))))
\end{LISP}
\begin{LISP}
  (defun evalcond (conds a-list) ;evaluate cond
  (cond
  ((null conds) nil)
  ((eval (car (car conds)) a-list)
  (eval (car (cdr (car conds))) a-list))
  (t (evalcond (cdr conds) a-list))))
\end{LISP}

\begin{LISP}
  (defun evallist (list a-list) ;evaluate list
  (cond
    ((null list) nil)
    (t (cons (eval (car list) a-list)
    (evallist (cdr list) a-list)))))
\end{LISP}

\begin{LISP}
  (defun lookup (id a-list) ; lookup id
  (cond
  ((null a-list) (error "Unbound variable:~S" id))
  ((eq id (car (car a-list))) (car (cdr (car a-list))))
  (t (lookup id (cdr a-list)))))
\end{LISP}

\begin{LISP}
; bind formal parameters to actual arguments
(defun update (formals values a-list) 
  (cond 
    ((null formals) ; no more formal arguments
      (cond
        ((null values) a-list)
        (t (error "bad argument count"))
      )
    )
    ((null values) ; more formal parameters than values 
      (error "bad argument count")
    )
    (t 
      (cons (cons (car formals)
        (cons (car values) nil))
        (update (cdr formals) (cdr values) a-list))
    )
  )
)
\end{LISP}

במונחים שלנו, כל זוג כזה הוא קישור של שם לישות. במקרה זה, הישות אותה
ניתן לשיים היא עץ בצורה של S-Expression. המחסנית היא מבנה
נתונים המתאר במדויק את ה-a-listironment בכל רגע בביצוע התכנית. קריאה לפונקציה
תוסיף הגדרות (המאורגנות בזוגות) לתחילת ה-a-list. סיום הביצוע של פונקציה, וחזרה
לפונקציה הקוראת תסיר הגדרות אלו.

החיפוש אחרי משמעות של
אטום ב-\E|a-list| נעשה על ידי סריקת הרשימה עד אשר נמצא בה ביטוי-S שה-CAR שלו
זהה לאטום המבוקש. המשמעות של האטום היא ה-CDR של ביטוי זה.

\begin{english}
  \begin{quote}
    \T|(
    (CAAR.(LAMBDA (X) (CAR (CAR X)) ⏎
    (T.T) ⏎
    (NIL.NIL)
)|
  \end{quote}
\end{english}
