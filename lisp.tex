\documentclass[a4paper,12pt,reqno]{article}
\usepackage{00}
\title{הגלעין של ליספ}
\author{יוסי גיל ⏎ הפקולטה למדעי המחשב⏎ הטכניון - מכון טכנולוגי לישראל}
\begin{document}
\maketitle

§ מבוא

שפת LISP (ראשי תיבות של \E|LIst PRocessing|), היתה, יחד עם שפת Fortran (ראשי
תיבות של \E|FORmula TRANslation|), אחת משתי שפות התכנות הראשונות. ליספ פותחה
ב-MIT על ידי \E|John McCarthy| עוד בשנת 1956. מלכתחילה, ליספ לא נתפסה על ידי
ממציאה כשפת תכנות, אלא כתחשיב מתימטי המיועד לכתיבת אלגוריתמים, הדומה לתחשיב
ה-$λ$ \E|(lambda calculus)|. רק לאחר מכן, מומש התחשיב כשפת תכנות.

בתחשיב של \E|McCarthy|, כל תכנית היא מה שנקרא "\ע|ביטוי~S|", והרצת התכנית קרויה
"שיערוך" (\E|evaluation|) של הביטוי. יתירה מכך, כל הנתונים בשפת ליספ גם הם
ביטויי~\E|S|.

בנוסף לתחשיב McCarthy הציג גם אלגוריתם אוניברסלי, \E|eval|, המסוגל להריץ תכניות
בליספ. ליספ הפכה לשפת תכנות כאשר האלגוריתם הזה מומש בשפת מכונה. ממאוחר יותר,
נמצא מי שכתב מימוש של \E|eval| בשפת ליספ עצמה. מאז, זכתה ליספ לגלגולים רבים:
התחשיב המקורי הפך לשפת תכנות של ממש, וזכה להרחבות רבות. פותחו ניבים רבים לשפה,
והיא מצוייה בשימוש נרחב. הדיון כאן איננו עוסק בליספ כשפת תכנות, וגם לא באף אחד
מהניבים שלה, אלא מתרכז אך ורק בהצגת הגלעין (\E|core|) של השפה. הגלעין שיוצג הוא
מינימלי ביותר, והוא כולל הגדרה של פחות מתריסר פונקציות פרימיטיביות בלבד, כלומר
פונקציות שלא ניתן להגדירן באמצעות פונקציות אחרות:

\ציינן
✦ \ע|פונקציות מבניות|: \E|car|, \E|cdr| ו-\E|cons|, אשר מאפשרות ליצור ביטוי
\E|S|, ולפרק אותו לחלקיו.

✦ \ע|פונקציות לוגיות|: \E|atom|, \E|eq| ו-\E|cond|, המאפשרות לבדוק את תכנו של
ביטוי~\E|S|.

✦ \ע|פונקציות נוספות|: \E|set|, \E|eval| ו-\E|error| המסייעות בכתיבת
תכניות בשפת ליספ.
===

\פנה|טבלה:גלעין| שבהמשך מסכמת את רשימת הפונקציות הפרימטיביות שבגלעין של ליספ.
בנוסף, מכיל הגלעין מספר קטן של פונקציות "סיפריה", כלומר פונקציות אותן ניתן
להגדיר באמצעות הפונקציות הפריטיביות.

\ציינן
✦ \ע|קבועים| (פונקציות ללא פרמטרים): \E|t|)המציין את ערך האמת(ו-\E|nil|)המציין
את ערך השקר(.
✦ \ע|פונקציה לוגית|: \E|null| (פונקציה חד-מקומיות הבודקת אם אטום הוא \E|nil|).
✦ \ע| פונקציות המסייעות בהגדרת פונקציות|:
\E|quote|, \E|defun|, \E|ndefun|, \E|lambda| ו-\E|nlambda|.
===
\פנה|טבלה:סיפריה| שבהמשך מסכמת את רשימת פונקציות הסיפריה שבגלעין, ומביאה גם
את מימושן באמצעות פונקציות הפרימיטיביות.

הגלעין של ליספ, בניגוד לכמעט כל הדיאלקטים שלה, אינו תומך במספרים ובפעולות
אריתמטיות. רוב הדיאלקטים של ליספ, יודעים להדר, באופן חלקי או מלא, תכניות ליספ
לשפת מכונה. גם הידור כזה אינו נחוץ בגלעין של השפה. על אף המינימליות של הגלעין,
הוא טיורינג שלם: כל תכנית שאפשר לכתוב בכל שפת תכנות, אפשר לכתוב גם בגלעין של
ליספ. בפרט, כפי שנדגים כאן, ניתן לממש את הפונקציה \E|eval| עצמה בגלעין.

אוסף הפונקציות שבגלעין שנתאר כאן, נמנע מלתמוך בשום תכונה של ליספ שאינן נחוצה
כדי לממש את הפונקציה \E|eval|.

הגלעין של ליספ מעניין שכן הוא מציג בצורה פשוטה וקלה רעיונות יסודיים, כגון עיבוד
רקורסיבי של רשימות, קישור של שמות לערכים, העברת פרמטרים, הסתכלות על תכנית כמבנה
נתונים, ועוד.

לא רק תכניות הם ביטויי~\E|S|. כל הערכים בשפת ליספ הם ביטויי~S
\E|(S-Expressions)|. המונח~S-Expression בא לעולם כקיצור למונח \E|symbolic
expression| (ביטוי סימבולי). המילה "סימבולי" מטעימה שמדובר שאין מדובר בהכרח
בביטוי מתימטי כגון~$13+41/2$, שבו המשמעות של כל הסימנים ידועה בדרך כלל, אלא
בביטוי כללי שיכול להכיל סימבולים שמשמעותם דורשת הגדרה מפורשת, כגון
\begin{equation*}
  (\amalg \circledcirc \maltese) ⊘ (\Re \wr \Game)
\end{equation*}
בביטוי זה, ניתן לזהות את האופרנדים ($\amalg$,~$\maltese$,~$\Re$ ו-$\Game$) ואת
האופרטורים ($\circledcirc$,~$⊘$ ו-$\wr$). ניתן גם לשרטט עץ המתאר את מבנה הביטוי
\begin{quote}
  \begin{forest}
    s tree [$⊘$,[$\circledcirc$ [$\amalg$] [$\maltese$]] [$\wr$[$\RE$][$\Game$]]]
  \end{forest}
\end{quote}
אולם כיוון שמשמעות האופרנדים והאופרטורים אינה ידועה, לא נוכל לחשב את הביטוי.
המונח שיערוך כולל בתוכו שני מרכיבים: ראשית, מתן משמעות לסימנים המופיעים בביטוי,
ושנית, חישוב הביטוי בהתאם למשמעות זו.

בשפת תכנות כדוגמת~\CPL העוברות הידור \E|(compilation)| שני מרכיבי השיערוך
נפרדים. מתן המשמעות לסימבולים נעשה על ידי המהדר \E|(compiler)|. החישוב עצמו
נעשה בזמן ריצת התכנית. בליספ, כמו בשפות אחרות שבהן יש פירוש
\E|(interpretation)| של תכניות, שני השלבים של השיערוך נעשים על ידי האינטרפטר
\E|(interpreter)| אשר קורא תכניות ומשערך אותן.

האינטרפטר של ליספ, כמו האינטרפטר של פרולוג, \E|bash| ושפות תכנות אחרות
העוברות אינטרפטציה, עובד במחזורים, בשיטה הידועה בשם \E|REPL|, שהם ראשי תיבות של
\begin{description}
  ✦ [READ] האינטרפטר קורא ביטוי~\E|S|.
  ✦ [EVALUATE] האינטרפטר משערך את ערכו של הביטוי שקרא.
  ✦ [PRINT] אם השיערוך של הקלט מצליח, אז האינטרפטר מדפיס את תוצאת השיערוך.
  אחרת, האינטרפטר ידפיס הודעת שגיאה מתאימה.
  ✦ [LOOP] האינטרפטר חוזר לצעד הראשון, לקריאת הביטוי הבא
\end{description}

תכנית בשפת ליספ היא פונקציה שיכולה לקבל כארגומנטים ביטויי~S והיא מחזירה
ביטוי~\E|S|. כאמור, כל פונקציה כזו, היא בעצמה ביטוי~\E|S|.

§ ביטויי~S כשפה פורמלית

\newcommand\SX{\ensuremath{S_{\text{exp}}}}

בהינתן אלפבית~$Σ$, נגדיר את~$\SX(Σ)$, קבוצת "ביטויי ה-S", מעל~$Σ$.
אינטואיטיבית, ביטוי~S יכול להיות אטומי, ואז הוא חייב להיות מילה מתוך~$Σ^*$.
ביטוי~S שאינו אטומי הוא בהכרח זוג סדור של שני ביטויי~S אחרים. הזוג הסדור נכתב
עטוף בזוג סוגריים ושני הביטויים הסימבוליים שבו מופרדים בסימן הנקודה.

כמה ביטויי~S מעל האלפבית~$Σ=❴a,b,c❵$ הם \[
  a,b,(a.b),(c.(b.a)),((a.b).(a.c))∈\SX❨❴a,b,c❵❩.
\] לעומת זאת,~$(a.b.c)$ אינו
שייך ל~$\SX(Σ)$ משום שהוא שלשה סדורה ולא זוג סדור, ואילו~$(a(b(c)))$ אינו
שייך לקבוצה, משום שהוא אינו עונה על הדרישה שבין פריטים ימצא סימן הנקודה.

הקבוצה~$\SX(Σ)$ היא שפה פורמלית מעל אלפבית מורחב, המתקבל מהוספת סימן הנקודה ואת
שני סימני הסוגריים לאלפבית~$Σ$ (אנו מניחים, בלי הגבלת הכלליות, ששלושת הסימנים
הללו אינם מצוים ב-$Σ$.)

ניתן לאפיין את השפה~$\SX(Σ)$ באמצעות כללי היסק:
\begin{definition}[ביטויי~S מעל
    אלפבית] בהנתן אלפבית~$Σ$ אזי,~$\SX(Σ)$, קבוצת ביטויי ה-S מעל~$Σ$ מוגדרת
  באמצעות הבנאי הנולארי (כלומר איברים אטומיים):
  \begin{equation*}
    \infer{w∈\SX(Σ)}{w∈Σ^*}
  \end{equation*} והבנאי הבינארי:
  \begin{equation*}
    \infer{(τ₁.τ₂⟩∈\SX(Σ)}{τ₁∈\SX(Σ) &τ₂∈\SX(Σ)}
  \end{equation*}
\end{definition}

ניתן להגדיר את~$\SX(Σ)$ גם באמצעות דקדוק חסר הקשר
\begin{equation}
  \begin{split}
    S &→(S.S)⏎ S &→A ⏎
    A &→ε⏎ A &→Aσ₁ ⏎
    A &→Aσ₂ ⏎
    ⋮ ⏎
    A &→Aσₙ ⏎
  \end{split}
\end{equation} כאשר~$Σ=❴σ₁,σ₂,…,σₙ❵$.

נוח לחשוב על ביטויי~S כעצים בינאריים מלאים (כלומר, שלכל צומת שאינה עלה יש בדיוק
שני בנים) כאשר צומת פנימית של עץ כזה אינו נושא מידע, ואילו עלה מכיל מילה
מתוך~$Σ^*$. הנה כמה ביטויי S והתיאור שלהם כעץ בינארי מלא.

\begin{LTR}
  \begin{tabular}{cccccc}~$(ab.cd)$ &
    $(abcd.ε)$ &
    $(ab.(c.d))$ &
    $((a.b).(c.d))$ &
    $(a.(b.(c.d)))$ &
    $(((a.b).c).d)$ ⏎
    \scriptsize
    \Forest{s tree [{},cons[$ab$,atom][$cd$,atom]]} &
    \scriptsize
    \Forest{s tree [{},cons[$abcd$,atom][$ε$,atom]]} &
    \scriptsize
    \Forest{s tree [{},cons[$ab$,atom][{},cons[$c$,atom][$d$,atom]]]} &
    \scriptsize
    \Forest{s tree [{},cons[{},cons[$a$,atom][$b$,atom]][{},cons[$c$,atom][$d$,atom]]]} &
    \scriptsize
    \Forest{s tree [{},cons [{},cons [{},cons[a,atom][b,atom]] [c,atom]] [d,atom] ] } &
    \scriptsize
    \Forest{s tree [{},cons [{}, cons [{}, cons
          [a,atom][b,atom]] [c,atom] ] [d,atom]] }
  \end{tabular}
\end{LTR}

§ ביטויי S בשפת ליספ וכתיב הרשימות

שפת ליספ מרחיבה מעט את ההגדרה של ביטויי-S כפי שהצגנו אותה למעלה, אבל, בסופו של
דבר, ביטויי S בליספ היא הקבוצה~$\SX$ מעל אלפבית הכולל בתוכו את האותיות
\texttt{A} עד \texttt{Z}, ספרות, וגם מרבית הסימנים המיוחדים, כולל \texttt{-},
\texttt{+} ועוד.

לביטוי S מורכב קוראים בשפת ליספ \E|dotted-pair|. לאיבר הראשון ב-dotted-pair
קוראים \E|car|, ולאיבר השני ב-dotted-pair קוראים \E|cdr|. לזוג כולו קוראים
לעיתים גם "רשומת \E|cons|".

לביטוי S אטומי בשפת ליספ קוראים אטום \E|(atom)|. דוגמאות לאטומים הן \E|A|,
\E|12B|, \E|ZZZ| ו-\E|+|. מסיבות היסטוריות, האלפבית של אטומים בליספ אינו מכיל
אותיות קטנות. מערכות ליספ מתרגמת את האותיות הקטנות לאותיות גדולות כשהן מופיעות
בתוך אטומים.

סדרת התווים המגדירה אטום יכולה להיות גם~$ε$, הסידרה הריקה. השם \E|nil| מציין את
האטום שסדרת התווים שלו היא~$ε$. כפי שנראה בהמשך, גם הכתיב \E|()| מציין את האטום
הזה. סדרת התווים המגדירה אטום היא חסרת משמעות בדרך כלל, אולם המתכנת בליספ יכול
להעניק לאטומים נבחרים משמעות. בנוסף, יש מספר אטומים שהמשמעות שלהם מוגדרת מראש
בשפה.

\ע|רשימה| \E|(list)| בליספ היא סדרה של פריטים העטופה
בסוגריים. כל פריט ברשימה יכול להיות ביטוי~\E|S|, או רשימה בעצמו.

כך, \E|(a b c d)| היא הרשימה המכילה ארבעה פריטים: האטומים \E|a|, \E|b|, \E|c|
ו-\E|d|. הרשימה הריקה, זו שאינה מכילה אף פריט, נכתבת כ-\E|()|, ואילו
\E|((a.c)c)| היא רשימה המכילה שני פריטים, שהראשון בהם הוא ביטויי~S מורכב,
\E|(a.c)|, והשני הוא האטום \E|c|.

כל רשימה היא כתיב מקוצר לביטוי~\E|S|. הכתיב מוגדר באינדוקציה על אורך הרשימה:
הרשימה הריקה \E|()| היא כתיב אחר לאטום \E|nil|. רשימה שאינה ריקה, היא כתיב
מקוצר לביטוי~S מורכב, כלומר זוג של ביטויי~\E|S|. האיבר הראשון בזוג הוא האיבר
הראשון ברשימה. האיבר השני בזוג, הוא הייצוג של שארית הרשימה.

לפיכך, הרשימה \E|(a b c d)| היא כתיב אחר לביטוי~S
\begin{LISP}
(a.(b.(c.(d.nil))))
\end{LISP}

הפריטים ברשימה הם ביטויי~\E|S|, אבל כיוון שרשימה גם היא ביטוי~\E|S|, רשימה
יכולה להכיל בתוכה רשימות. למשל,
\begin{LISP}
  ((a b) c)
\end{LISP}
היא רשימה המכילה בתוכה שני פריטים, הראשון שבהם הוא רשימה בת שני אטומים, והשני
שבהם הוא אטום. רשימה זו ניתנת לתיאור באמצעות ביטוי~\E|S|,
\begin{LISP}
  ((a.(b.nil)).(c.nil))
\end{LISP}
\פנה|איור:רשימות| מציג רשימות אלו כעצים בינאריים מלאים.

\begin{figure}[H]
  \caption{יצוג רשימות כעצים בינאריים}
  \label{איור:רשימות}
  \begin{LTR}
    \begin{tabular}{cccc}
      \lisp{()} &
      \T|(A)| &
      \T|(A B C D)| &
      \T|((A B) C)|
 ⏎
      \begin{forest}
        s tree [NIL,atom]
      \end{forest} &
      \begin{forest}
        s tree [{},cons [A,atom]]
      \end{forest} &
      \begin{forest}
        s tree [{},cons [A,atom]
        [{},cons [B,atom]
        [{},cons [C,atom]
        [{},cons [D,atom]
        [$ε$,atom]
        ]
        ]
        ]
        ]
      \end{forest} &
      \begin{forest}
        s tree [{},cons
        [{},cons
        [B,atom]
        [{},cons[C,atom] [$ε$,atom] ]
        ]
        [{},cons
        [C,atom]
        [$ε$,atom]
        ]
        ]
      \end{forest}
    \end{tabular}
  \end{LTR}
\end{figure}

לא כל ביטוי~S ניתן להיכתב בכתיב הרשימות. למשל הביטוי \E|(a.b)| אינו ניתן להכתב
כרשימה. אבל כל רשימה ניתנת להיכתב כביטוי~\E|S|. נהוג לכתוב ביטויי~S בכתיב
הרשימות בכל אימת שניתן לעשות זאת.

§ פעולות על ביטויי~S

הגלעין של ליספ תומך בפעולות מבניות אלמנטריות על ביטויי~\E|S|. המשמעות של שלושת
האטומים \T|cons|, \T|car|, ו-\T|cdr| מוגדרת מראש לציין פעולות מבניות אלו:

\begin{enumerate}
  ✦ האטום \T|cons| מציין פונקציה המקבלת שני ביטויי~\E|S|, ומחזירה ביטוי~S
  שהוא זוג בו האיבר הראשון הוא הארגומנט הראשון לפונקציה, ואילו האיבר השני של
  הזוג הוא הארגומנט השני לפונקציה.

  נשים לב לכך שאם הארגומנט השני לפונקציה זו הוא רשימה, אז הפונקציה מחזירה
  רשימה חדשה שבה הפריט הראשון הוא הארגומנט הראשון לפונקציה ושאר
  הפריטים הם כמו אלו שהיו ברשימה שהיא הארגומנט הראשון.

  ✦ האטום \T|car| מציין פונקציה המקבלת כארגומנט ביטוי~S אחד. אם ביטוי זה הוא
  ביטוי מורכב, הפונקציה מחזירה ביטוי~S שהוא האיבר הראשון בזוג ממנו הארגומנט
  בנוי.

  לעומת זאת, אם הארגומנט לפונקציה הוא אטום, הפונקציה נכשלת. כשלון זה דומה
  לכשלון של ניסיון לחלוקה באפס. ממש כשם שלא כל הפעולות האריתמטיות מוגדרות על כל
  המספרים, לא כל הפונקציות המבניות מוגדרות על כל ביטויי~ה-\E|S|.

  אם הארגומנט לפונקציה הוא רשימה שאיננה ריקה, אז הפונקציה מחזירה את הפריט
  הראשון ברשימה. כאמור, אם הארגומנט ל-\E|CAR| הוא אטום, ואפילו יהא זה
  האטום \lisp{nil}, כלומר הרשימה הריקה, הפונקציה נכשלת.

  ✦ האטום \T|cdr| מציין פונקציה המקבלת כארגומנט ביטוי~S אחד. אם ביטוי זה הוא
  ביטוי מורכב, הפונקציה מחזירה ביטוי~S שהוא האיבר השני בזוג ממנו הארגומנט בנוי.
  אם הארגומנט לפונקציה הוא אטום, הפונקציה נכשלת.

  אם הארגומנט לפונקציה הוא רשימה שאינה ריקה, אז הפונקציה מחזירה את
  שארית הרשימה, כלומר, הרשימה בלעדי האיבר הראשון שבה.
\end{enumerate}

הגלעין של ליספ תומך גם בפונקציות לוגיות המאפשרות לבדוק את תוכנו של
ביטויי~\E|S|. המשמעות של שלושת האטומים \T|atom|, \T|null|, ו-\T|eq| מוגדרת
מראש לפונקציות המאפשרות בדיקות כאלו:

\begin{enumerate}
  ✦ האטום \T|atom| מציין פונקציה המקבלת ביטוי~S אחד ומחזירה את האטום \T|t| אם
  ארגומנט זה הוא אטום, ואחרת את האטום \T|nil|.

  ✦ האטום \T|null| מציין את הפונקציה המקבלת ביטויי~S אחד ומחזירה את האטום
  \T|t|. אם ארגומנט זה הוא האטום \T|nil| ואחרת את האטום \T|t| אם הארגומנט
  לפונקציה הוא רשימה, אז הפונקציה מחזירה \T|t| אם ורק אם הרשימה ריקה, ו-\T|nil|
  בכל מקרה אחר.

  ✦ האטום \T|eq| מציין את הפונקציה המקבלת שני ביטויי~S ומחזירה את האטום \T|t|
  אם שני הארגומנטים לפונקציה הם אטומים, ושני האטומים הללו שווים. בכל מקרה אחר,
  הפונקציה מחזירה את האטום \T|nil|.
\end{enumerate}

ניתן לחשוב על האטום \T|nil| כמסמן את הערך של שלילה לוגית, כלומר \E|false|, ועל
האטום \T|t| כמסמן את ערך האמת, \E|true|.

§ ביטויי S כעצים מעל אלאפבית

ראינו שביטויי S ניתנים להצגה כעץ בינארי שבו העלים, והעלים בלבד, מכילים
סימבולים. אם ביטוי S ניתן להכתב כרשימה של רשימות, אז ניתן להציג את הביטוי הזה
כ\ע|עץ|, שבו קיים סימבול בכל צומת פנימית ובכל עלה. ומספר הבנים של כל צומת
פנימית יכול להיות כלשהו.

בהנתן אלפבית~$Σ$, נגדיר את~$T(Σ)$, קבוצת העצים שבכל צומת שלהם ישנו איבר של~$Σ$.
עץ כזה יכול להיות עץ אטומי, ואז העץ מצטמצם לכדי עלה בודד, שחייב להכיל איבר
של~$Σ^*$. עץ ב-$T(Σ)$ יכול להיות גם עץ מורכב, ובמקרה זה הוא מורכב מצומת פנימי
שבו יש אות של~$Σ$ ומספר כלשהו של בנים שכולם עצים ב-\E|$T(S)$|. בניסוח זה, אנו
רואים שעץ אטומי הוא עץ מורכב שיש לו אפס בנים.

נוכל להגדיר את הקבוצה~$T(Σ)$ כשפה פורמלית מעל אלפבית מורחב, הכולל גם את זוג
סימני הסוגריים ואת סימן הפסיק בא בהנתן אלפבית~$Σ$ אזי,~$T(Σ)$,
\begin{definition}[עצים מעל אלפבית]
  בהנתן אלפבית~$Σ$ אזי,~\E|$T(Σ)$|, קבוצת העצים מעל~$Σ$ מוגדרת באמצעות הבנאי
  ה-$n$ מקומי
  \begin{equation*}
    \infer{w(t₁,…,tₙ)∈\SX(Σ)}{w∈Σ^* & n≥0 & t₁∈T(Σ) & t₂∈T(Σ)&⋯& tₙ∈T(Σ)}
  \end{equation*}
\end{definition}

כמה איברים פשוטים של קבוצת העצים מעל האלפבית בן שלוש האותיות~$Σ=❴a,b,c❵$ הם \[
  a,b,c,a(b,c), a(b(a)), a(a,b,c)∈T(❴a,b,c❵)
\] \cref{figure:tree} מדגים את הטופולגיה של העץ המורכב יותר
$a(a(a,ab,abc),b(b,ab(c)),c(c(a(ab)))∈T(❴a,b,c❵))$
\begin{figure}[H]
  \centering
  \forestset{%
    x tree/.style={%
        for tree={%
            math content,
            s sep'+=-3pt,
            fit=band,
          },
      },
  }
  \begin{forest}
    s tree [a
          [a,[a][ab][abc]]
          [b,[b][ab[c]]]
          [c,[c[a[ab]]]]
      ]
  \end{forest}
  \כיתוב|העץ~$a(a(a,ab,abc),b(b,ab(c)),c(c(a(ab))))$.|
  \label{figure:tree}
\end{figure}

אם ביטוי S הוא רשימה של רשימות, אזי ניתן להציגו כעץ. התרגום מתבצע על ידי הפיכת
כל רשימה בביטוי לתת-עץ: האיבר הראשון ברשימה הוא שורש תת-העץ. שאר האיברים
ברשימה, הם הבנים של תת העץ. לדוגמה, בעבור הרשימה
\begin{LISP}
  (a b (car x) (+b x))
\end{LISP}
יבנה כך העץ
\begin{LTR}
  \scriptsize
  \forestset{%
    x tree/.style={%
        font=\ttfamily,
        for tree={%
            s sep'+=-3pt,
            fit=band,
          },
      },
  }
  \begin{forest}
    x tree [a,
        [a,[car,[x]]]
          [+, [b] [x]]
      ]
  \end{forest}
\end{LTR}

נשים לב לכך שהפונקציה \E|car|, כשהיא מופעלת על עץ מעל אלאפבית מחזירה את תוכנו
של הצומת שבשורש העץ, ואילו הפונקציה \E|cdr| מחזירה את רשימת הבנים של הצומת, שכל
אחד מהם הוא עץ כזה בעצמו.

§ עצי שיערוך

ניתן להסתכל על עץ מעל אלאפבית, שבו יש סימבול בכל צומת, ושבו הדרגה אינה מוגבלת,
כעץ "שיערוך". נסתכל למשל על הביטוי הבא בשפת~\CPL
\begin{CPP}
  f(2) ? g(++a,--b,-sin(c)) : 10+h()
\end{CPP}
חישוב ביטוי כגון זה, דורש ראשית הבנה של המונחים שבו. חישוב הכולל הבנת מונחים
פיענוח משמעות הסימבולים אנו קוראים שיערוך \E|(evaluation)|.
נתאר את השיערוך של הביטוי הזה על ידי הצגתו כעץ השיערוך המתואר ב\פנה|איור:עץ|.

\begin{figure}[H]
  \caption{%
    עץ החישוב של הביטוי \protect\T|f(2) ? g(++a,--b,-sin(c)) : 10+h()|.
  }
  \תגית|איור:עץ|
  \begin{english}
    \scriptsize
    \forestset{%
      x tree/.style={%
          for tree={%
              font=\ttfamily\scriptsize,
              s sep'+=-3pt,
              l sep'+=-3pt,
              fit=band,
            },
        },
    }
    \begin{forest}
      x tree [\E|?:|,
      [$f()$ [$2$]]
      [$g()$
      [\T|++|[$a$]]
      [\T|--|[$b$]]
      [$-$ [$\sin()$ [$c$]]]
      ]
      [$+$[$10$][$h()$]]
      ]
    \end{forest}
  \end{english}
\end{figure}

שיערוך ביטוי ניתן לתיאור רקורסיבי באמצעות העץ שמתאר אותו.
בסיס הרקורסיה הוא שיערוך של עלה, הנעשה באמצעות פיענוח משמעותו.
בעץ שבאיור יש שישה עלים:
\begin{itemize}
  ✦ משמעות העלים המסומנים ב-$2$ וב-$10$ היא המספרים~$2$ ו-$10$, שכן בשפת~\CPL
  סדרות התווים \T|2| ו-\T|10| הן ליטרלים, כלומר סדרות אלו מציינות ערך הנקבע
  באופן יחיד על ידי תוכן הסדרה, ללא תלות בטבלת סימבולים כלשהי.
  ✦ משמעות העלים המסומנים ב-$a$, \E|$b$| וב-$c$ נעשית על ידי חיפוש השמות הללו
  בטבלת הסמלים, שכן בשפת~\CPL סדרות התווים \T|a|, \T|b| ו-\T|c| הם מזהים. מזהים
  אלו מתייחסים, ככל הנראה, למשתנים אשר הוגדרו קודם.
  ✦ משמעות העלה המסומן ב-$h()$ גם היא נעשית באמצעות חיפוש השם~$h$
  בטבלת הסמלים, אלא שנדרש שהחיפוש בטבלה יקשור את השם לפונקציה.
  אם על פי החיפוש, משמעות השם~$h$ היא משתנה, אזי השיערוך של הביטוי יכשל.
\end{itemize}

שיערוך של צומת פנימית, מתחיל באופן דומה. ראשית יש לברר את משמעות הסימבול אשר
נמצא בתוך הצומת. בדוגמה שלנו, הסימבולים \T|+|, \T|-|, \T|++|, \T|--| ו-\T|?:|
הם אופרטורים של שפת~\E|\CPL|. כלומר, המשמעות שלהם קבועה מראש בשפה, ולכן אין לחפש את
משמעותם בטבלת שמות. לעומת זאת, \T|f|, \T|g| ו-\T|sin| הם שמות שהוגדרו על ידי
מתכנת†{נזכר שהפונקציה~$\sin$ אינה בנויה בשפת~\E|\CPL|, אלא היא מוגדרת באחת
מהסיפריות.} לאחר פענוח משמעותה של צומת פנימית, יש לחשב את ערכי תתי העצים של
הצומת, ולהעביר את תוצאות החישוב של תתי העצים כארגומנטים לפונקציה.

ניתן להבין באופן מדוייק יותר את תהליך השיערוך באמצעות בדיקה של האופן שבו הוא
מתבצע בשפת ליספ.

§ שיערוך של אטומים

השיערוך של ביטויי-S מוגדר רקורסיבית. בסיס הרקורסיה הוא בשיערוך של אטומים.
שיערוך של אטום אינו נדרש לבצע חישוב, אלא רק מציאת משמעותו של האטום. אטום בליספ
הוא מזהה \E|(identifiier)|, וכמו בשפות תכנות אחרות, משמעותו של המזהה נמצאת
בטבלת סמלים \E|(symbol table)|. טבלת הסמלים היא מבנה נתונים הקושר בין שמות
ובין משמעותם, ומציאת המשמעות נעשית על ידי חיפוש בטבלה זו.

טבלת הסמלים בליספ מאורגנת במבנה נתונים הידוע בליספ בשם \E|association list| או
בקיצור \E|a-list|. ה-\E|a-list| היא רשימה של פריטים אשר כל אחד מהם מבטא קישור
של שם לערך. כל פריט הוא dotted-pair אשר ה-car שלו הוא שם
(המיוצג כאטום) ואילו ה-cdr של הפריט הוא משמעותו של השם (שהיא~\E|S-Expression|,
אטומי או מורכב. אם משמעותו של האטום foo היא העץ~$ϕ$ אז הפריט הנשמר ב-\E|a-list|
הוא~\E|$(\text{foo}.φ)$|. הקישור בין השם והביטוי הוא בדיוק בעובדה ששני אלו מחוברים
ברשומת \E|cons|.

רשימה ה-\E|a-list| מנוהלת כמחסנית, כלומר פריטים מתווספים ומוסרים ממנה רק
בתחילתה. החיפוש אחר משמעות ברשימה נעשה סדרתית, בסריקה המתחילה בתחילת הרשימה.
חיפוש המשמעות של האטום foo נעצר בזוג הראשון שבו מרכיב השם הוא \E|foo|. החיפוש
נכשל אם לא נמצא זוג כזה.

כאשר האינטרפטר של ליספ מתחיל את פעולתו, ה-\E|a-list| מכילה קישורים בעבור כמה
אטומים המוגדרים מראש בשפה. לשם פשטות נניח בשלב זה כי הרשימה מכילה קישורים בעבור
שני אטומים בלבד: \E|t| ו-\E|nil|.
התוכן המינימלי של ה-\E|a-list| הוא על כן
\begin{LISP}
(
  (t.t)
  (nil.nil)
)
\end{LISP}

הפריט הראשון ברשימה הוא dotted-pair הקובע שמשמעות של האטום \T|t| היא אטום זה
עצמו. הפריט השני ברשימה קובע שמשמעותו של האטום \T|nil| היא אטום זה עצמו גם כן.
לפיכך, כאשר האינטרפטר של ליספ יקרא את האטום \T|t| הוא ידפיס בתגובה \T|T|, וכאשר
הוא יקרא את האטום \T|nil| הוא ידפיס בתגובה \T|NIL|.

הפונקציה \T|set| שבגלעין היא פונקציה המקבלת שני פרמטרים, שהראשון בהם הוא
אטום, והשני הוא ביטוי S כלשהו. הפונקציה מוסיפה ל-\E|a-list| פריט שהוא
dotted-pair המבטא קישור בין האטום לביטוי.

אם נזין לאינטרפטר של ליספ את הביטוי
\begin{LISP}
> (set foo (bar baz))
\end{LISP}
כבקשה לקשור את האטום \T|foo| לרשימה
\T|(bar baz)|
נתקל בשגיאות, שכן האינטרפטר ינסה לשערך את שני הארגומנטים של הפונקציה \E|set|
טרם שהוא יפעיל פונקציה זו. אלא ששיערוך זה יכשל, שכן לאף אחד משלושת האטומים המופיעים
בקריאה ל-set אין משמעות מלכתחילה.

בכדי להתגבר על מכשלה זו יש להשתמש בפונקציה \T|quote|, פונקציה של
ארגומנט אחד אשר \ע|אינה| משערכת את הארגומנט שלה, אלא מחזירה אותו כמות שהוא.
כך למשל
\begin{LISP}
> (quote foo)
FOO
> (quote (bar baz))
(BAR BAZ)
\end{LISP}
קשירת האטום \T|foo| לרשימה \T|(bar baz)| יכול להעשות באמצעות
\begin{LISP}
> (set (quote foo) (quote (bar baz)))
(BAR BAZ)
> foo
(BAR BAZ)
\end{LISP}
אם התוכן של ה-\E|a-list| לפני הקריאה ל-set היה
\begin{LISP}
(
  (t.t)
  (nil.nil)
)
\end{LISP}
אזי אחרי הקריאה תוכן הרשימה יהיה
\begin{LISP}
(
  (foo.(bar baz))
  (t.t)
  (nil.nil)
)
\end{LISP}
הגלעין יכול לאתחל את ה-a-list באמצעות
\begin{LISP}
> (set (quote t) (quote t))
T
> (set (quote nil) (quote nil))
NIL
\end{LISP}
נשים לב לכך שהשערוך של הביטוי \T|(set (quote t) (quote t))| אינו מביא רק לחישוב
של ערך, אלא לקשירה של שם לערך. באופן כללי פעולת השיערוך בליספ כוללת שלושה סוגים
של פעולות: מציאת משמעות של שם, הגדרת משמעות של שם, וחישוב שהוא הפעלת פונקציה על
ביטוי S או ביטויי \E|S|.

לא ניתן להסיר פריטים מתוך ה-\E|a-list|. אבל, ניתן להסתיר קישור באמצעות הוספת
פריט לרשימה, אשר יסתיר את הקישור הקודם. אם נכתוב כעת
\begin{LISP}
> (set (quote foo) (quote (baz bar)))
(BAR BAZ)
\end{LISP}
הרי התוכן של ה-a-list יהיה אזי אחרי הקריאה תוכן הרשימה יהיה
\begin{LISP}
(
  (foo.(baz bar))
  (foo.(bar baz))
  (t.t)
  (nil.nil)
)
\end{LISP}
ואם ננסה לשערך כעת את \T|foo|, נקבל את הערך הנוצר מהקישור החדש
\begin{LISP}
> foo
(BAZ BAR)
\end{LISP}
כתיב מקוצר לביטוי \E|(quote~$X$(| המפעיל את הפונקציה quote על הביטויי~$X$,
הוא~\E|$'X$|, כלומר סימן מרכאה בודד לפני~$X$. הקריאה ל-\E|set| בשימוש בכתיב זה
היא קצרה יותר,
\begin{LISP}
> 'foo
FOO
> (quote 'foo)
'FOO
> '(quote foo)
'FOO
> '(bar baz)
(BAR BAZ)
> (set 'foo '(bar baz))
(BAR BAZ)
> foo
(BAR BAZ)
\end{LISP}

ניזכר שבביטויי~S כל אטום הוא סדרת סימנים נטולת משמעות. בעבור הגלעין של ליספ,
מספיק להניח כי גם האטום 42 הוא סדרה (בת שתי אותיות) שאין לה משמעות מיוחדת. בכל
זאת, במרבית המימושים של ליספ, מסיבות של יעילות בעיקר, האטום 42 מייצג ערך שהוא
מספר שלם, והמימוש תומך בפעולות אריתמטיות על מספרים שלמים. במרבית המימושים, ישנם
גם אטומים שהם מספרים ממשיים בייצוג של נקודה צפה, כמו גם תמיכה ישירה באריתמטיקה
המתאימה.

תמיכה בחישובים אריתמטיים נעשית על ידי שינוי שיטת השיערוך: אם האטום אותו יש
לשערך הוא סדרת ספרות הנחזית להיות מספר, אז השיערוך של האטום נעשה ללא היוועצות
בטבלת הסמלים. באופן דומה, פעולות אריתמטיות נעשות באמצעות הגדרה מראש של קישור
בין האטום \T|+| לפעולת החיבור של מספרים, בין \T|*| ובין פעולת הכפל, וכו'.

מסיבה זו, בכמעט כל הניבים של ליספ, ניתן לכתוב ביטויים אריתמטיים בכתיב
הרשימות, והשיערוך שלהם יביא לתוצאה הצפוייה,

\begin{LISP}
> (+⌘ ⌘2 (* 3 5))
17
\end{LISP}

הרחבות אלו אינן נחוצות לשם הבנה של ליספ, שכן ניתן לקודד בתוך ביטויי~S את
המספרים הטבעיים, את המספרים הממשיים (ולמעשה כל מבנה נתונים שניתן להעלות על
הדעת), וניתן באמצעות הגלעין של ליספ לממש את כל הפונקציות האריתמטיות. אבל, כיוון
שהגלעין של ליספ אינו מסוגל לבדוק את תוכנה של סדרת הסימנים היוצרת אטום
(הפעולה
היחידה המותרת על אטום בגלעין היא השוואתו לאטום אחר) הגלעין אינו יכול להפוך את
אטום כמו \T|43217| לליטרל אשר משמעותו היא המספר הטבעי \E|$43,217$|,
דהיינו, ארבעים ושלושה אלפים ומאתיים ושבע עשרה.

§ הגדרת פונקציות
מתכנת בליספ יכול להוסיף פריטים ל-\E|a-list| באמצעות הפונקציות \E|set|
ו-\E|defun|.

הפונקציה defun מאפשרת להגדיר פונקציות חדשות. נגדיר לדוגמה פונקציה בשם mirror
המקבלת פרמטר x שהוא ביטוי~\E|S| מורכב, ומחזירה ביטוי מורכב אחר שבו ה-car וה-cdr
שב-x הוחלפו.
\begin{LISP}
(defun
  mirror (x)
  (cons (cdr x) (car x))
)
\end{LISP}
אחרי הגדרה זו, נוכל להשתמש ב-mirror כך:
\begin{LISP}
> (mirror '(a.b))
(B.A)
\end{LISP}

מקובל לקרוא ל-\E|a-list| גם סביבה \E|(environment)|. הסביבה היא אוסף של קישורים
בין שמות למשמעותם, והיא זו שנותנת משמעות לשמות. ראינו כבר שהפונקציה \E|set|
מוסיפה קישור לסביבה. גם הפונקציה \E|defun| מוסיפה קישור לסביבה: שיערוך הביטוי
\T|(defun mirror (x) (cons (cdr x) (car x)))| מביאה לקשירה בין השם mirror ובין
מימוש הפונקציה. שיערוך הביטוי \T|(mirror '(a.b))| משתמש בשם זה, למציאת
מימוש הפונקציה.

המימוש של פונקציה כולל את ביטוי ה-S המהווה את גוף הפונקציה.
בדוגמה שלנו ביטוי זה הוא
\begin{LISP}
(cons (cdr x) (car x))
\end{LISP}
אבל, מלבד גוף הפונקציה כולל המימוש גם את רשימת השמות הפרמטרים הפורמליים אליה.
בפונקציה mirror יש פרמטר אחד אשר מיוצג ברשימה \T|(x)|.
שמות הפרמטרים הפורמליים קובעים כיצד יש לחשב את גוף הפונקציה: בכל מקום שבגוף
הפונקציה מופיע שם של פרמטר פורמלי, יש בזמן הקריאה לפונקציה וחישוב הגוף, להחליף
שם זה בערכו של הפרמטר האקטואלי.

הצירוף של גוף הפונקציה ושמות הפרמטרים אליה נקרא ביטוי-$λ$. ביטוי כזה
מייצג פונקציה אנונימית. ביטוי ה-$λ$ בעבור mirror הוא
\begin{LISP}
  (lambda (x) (cons (cdr x) (car x)))
\end{LISP}
באופן כללי ביטוי~$λ$ הוא רשימה בת שלושה פריטים בדיוק:
\ספרר
✦ האטום \T|lambda| המזהה את הרשימה כביטוי~$λ$.
✦ רשימה של אטומים, המייצגת את שמות הפרמטרים הפורמליים לפונקציה.
✦ גוף הפונקציה, כלומר הביטוי שהשיערוך שלו אחרי הקשירה בין הפרמטרים
הפורמליים לאקטואליים, יתן את ערכה של הפונקציה.
===
הפונקציה defun יוצרת ביטוי-$λ$ וקושרת אותו לשם הפונקציה המוגדרת.
אם תוכן ה-\E|a-list| הוא
\begin{LISP}
(
  (foo.(bar baz))
  (t.t)
  (nil.nil)
)
\end{LISP}
אז לאחר שיערוך הביטוי
\begin{LISP}
(defun
  mirror (x)
  (cons (cdr x) (car x))
)
\end{LISP}
תוכן ה-\E|a-list| יהיה
\begin{LISP}
(
  (mirror.
     (lambda (x)
        (cons (cdr x) (car x))))
  (foo.(bar baz))
  (t.t)
  (nil.nil)
)
\end{LISP}

ניתן ליצר ביטוי-$λ$ מבלי להשתמש ב-\E|defun|, בשימוש בפונקציה quote
\begin{LISP}
  '(lambda (x) (cons (cdr x) (car x)))
\end{LISP}
ולכן ניתן להגדיר את הפונקציה mirror תוך שימוש ב-set במקום ב-defun,
\begin{LISP}
(set mirror
  '(lambda (x)
      (cons (cdr x) (car x)))
)
\end{LISP}
לחילופין, ניתן להשתמש בפונקציה lambda המקבלת שני פרמטרים: הראשון שבהם הוא רשימה
של אטומים, המייצגים את שמות הפרמטרים הפורמליים לפונקציה, והשני הוא גוף הפונקציה
אשר אותו יש לשערך בקריאה לפונקציה, בסביבה הכוללת קישורים בין הפרמטרים הפורמליים
ובין האקטואליים. תוצאת השיערוך של קריאה לפונקציה lambda היא ביטוי S שנראה
בדיוק כמו הקריאה לפונקציה.
\begin{LISP}
> (lambda (x) (cons (cdr x) (car x)))
(LAMBDA (X) (CONS (CDR X) (CAR X)))
\end{LISP}
ניתן לחקות את ה-הפעולה של defun באמצעות set ושימוש בביטויי~$λ$.
\begin{LISP}
(set
  mirror
  (lambda (x) (cons (cdr x) (car x)))
)
\end{LISP}
לאחר הקישור בין השם mirror ובין ביטוי ה-$λ$ המתאר את מימוש הפונקציה \E|mirror|,
האטום mirror ישוערך לביטוי~$λ$ זה. בקריאה \T|(mirror '(a.b))| תוחלף המילה
mirror בביטוי זה, אשר מגדיר כיצד לבצע את הקישור בין הפרמטרים האקטואליים
והפורמליים.

ניתן גם לקרוא לפונקציה מבלי לנקוב בשמה, אלא תוך שימוש בביטוי המתאר את המימוש
שלה:
\begin{LISP}
> (
    '(lambda (x)
      (cons (cdr x) (car x))
    '(a.b)
)

(B.A)
\end{LISP}
ניתן להשמיט את סימן ה-\E|quote|, ולנצל את העובדה שהאטום \T|lambda| אינו רק
הפתיח של ביטוי~$λ$ אלא גם פונקציה המחזירה ביטוי כזה,
\begin{LISP}
> (
    (lambda (x) (cons (cdr x) (car x)
    '(a.b)
)

(B.A)
\end{LISP}

§ שיערוך מותנה ורקורסיה

שיערוך מותנה פירושו שהשיערוך מתבצע כאשר תנאי מסויים מתקיים, והוא אינו מתבצע
כאשר התנאי אינו מתקיים. בליספ שיערוך מותנה מתבצע באמצעות הפונקציה \E|cond|
שבגלעין, אשר מכלילה את פקודות ה-if וה-switch שיש בשפת-\E|\CPL|.

נשתמש ב-cond כדי להגדיר פונקציה zcar המחזירה את ה-car של הפרמטר אם
הוא ביטוי מורכב, ואת הפרמטר עצמו אם הוא אטום
\begin{LISP}
(defun zcar(x)
  (cond ((atom x) x) (t (car x)))
)
\end{LISP}
גוף הפונקציה zcar הוא הביטוי
\begin{LISP}
  (cond ((atom x) x) (t (car x)))
\end{LISP}
שהוא קריאה לפונקציה cond עם שני פרמטרים שכל אחד מהם הוא רשימה בת שני איברים:
\begin{LTR}
  \begin{itemize}
    ✦ \lisp{((atom x) x)}
    ✦ \lisp{(t x)}
  \end{itemize}
\end{LTR}
cond היא פונקציה רב מקומית המקבלת מספר כלשהו של פרמטרים שכל אחד מהם נקרא
\E|test-form|. כל \E|test-form| הוא רשימה בת שני פריטים שכל אחד מהם הוא ביטוי~S
אשר עשוי להיות משוערך במהלך פעולתה של \E|cond|. הפריט הראשון ב-\E|test-form|
נקרא test-condition והפריט השני נקראה \E|test-value|.

הפונקציה cond עוברת על ה-test-forms שקיבלה כפרמטרים לפי סדרם, ובכל אחד כזה היא
משערכת את ה-\E|test-condition|. אם תוצאת השיערוך היא \E|nil|, כלומר
ה-test-condition אינו מתקיים, אזי cond \ע|אינה| משערכת את ה-\E|test-value|, וממשיכה
ל-test-form הבא. אם לעומת זאת תוצאת השיערוך אינה \E|nil|, כלומר ה-test-condition
מתקיים, אזי cond משערכת את ה-\E|test-value|, ומחזירה את תוצאת השיערוך הזו, \ע|מבלי|
להמשיך לשאר ה-\E|test-forms|. אם cond ממצה את רשימת ה-\E|test-forms| מבלי
להיתקל באף \E|test-condition| שמתקיים, הרי cond מחזירה את הערך \E|nil|.

הביטוי
\begin{LISP}
  (cond ((atom x) x) (t (car x)))
\end{LISP}
שבגוף הפונקציה zcar ישוערך לכן ל-x אם x הוא אטום, ול-\E|car| של \E|x|, אם x
איננו אטום.

מקובל להשתמש תמיד באטום \E|t| דווקא כדי לציין את התנאי שמתקיים תמיד, כלומר חלק
ה-else של פקודת ה-\E|if|, אבל טכנית ניתן היה להגדיר את zcar תוך שימוש בביטוי
אחר שערכו אינו \E|nil|, למשל
\begin{LISP}
(defun zcar(x)
  (cond ((atom x) x) ('(DUMMY) (car x)))
)
\end{LISP}
הנה דוגמה נוספת בה cond מופעלת עם מספר רב יותר של test-forms
\begin{LISP}
(defun is-primitive(function)
  (cond
    ((eq function 'atom) t)
    ((eq function 'car) t)
    ((eq function 'cdr) t)
    ((eq function 'cond) t)
    ((eq function 'cons) t)
    ((eq function 'eq) t)
    ((eq function 'error) t)
    ((eq function 'eval) t)
    ((eq function 'set) t)
    (t nil))
)
\end{LISP}
הפונקציה is-primitive משתמשת בסידרה של test-forms כדי לבדוק אם הפרמטר שלה הוא
אטום המציין פונקציה פרימטיבית ואם כן מחזירה את האטום \E|t|. האטום \E|nil| יוחזר
בכל מקרה שהפרמטר אינו אטום, או שהוא אטום שאינו מציין פונקציה פרימיטיבית.
לשם כך, משתמשת is-primitive בפונקציה \T|eq|, שהיא פונקציה פרימטיבית, המשמשת
לבדיקה אם הפרמטרים שלה הם שני אטומים השווים זה לזה.

כדאי לשים לכך שה-test-form האחרון (\T|(t nil)|) מיותר, שהרי אם אף אחד
מה-test-conditions שב-test-forms שקדמו לו אינו מתקיים, ממילא cond
תחזיר \E|nil|. בכל זאת, מקובל להוסיף \T|(t nil)| אף אם אינו נחוץ, כדי להדגיש
שערך ברירת המחדל הוא \E|nil|.

דרך קצרה יותר להגדיר את הפונקציה is-primitive היא באמצעות בדיקה אם הפרמטר
שלה מצוי ברשימה המכילה את שמות כל הפונקציות הפרימטיביות
\begin{LISP}
(defun is-primitive(function)
  (exists function '(atom car cdr cond cons eq error eval set))
)
\end{LISP}
במימוש זה, אטום הוא שמה של פונקציה פרימיטיבית אם הוא מצוי בתוך רשימה של האטומים
המציינות פונקציה פרימיטיבית. הפונקציה exists אינה מצוייה בגלעין, אבל קל לממש
אותה ברקורסיה.
\begin{LISP}
(defun exists (x xs) ; determine if atom x is in list xs
  (cond
    ((eq xs nil) t) ; list is exhausted
    ((eq x (car xs)) t) ; item is first in list
    (t (exists x (cdr xs)))
)
\end{LISP}
הפונקציה \T|exists| מקבלת אטום המסומן ב-\T|x| ורשימה של אטומים המסומנת
ב-\T|xs|, ומחזירה t אם x מצוי בין ה-\T|xs| ו-\T|nil| אחרת. רקורסיה דורשת תמיד
בדיקת תנאי, כדי להבחין בין בסיס הרקורסיה שבו אין צורך לבצע קריאות רקורסיביות
נוספות, ובין המקרה שבו יש צורך בהפעלה רקורסיבית. במקרה של הפונקציה \T|exists|
יש ל-\T|cond| שלושה test-forms:
\ספרר
✦ \T|((eq xs nil) t)| כלומר, אם רשימת ה-\T|xs| ריקה, ברור ש-\T|s| אינו מצוי
בתוכה ואז \T|exists| מחזירה \T|nil|. לעומת זאת, אם תנאי זה אינו מתקדם,
\T|exists| עוברת לבדוק את התנאי הבא:
✦ \T|((eq x (car xs)) t)| כלומר, הרקורסיה בוחנת את הפריט הראשון ברשימה \T|xs|,
על ידי חישוב הביטוי \T|(car xs)| (מובטח שחישוב \T|(car xs)| יצליח שכן
ה-test-form הקודם שבו נבדק אם הרשימה ריקה נכשל) ומשווה אותו ל-\T|x|. אם מתקיים
שיוויון, אזי החיפוש הצליח, ו-\T|exists| מחזירה \T|t| מבלי להידרש ל-test-form
הבא. אחרת, יש בדיקה של ה-test-form הבא:
✦ \T|(t (exists x (car xs)))|, כלומר, במקרה שהרשימה \T|xs| אינה ריקה, ו-\T|x|
אינו שווה לפריט הראשון שב-\T|xs|, הפונקציה \T|exists| קוראת לעצמה רקורסיבית לחיפוש של
\T|x| בשארית הרשימה אשר מתקבלת מחישוב \T|(cdr xs)|.
===
הבדיקה אם הרשימה ריקה נעשית באמצעות חישוב התנאי \T|(eq xs nil)|. השוואה של
אטום ל-nil היא נפוצה בחישובים רקורסיביים. הגלעין מגדיר פונקציה הנקראת null
המיועדת לשם ביצוע השוואה זו:
\begin{LISP}
(defun null(x) (eq x nil))
\end{LISP}
ניזכר שהפונקציה eq היא פונקציה פרימטיבית, במובן זה שלא ניתן לממש אותה באמצעות
פונקציות אחרות. לעומת זאת, כיוון שהפונקציה null שבגלעין ניתנת להגדרה באמצעות
פונקציות אחרות היא נחשבת לפונקצית סיפריה.

מימוש exists באמצעות null יראה אם כן כך
\begin{LISP}
(defun exists (x xs) ; determine if atom x is in list xs
  (cond
    ((null xs) t) ; list is exhausted
    ((eq x (car xs)) t) ; item is first in list
    (t (exists x (car xs))))
)
\end{LISP}

כזכור, ה-a-list היא רשימה של dotted-pairs שכל אחד מהם הוא קישור בין שם לערך.
נגדיר פונקציה רקורסיבית המחפשת שם ברשימה שהיא במבנה של a-list:
\begin{LISP}
(defun lookup (id a-list) ; lookup id in an a-list
  (cond
    ((null a-list) ; list was exhausted.
      (error 'unbound-variable id))
    ((eq id (car (car a-list))) ; found
      (car (cdr (car a-list))))
    (t (lookup id (cdr a-list))))
)
\end{LISP}
גם בפונקציה lookup אנו רואים קריאה רקורסיבית עם cond המתפצל לשלושה מקרים: במקרה
של רשימה ריקה הפונקציה נכשלת, במקרה שראש הרשימה מתאים לתנאי, הפונקציה מצליחה,
וקריאה רקורסיבית בכל מקרה אחר.

בהגדרת lookup נעשה שימוש בפונקציה פרימטיבית נוספת, \E|error|. פונקציה זו מדפיסה את
כל הפרמטרים שלה וגורמת לאינטרפרטר לעבור לסבב הבא של לולאת ה-\E|REPL|.

נשתמש ב-error כדי להגדיר את הפונקציה bind שהיא פונקציה רקורסיבית נוספת,
אשר מקבלת שתי רשימות באורך שווה: רשימת שמות (\E|names|) ורשימת ערכים
(\E|values|), וכן רשימה שהיא במבנה של \E|a-list|. \E|bind| ומחזירה את ה-a-list
שקיבלה בתוספת קישורים בין השמות לערכים.

\begin{minipage}{0.95\linewidth}
\begin{LISP}
; bind names to values, and append to a-list
(defun bind (names values a-list)
  (cond
    ((null names) ; no more names
      (cond
        ((null values) a-list)
        (t (error 'missing-names))))
    ((null values) ; more names than values
      (error 'missing-values))
    (t
      (cons
        (cons (car names) (car values)) ; new dotted-pair
        (bind (cdr names) (cdr values) a-list)))))
\end{LISP}
\end{minipage}

§ שיערוך ביטוי מורכב וקריאה לפונקציה

תיארנו למעלה כיצד נעשה שיערוך של אטום. נותר לתאר כיצד מתבצע השיערוך של ביטוי
מורכב: בכל פעם שיש לשערך ביטוי מורכב \E|$s$|, פרוצדורת השיערוך של ליספ מנסה
להציג אותו כרשימה בת~$n+1$ איברים \[
  s=(s₀\;\;s₁\;\;⋯\;\;sₙ).
\] אם הביטוי אינו רשימה, השיערוך נכשל. אם הרשימה ריקה, תוצאת השיערוך היא האטום
\T|nil|. אחרת, האינטרפטר מסתכל על הרשימה כעל עץ שיערוך, כלומר כעל קריאה
לפונקציה~$s₀$ המקבלת~$n$ ארגומנטים \E|$s₁$,…,$sₙ$|, והשיערוך
של~$s$ מתבצע על פי הסתכלות זו:
\begin{enumerate}
  ✦ שיערוך רקורסיבי של~$s₀$, הפונקציה אותה יש להפעיל. אם השיערוך של~$s₀$ נכשל,
  אזי גם השיערוך של~$s$ נכשל. אחרת, שיערוך זה מחזיר ביטוי~\E|S| שנסמן~$s₀'$.

  השיערוך של~$s$ נכשל גם אם~$s₀'$ אינו פונקציה, או שהוא פונקציה, אך כזו שאינה
  מצפה ל-$n-1$ ארגומנטים בדיוק.

  ✦ האינטרפטר ממשיך כעת לשערך רקורסיבית את הפרמטרים האקטואליים לפונקציה~$s₀'$,
  הלא הם הביטויים~\E|$s₁$~,…,~$sₙ$|. נסמן את תוצאות השיערוך הללו
  ב-\E|$s₁'$,…,$sₙ'$|. אם השיערוך הרקורסיבי של אחד מבין
  הביטויים~\E|$s₁$,…,~$sₙ$| נכשל, אז גם השיערוך של הביטוי~$s$
  כולו נכשל.

  ✦ תוצאת השיערוך של הביטוי~$s$ היא תוצאת הקריאה לפונקציה~$s₀'$ על~$n$ הביטויים
  \E|$s₁'$,…,~$sₙ'$|. אם הפעלת זו נכשלת, השיערוך של הביטוי~$s$ כולו נכשל.
\end{enumerate}

עלינו עוד לתאר כיצד נעשית קריאה לפונקציה. נסתכל לדוגמה על הפונקציה הרקורסיבית המוסיפה פריט בסופה של רשימה
\begin{LISP}
(defun append(x xs)
  (cond
    ((null xs) (x))
    (t
      (cons
        (car x)
        (append x (cdr xs))))))
\end{LISP}
לאחר ביצוע הגדרה זו, כלומר לאחר שיערוך הביטוי מעלה, יווצר קישור בין השם append
ובין גוף הפונקציה \E|append|, כלומר ביטוי ה-$λ$
\begin{LISP}
(lambda (x xs)
  (cond
    ((null xs) (x))
    (t
      (cons
        (car x)
        (append x (cdr xs))))))
\end{LISP}
וקישור זה יתווסף לתחילת ה-\E|a-list|. בקריאה ל-append כמו
\begin{LISP}
(append 'a '(b c))
\end{LISP}

פרודצורת השיערוך תאתר את ביטוי ה-$λ$ הקשור לפונקציה, ותפרק אותו לשלושת
מרכיביו: האטום lambda המזהה את הביטוי, רשימת הפרמטרים הפורמליים \lisp{(x xs)}
והביטוי לחישוב,
\begin{LISP}
(cond
  ((null xs) (x))
  (t
    (cons
      (car x)
      (append x (cdr xs)))))
\end{LISP}
הקריאה לפונקציה append מתבצעת על ידי שיערוך הפרמטרים האקטואליים, כלומר שיערוך
של הפרמטר \lisp{'a} לכדי הערך \lisp{A} ושיערוך של הפרמטר \lisp{'(b c)}
לכדי הערך \lisp{(B C)}, ולאחר מכן חישוב
הביטוי הזה בתנאים שבהם הפרמטר x משתערך לאטום
\lisp{a} והפרמטר xs משתערך לרשימה \lisp{(b c)}.

קריאה לפונקציה בפרודצורת השיערוך בליספ נעשית באמצעות יצירת קישורים בין שמות הפרמטרים הפורמליים
וערכי הפרמטרים האקטואליים. במקרה של append מתווספים שני \E|dotted-pairs|
\begin{LISP}
(x.a)
\end{LISP}
ו
\begin{LISP}
(xs.(b c))
\end{LISP}
ל-\E|a-list|.
לאחר הקריאה לפונקציה, יש לשחזר את ערכה של ה-a-list לערכה המקורי טרם הקריאה לה.
כאשר append קוראת לעצמה רקורסיבית, יתבצע קישור נוסף בין הפרמטרים האקטואליים והפורמליים,
וגם זאת על ידי תוספת של \E|dotted-pairs|, והפעם את
\begin{LISP}
(x.a)
\end{LISP}
ו
\begin{LISP}
(xs.(c))
\end{LISP}
קישורים אלו יסתירו את הקישורים הקודמים.
בקריאה הרקורסיבית השלישית ל-append יווצרו שני קישורים נוספים,
\begin{LISP}
(x.a)
\end{LISP}
ו
\begin{LISP}
(xs.())
\end{LISP}
כאמור, בכל פעם שבה הפונקציה append חוזרת מהפעלה רקורסיבית,
ה-a-list ישוחזר, ושני קישורים בין פרמטרים פורמליים לאקטואליים יוסרו ממנו.

§ שיערוך דחוי
פרוצדורת השיערוך כפי שתוארה עד כה אינה מספיקה כדי לשערך את העץ ב\פנה|איור:עץ|
כהלכה. הסיבה היא שהאופרטור הטרנארי \T|:?| אשר מצוי בשורש העץ, מחשב את הארגומנט
הראשון שלו, ובהתאם לתוצאת החישוב, מחשב את הארגומנט השני או השלישי, אבל לא את
שניהם גם יחד. בפרודצורת השיערוך שתוארה למעלה, יש לחשב את כל הארגומנטים לפונקציה
(או אופרטור), טרם שמפעילים את הפונקציה עצמה.

פרוצדורת השיערוך גם אינה מתאימה לפונקציות כגון quote ו-lambda אשר אינן משערכות
את הפרמטרים שלהן כלל. הפרודצורה גם אינה מתאימה לפונקציות כגון cond בהן השיערוך
של חלקים מגוף הפונקציה תלוי בערכים המחושבים בחלקים אחרים של הגוף.

אנו מבדילים בין שני סוגים של סמנטיקות של שיערוך של פונקציה:
\begin{description}
  ✦ [eager] בקריאה לפונקציה כגון set שהסמנטיקה שלה היא \E|eager|, הארגומנטים
  לפונקציה משוערכים \ע|טרם| הקריאה לפונקציה, ורק ערכי השיערוך מועברים לפונקציה.
  הפונקציה אינה יכולה לדעת מה היו ערכי הארגומנטים לפני ששוערכו.

  פונקציות בעלות סמנטיקה שהיא eager מיוצגות על ידי ביטוי~$λ$ שהאטום הראשון שבו
  הוא \T|lambda|.

  ✦ [normal] לעומת זאת, בקריאה לפונקציה כגון quote שהסמנטיקה שלה היא
  \E|normal|, הארגומנטים לפונקציה \ע|אינם| משוערכים טרם הקריאה לפונקציה,
  והפונקציה יכולה לבחור אם לשערך את הארגומנטים.

  פונקציות בעלות סמנטיקה שהיא normal מיוצגות על ידי ביטוי~$λ$ שהאטום הראשון שבו
  הוא האטום \T|nlambda|.†{
  שימוש זה ב-nlambda היה קיים במימושים הראשונים של ליספ, אולם ברוב המימושים המודרניים
  הוא בוטל מסיבות של יעילות. במקומו, נוסף מה שקוראים מקרו \E|(macro)|
  שהוא דומה אך לא זהה ל-\E|nlambda|.}

\end{description}

הסמנטיקה של כל הפונקציות וכמעט כל האופרטורים בשפות כמו \E|\CPL|, היא \E|eager|.
ב\פנה|טבלה:גלעין| אנחנו רואים גם שמרבית הפונקציות שבגלעין הן \E|eager|.

הפונקציה quote שבגלעין אינה פרימיטיבית שכן ניתן להגדיר אותה באמצעות ביטוי
ה-nlambda הפשוט הבא
\begin{LISP}
(nlambda (x) x)
\end{LISP}
לא ניתן להגדיר פונקציות שהן normal באמצעות \E|defun|, אך ניתן להוסיף את הפונקציה
quote לרשימת ה-a-list באמצעות set
\begin{LISP}
(set 'quote
    '(nlambda (x) x)
)
\end{LISP}
כפי שראינו הגלעין של ליספ מגדיר גם פונקציה lambda שהסמנטיקה שלה היא normal
המאפשרת ליצור ביטוי~$λ$ מבלי להשתמש ב-quote
\begin{LISP}
> (lambda (x) (cons (cdr x) (car x)))
(LAMBDA (X) (CONS (CDR X) (CAR X)))
\end{LISP}
נוכל לכן להגדיר את הפונקציה lambda באמצעות
\begin{LISP}
(set 'lambda
  '(nlambda (parameters-list body) ('lambda parameters body))
)
\end{LISP}
כלומר, הפונקציה lambda היא פונקציה שמקבלת שני פרמטרים: parameters-list
ו-\E|body|. הפונקציה אינה משערכת פרמטרים אלו ומחזירה ביטוי lambda המוגדר על ידיהם
\begin{LISP}
  ('lambda parameters body)
\end{LISP}
גם הפונקציה nlambda מסייעת להגדרת ביטויי nlambda באופן דומה, וניתן להגדירה
באמצעות
\begin{LISP}
(set 'nlambda
  '(nlambda (parameters-list body) ('nlambda parameters body))
)
\end{LISP}
כלומר, גם הפונקציה nlambda היא פונקציה שמקבלת שני פרמטרים שאינם משוערכים
(parameters-list ו-\E|body|) ומחזירה ביטוי nlambda המוגדר על ידי
שני הפרמטרים הללו
\begin{LISP}
  ('nlambda parameters body)
\end{LISP}
לאחר הגדרה זו של הפונקציה nlambda הכתיב
\begin{LISP}
  (nlambda x y)
\end{LISP}
זהה לכתיב
\begin{LISP}
  ('nlambda x y)
\end{LISP}
ללא תלות בערכיהם של x ו-\E|y|.

ניתן גם להגדיר את הפונקציה defun באמצעות ביטוי nlambda
\begin{LISP}
(set 'defun
  (nlambda (name parameter-list body)
      (set name (lambda parameter-list body)))
\end{LISP}
כלומר, הפונקציה defun היא ביטוי nlambda אשר מקבל שלושה פרמטרים: \E|name|,
\E|parameter-list| ו-\E|body|, ואשר קושר (באמצעות \E|set|) את הפרמטר אל ביטוי
ה-lambda המוגדר על ידי שני הפרמטרים האחרים, והכל מבלי לשערך את הפרמטרים שלו.

ניתן גם להגדיר את הפונקציה ndefun המגדירה פונקציה שהסמנטיקה שלה היא normal
\begin{LISP}
(set 'ndefun
  (nlambda (name parameter-list body)
      (set name (nlambda parameter-list body)))
\end{LISP}
גוף ההגדרה זהה לזה defun אלא ש-ndefun יוצרת ביטוי nlambda במקום ביטוי
\E|lambda|.

לאחר שהגדרנו את הפונקציה ndefun נוכל להגדיר את quote באמצעותה
\begin{LISP}
(ndefun quote(x) x)
\end{LISP}
הפונקציות \E|quote|, \E|defun|, \E|ndefun|, \E|lambda| ו-\E|nlambda| אינן
משערכות את הפרמטרים שלהן אף פעם. כאשר יש צורך בשיערוך הפרמטרים ניתן לקרוא
לפונקציה הפרמיטיבית \E|eval|.
נגדיר לדוגמה את הפונקציה setq אשר מאפשרת לקשור ערך לאטום ללא צורך לבצע quoting על שם האטום
\begin{LISP}
(ndefun setq(atom value)
  (set atom (eval value)))
\end{LISP}
באופן דומה נגדיר את הפונקציה \T|?:| אשר מתנהגת באופן דומה לאופרטור בשם זה בשפת~\CPL
\begin{LISP}
(ndefun ?: (condition true-value false-value)
  (cond
    ((eval condition) (eval true-value))
    (t (eval false-value))))
\end{LISP}

נתקן את פרוצדורת השיערוך כך שתתמוך בפונקציות שהן \E|normal|, על ידי הוספת התנאי
הבא: בשיערוך הביטוי \[
  s=(s₀\;\;s₁\;\;⋯\;\;sₙ).
\] אם שיערוך הביטוי~$s₀$ מחזיר פונקציה שהיא
normal כלומר ביטוי~$λ$ שהאטום הראשון שבו הוא nlambda (ולא \E|lambda|) אזי יש
להעביר לפונקציה זו כארגומנטים את הביטויים~\E|$s₁$,…,$sₙ$| ולא את הערכים
המשוערכים שלהם~\E|$s₁'$,…,$sₙ'$|.

§ הגדרת פונקצית השיערוך בליספ

מתברר שאפשר לממש את פרוצדורת השיערוך גם בליספ. לשם כך נגדיר פונקציה evaluate
המקבלת ביטוי \E|S|, וסביבה במבנה של \E|a-list|, ומשערכת את הביטוי בהתאם
לקישורים שבסביבה הנתונה.  הפונקציה evaluate קוראת לעצמה ברקורסיה כדי לשערך את
מרכיבי הביטוי. כאשר evaluate תזהה ביטוי~$λ$ היא תקרא לפונקצית עזר apply אשר גם
אותה נגדיר בהמשך, ואשר אחראית להפעיל ביטוי~$λ$ על הפרמטרים המועברים לו. אם
ביטוי ה-$λ$ הוא \E|eager|, אז apply תקרא ל-evaluate כדי לשערך את הפרמטרים.

מבנה הקריאות והרקורסיות ההדדיות שבמימוש של evaluate ופונקציות העזר שלה מתואר
ב\פנה|איור:שיערוך|.


\begin{figure}[!htb]
  \כיתוב|רקורסיות הדדיות בין הפונקציה evaluate ופונקציות העזר שלה|
  \תגית|איור:שיערוך|
  \forestset{%
    call tree/.style={
        for tree={
            font=\scriptsize,
            % draw,
            s sep'+=-4pt,
            fit=tight,
          },
      },
  }
  \centering
  \begin{forest}
    call tree [evaluate,name=evaluate
    [lookup,name=lookup] {
    \draw[->] () [out=south west,in=north] .. controls+(250:2) and+(120:2) .. ();
    }
    [is-primitive [exists]
    {
    \draw[->] () [out=south west,in=north] .. controls+(250:2) and+(120:2) .. ();
    }
    ]
    [evaluate-primitive
    [apply-primitive
    [evaluate-cond] {
    \draw[->] (.-20) .. controls+(-60:0.9) and+(60:0.9) .. (.20);
    \draw[->] (.200) .. controls+(210:9) and+(120:6) .. (evaluate.120);
    }
    [apply-eager-primitive
    [apply-trivial-primitive]
    ]
    ]
    ]
    [apply, name=apply
    [apply-decomposed-lambda
    [bind] {
    \draw[->] () [out=south west,in=north] .. controls+(250:2) and+(120:1) .. ();
    }
    [evaluate-list] {
    \draw[->] (.210) .. controls+(250:2) and+(120:1) .. (.150);
    \draw[->] (.-20) .. controls+(-10:6) and+(60:3) .. (evaluate.60);
    }
    ]
    ] {
    \draw[->] (.15) .. controls+(30:1) and+(60:1) .. (evaluate.north east);
    }
    ]
    \draw[->] (.180) [out=south west,in=north west] .. controls+(south west:1) and+(north west:2) .. ();
    \path (current bounding box.south west)++(-13ex,0) coordinate (A);
    \path (current bounding box.north east)++(11ex,1ex) coordinate (B);
    \clip (A) rectangle (B);
  \end{forest}
\end{figure}

אנו רואים באיור גם ש-apply קוראת לפונקציה הרקורסיבית bind (שאותה כבר הגדרנו),
וזאת כדי לקשור בין הפרמטרים הפורמליים והאקטואליים. האיור מראה גם ש-evaluate
משתמשת בכמה פונקציות נוספות שהוצגו כבר: הפונקציה הרקורסיבית lookup כדי לשערך את
ערכו של אטום, ו-is-primitive הקוראת ל-exists הרקורסיבית כדי לזהות אטומים המזהים
פונקצית פרימיטיביות.  בנוסף לאלו, נעזרת evaluate בפונקציה
\E|evaluate-primitive|, אשר תתואר בהמשך, כדי לטפל בפונקציות הפרימיטיביות
שבגלעין.

הגוף של evalaute הוא קצר, והוא מבוסס על אבחנה בין שלוש אפשרויות שונות ביחס
לביטוי אותו היא נדרש לשערך.

\begin{minipage}{0.97\linewidth}
\begin{LISP}
(defun evaluate(S-expression a-list) ; evaluate S-expression in the environment defined by a-list
  (cond
    ((atom S-expression) ; recursion base: lookup of atom in a-list
      (lookup S-expression a-list))
    ((is-primitive (car S-expression)) ; special case handling of primitive functions
      (evaluate-primitive S-expression a-list))
    (t ; recursion---lambda applied to parameters
      (apply
        (evaluate (car S-expression) a-list) ; find lambda expression
        (cdr S-expression) ; find actual parameters
        a-list))))
\end{LISP}
\end{minipage}
אם הביטוי ש-evaluate מקבלת הוא אטום, evaluate מפעילה את \E|lookup| כדי למצוא את
הערך הקשור אליו ברשימת ה-\E|a-list|.  אם לעומת הביטוי הוא ביטוי מורכב, אזי
dotted-pair אשר ה-car שלו הוא פונקציה, וה-cdr שלו הוא רשימה של
ארגומנטים שיש להעביר לפונקציה. אם ה-car הוא שם של פונקציה אטומית, נדרש טיפול
מיוחד, ואז evaluate קוראת לפונקציה evaluate-primitive אשר מבצעת זאת.
בכל מקרה אחר, evaluate מוצאת את הפונקציה אותה יש להפעיל על ידי השיערוך
\begin{LISP}
(evaluate (car S-expression) a-list)
\end{LISP}
קריאה רקורסיבית זו תחזיר את ביטוי ה-$λ$ אותו יש להפעיל על הפרמטרים. evaluate
גם מחשבת את הפרמטרים באמצעות הקריאה-\T|(cdr S-expression)|, וקוראת לפונקציה
apply אשר מפעילה את ביטוי ה-$λ$ על הפרמטרים.

הפונקציה apply מצידה מפרקת את ביטוי ה-$λ$ לשלושת מרכיביו (תגית, רשימת פרמטרים
וביטוי לחישוב), ומעבירה מרכיבים אלו לפונקצית העזר apply-decompsed-lambda
\begin{LISP}
(defun apply(lambda-expression actuals a-list)
  (apply-decomposed-lambda
    (car lambda-expression) ; tag=lambda or nlambda
    (car (cdr lambda-expression)); list of formal parameters
    (car (cdr (cdr lambda-expression))); body
    actuals
    a-list))
\end{LISP}
הפונקציה apply-decompsed-lambda משערכת את גוף הפונקציה, בסביבה הכוללת קישור בין
הפרמטרים הפורמלים לאקטואליים. קישור זה נעשה באמצעות הפונקציה bind אותה כבר
הגדרנו.

אם התגית של ביטוי ה-$λ$ היא האטום nlamba הקישור נעשה ללא שיערוך
הפרמטרים האקטואליים. אם לעומת זאת התגית היא האטום lambda הקישור בין הפרמטרים
הפורמליים לאקטואליים נעשה לאחר שיערוך של הפרמטרים האקטואליים באמצעות הפונקציה
\E|evalauate-list|. אם התגית אינה אף אחד משני האטומים הללו השיערוך נכשל.
\begin{LISP}
(defun apply-decompsed-lambda(tag formals body actuals a-list)
  (evaluate body
    (cond
      (eq tag 'nlambda) (bind formals actuals a-list)
      (eq tag 'lambda) (bind formals (evaluate-list actuals a-list) a-list)
      (t (error 'unkown-lambda tag)))))
\end{LISP}
ההגדרה של הפונקציה evaluate-list המיועדת לשיערוך רשימת הפרמטרים האקטואליים היא
באמצעות הפעלה רקורסיבית של evaluate על כל אחד מאיברי הרשימה, ושרשור התוצאות
לכדי רשימה אחת.
\begin{LISP}
(defun
  evaluate-list(S-expressions a-list)
    (cond
      ((null S-expressions) nil) ; no more S-expressions to evaluate
      (t
        (cons
          (evaluate (car S-expressions)) ; evaluate first S-Expression
          (evaluate-list (cdr S-expressions)))))) ; recursive call on remainder
\end{LISP}

§ מימוש הפונקציות הפרימטיביות שבגלעין

תיארנו את הפונקציה evaluate הממשת את מרבית הפעולות שבפרוצדורת השיערוך של ליספ.
נותר עוד לתאר את המימוש של הפונקציה evaluate-primitive אשר נועדה לטיפול בפונקציות
פרימטיביות, כלומר כאלו שלא הוגדרו על ידי המתכנת והמימוש שלהן לא נמצא בתוך
ה-\E|a-list|.

הצעד הראשון במימוש של evaluate-primitive הוא פירוק הביטוי אותו יש לשערך לשני
חלקים: שם הפונקציה הפרימיטיבית, והפרמטרים לפונקציה זו.
\begin{LISP}
(defun (evaluate-primitive S-expression a-list)
  (apply-primitive (car S-expression) (cdr S-expression) a-list))
\end{LISP}

\פנה|טבלה:גלעין| מסכמת את הפונקציות הפרימיטיביות שבגלעין אשר evaluate-primitive צריכה לטפל בהן.

\begin{table}[!htb]
  \begin{tabularx}\textwidth{>{\setLR\scriptsize\setLR}c>{\scriptsize}c
    >{\setRL\scriptsize\raggedleft\arraybackslash}X
    >{\scriptsize\setLR\raggedright\arraybackslash}X
    >{\scriptsize\setLR\raggedright\arraybackslash}X
    }
    \toprule

    \normalsize \bfseries {\text{/arity}}שם &
    \normalsize \bfseries סמנטיקה &
    \normalsize \bfseries תמצית &
    \multicolumn1c{\normalsize \bfseries \RL{דוגמאות}} ⏎
    \midrule

    atom/1 &
    eager &
    בדיקה אם הארגומנט הוא אטום &
    \lisp{(atom nil)}~$⇒$ \lisp{T} \newline
    \lisp{(atom t)}~$⇒$ \lisp{T} \newline
    \lisp{(atom '(a a))}~$⇒$ \lisp{NIL} \newline
    \lisp{(atom 'a)}~$⇒$ \lisp{T} ⏎

    car/1 &
    eager &
    חילוץ האיבר הראשון ברשימה &
    \lisp{(car '(b.a))}~$⇒$ \lisp{B} \newline
    \lisp{(car '(b a))}~$⇒$ \lisp{B} \newline
    \lisp{(car '(a))}~$⇒$ \lisp{A} \newline
    \lisp{(car 'a)}~$⇒$ \text{✗} \newline
    \lisp{(car ())}~$⇒$ \text{✗} ⏎

    cdr/1 &
    eager &
    חילוץ שארית הרשימה, כלומר הרשימה ללא האיבר הראשון &
    \lisp{(cdr '(a.b))}~$⇒$ \lisp{b} \newline
    \lisp{(cdr '(a b))}~$⇒$ \lisp{(b)} \newline
    \lisp{(cdr '(b))}~$⇒$ \lisp{NIL} \newline
    \lisp{(cdr t)}~$⇒$ ✗ \newline
    \lisp{(cdr ())}~$⇒$ ✗ \newline
    \lisp{(cdr nil)}~$⇒$ ✗ ⏎

    ($n≥0$) cond/n &
    normal &
    הכללה של פקודת \E|if|. &
    \lisp{(cond (t 'A))}~$⇒$ \lisp{A} \newline
    \lisp{(cond (nil 'A) (t 'B))}~$⇒$ \lisp{B} \newline
    \lisp{(cond (nil 'A) (t 'B) (t 'C))}~$⇒$ \lisp{B} \newline
    \lisp{(cond (nil 'A) (nil 'B) (nil 'C))}~$⇒$ \lisp{nil}\newline
    \lisp{(cond)}~$⇒$ \lisp{nil} ⏎

    cons/2 &
    eager &
    הוספת איבר בתחילת רשימה &
    \lisp{(cons 'a '(b c))}~$⇒$ \lisp{(A B C)} \newline
    \lisp{(cons 'b nil)}~$⇒$ \lisp{NIL} \newline
    \lisp{(cons 'a 'b)}~$⇒$ \lisp{(A.B)} ⏎

    eq/2 &
    eager &
    בדיקה אם שני הפרמטרים הם אטומים השווים זה לזה &
    \lisp{(eq t t)}~$⇒$ \lisp{T} \newline
    \lisp{(eq t nil)}~$⇒$ \lisp{NIL} \newline
    \lisp{(eq nil nil)}~$⇒$ \lisp{T} \newline
    \lisp{(eq 'a 'a)}~$⇒$ \lisp{T} \newline
    \lisp{(eq '(a a) '(a a))}~$⇒$ \lisp{NIL} ⏎

    ($n≥0$) error/n &
    eager &
    הדפסת כל הפרמטרים ועצירת ביצוע התכנית &
    \lisp{(error)}~$⇒$ ✗ \newline
    \lisp{(error A)}~$⇒$ ✗ \newline
    \lisp{(error 'my-error 'message)}~$⇒$ ✗ ⏎

    eval/1 &
    eager &
    הדפסת כל הפרמטרים ועצירת ביצוע התכנית &
    \lisp{(eval 'a)}~$⇒$ \lisp{A} \newline
    \lisp{(eval '(car (x.y))}~$⇒$ \lisp{Y} ⏎

    set/2 &
    eager &
    יצירת קישור בין אטום ובין ביטוי~\E|S|. &
    \lisp{(set 'a '(b c))}~$⇒$ \lisp{(b c)}\newline
    \lisp{(set 'b nil)}~$⇒$ \lisp{NIL}
    \label{primitive:count}
 ⏎
    \bottomrule
  \end{tabularx}
  \כיתוב|הפונקציות הפרימטיביות בגלעין של ליספ|
  \תגית|טבלה:גלעין|
\end{table}

אנו רואים ש-cond היא הפונקציה היחידה מבין כל אלו שהסמנטיקה שלה היא \E|normal|.
במימוש של apply-primitive נבדיל בין פונקציה זו וכל השאר.
\begin{LISP}
(defun apply-primitive (function actuals a-list)
  (cond
    ((eq 'cond function)
      (evaluate-cond actuals a-list))
    (t
      (apply-eager-primitive
        function
        (evaluate-list actuals a-list)
        a-list))))
\end{LISP}
המימוש של evaluate-cond הוא ברקורסיה פשוטה על רשימת ה-test-forms
\begin{LISP}
(defun evaluate-cond(test-forms a-list);
  (cond
    ((null test-forms) nil) ; if no more test-forms, return nil
    ((evaluate (car (car test-forms)) a-list) ; evaluate test-condition of first test-form
      (evaluate (car (cdr (car test-forms))) a-list)) ; if true, evaluate test-value of first test-form
      (t (evaluate-cond (cdr test-forms) a-list))))   ; otherwise, recurse on remainder list of test-forms
\end{LISP}
כדי לטפל בשאר הפונקציות שב\פנה|טבלה:גלעין| נשים לב לכך שכל אלו לבד מ-eval אינן נדרשות יותר ל-a-list, וכולן, לבד מ-error
מצפות לפרמטר אחד או שני פרמטרים. הפונקציה
apply-eager-primitive מטפלת בשני מקרים מיוחדים אלו, ומעבירה את המשך הטיפול ל-apply-trivial-primitive
\begin{LISP}
(defun (apply-eager-primitive function actuals a-list)
  (cond
    ((eq 'error function) (error actuals))
    ((eq 'eval function) (evaluate (car actuals) a-list))
    (t (apply-trivial-primitive
      function
      (car actuals) ; first actual parameter
      (car cdr actuals))))) ; second actual parameter, could be nil
\end{LISP}
כעת הפונקציה apply-trivial-primitive משתמשת ב-cond כדי לטפל בששת הפונקציות הפרימטיביות שנותרו:
\begin{LISP}
(defun (apply-trivial-primitive function first second)
  (cond
    ((eq 'atom function) (atom first))
    ((eq 'car function) (car first))
    ((eq 'cdr function) (cdr first))
    ((eq 'cons function) (cons first second))
    ((eq 'eq function) (eq first second))
    ((eq 'set function) (set first second))
    (t (error 'something-went-wrong function))))
\end{LISP}

\פנה|טבלה:סיפריה| מרכזת את הפונקציות בגלעין שאינן פרימטיביות, כלומר אלו שמימושן
יכול להעשות ישירות באמצעות הפונקציה \E|set| או באמצעות הפונקציות \E|defun|, \E|lambda|, \E|ndefun|
ו-\E|nlambda|, שגם הן שגם משתמשות ב-\E|set|.
\begin{table}[H]
  \begin{tabularx}\textwidth{>{\setLR\scriptsize}c>{\scriptsize}c
    >{\scriptsize\raggedleft\arraybackslash}X
    >{\setLR\scriptsize\raggedright\arraybackslash}X
    >{\setLR\scriptsize\raggedright\arraybackslash}X
    }
    \toprule
    \normalsize \bfseries {\text{/arity}}שם &
    \normalsize \bfseries סמנטיקה &
    \normalsize \bfseries תמצית &
    \multicolumn1c{\normalsize \bfseries \RL{הגדרה}} &
    \multicolumn1c{\normalsize \bfseries \RL{דוגמאות}} ⏎
    \midrule

    \E|defun/3| &
    normal &
    יצירת קישור בין אטום ובין ביטוי S שהוא פונקציה בסמנטיקה \E|eager|. &
    \lisp{(set 'defun }\newline
    \mbox\quad\lisp{(nlambda (n p b)} \newline
    \mbox\qquad \lisp{(set n (lambda p b))))} &
    \T|(defun f (x y) (y x))|\newline\quad⏎

    lambda/2 &
    normal &
    יצירת פונקציה אנונימית שהסמנטיקה שלה היא \E|eager|. &
    \lisp{(ndefun lambda(p b)}\newline
    \mbox\quad\lisp{('lambda p b))} &
    \lisp{((lambda (x) (car (cdr x)))}\newline
    \mbox\quad\lisp{'(a b)}~$⇒$ \lisp{B}
 ⏎

    nil/0 &
    n/a &
    האטום הנקבע על ידי~$ε$, סדרת ריקה של תווים, והמציין את הרשימה הריקה. אטום
    זה מציין את עצמו, ונחשב גם לערך הבוליאני של שקר, \E|false|. &
    \lisp{(set 'nil 'nil)} &
    \lisp{nil}~$⇒$ \lisp{NIL} \newline
    \lisp{()}~$⇒$ \lisp{NIL} \newline
    \lisp{(eq nil t)}~$⇒$ \lisp{NIL} ⏎

    null/1 &
    eager &
    בדיקה אם הארגומנט הוא האטום \lisp{nil} &
    \lisp{(defun null (x)}\newline
    \mbox\quad\lisp{(eq x nil))} &
    \lisp{(null t)}~$⇒$ \lisp{NIL} \newline
    \lisp{(null nil)}~$⇒$ \lisp{T}\newline
    \lisp{(null 'a)}~$⇒$ \lisp{NIL} \newline
    \lisp{(null '(a a))}~$⇒$ \lisp{NIL} ⏎

    ndefun/3 &
    normal &
    יצירת קישור בין אטום ובין ביטוי S שהוא פונקציה בסמנטיקה \E|normal|. &
    \lisp{(set 'ndefun }\newline
    \mbox\quad\lisp{(nlambda (n p b)} \newline
    \mbox\qquad\lisp{(set n (nlambda p b))))} &
    \T|(ndefun f(x y) (y x))|\newline\quad~$⇒$ \T|F|⏎

    nlambda/2 &
    normal &
    יצירת פונקציה אנונימית שהסמנטיקה שלה היא \E|normal|. &
    \lisp{(ndefun nlambda(p b)}\newline\mbox\quad\lisp{('nlambda p b))} &
    \T|(nlambda f (x y) (y x))|~$⇒$
    \newline\mbox\quad\T|(nlambda f (x y) (y x)|
 ⏎

    quote/1 &
    normal &
    החזרת הארגומנט מבלי לשערך אותו. &
    \lisp{(ndefun quoate (x) x)} &
    \lisp{(quote a)}~$⇒$ \lisp{A} \newline
    \lisp{(quote (b c))}~$⇒$ \lisp{(B C)} \newline
    \lisp{'a}~$⇒$ \lisp{A} \newline
    \lisp{'(b c)}~$⇒$ \lisp{(B C)} \newline ⏎

    t/0 &
    n/a &
    האטום \E|t|, המציין את \E|t|, כלומר את עצמו. נחשב גם לערך הבוליאני של אמת,
    \E|(true)|. &
    \lisp{(set 't 't)} &
    \lisp{t}~$⇒$ \lisp{T} \newline \lisp{(eq nil nil)}~$⇒$ \lisp{T} ⏎

    \bottomrule
  \end{tabularx}
  \כיתוב|פונקציות הסיפריה של הגלעין של ליספ|
  \תגית|טבלה:סיפריה|
\end{table}
\end{document}]
