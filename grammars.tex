כוח ההבעה של בביטויים רגולריים מוגבל כיוון שביטויים רגורליים אינם מאפשרים
רקורסיה: כלומר, לא ניתן בהגדרה של ביטוי רגולרי מסויים, בתוך ההגדרה עצמה. לעומת
ביטויים רגולריים ניצבים דקדוקים \E|(grammars)|, אשר תומכים בהגדרות רקורסיביות.

הגדרות של שפות תכנות עושות שימוש נרחב בדקדוקים, ובמיוחד בסוג מיוחד של דקדוקים,
הלא הם הדקדוקים חסרי ההקשר \RL{(context free grammars)}. יתירה מכך, הסכימה
הכללית של ניתוח תכנית בשפת תכנות בלתי מסויימת, היא של ניתוח לקסיקלי של הקלט
לאסימונים, כאשר מבנה האסימונים מוגדר על ידי ביטויים רגולריים, ולאחר מכן, ניתוח
דקדוקי של האסימונים, תוך שימוש בדקדוק מתאים.

בפרק זה יתברר כי עיקרו של כל דקדוק הוא אוסף של כללי דקדוקיים הידועים גם בשם
כללי גזירה. כל כלל גזירה מאפשר להחליף צורת משפט אחת באחרת. נגדיר לכן בפרק זה
מהי צורת משפט, ובאמצעות הגדרה זו, מהו כלל גזירה, וכיצד מפעילים אותו. בנוסף
לכללים, הדקדוק גם קובע צורת משפט התחלתית. השפה הפורמלית המוגדרת על ידי דקדוק
היא אוסף כל המילים שאפשר להגיע אליהן מצורת המשפט ההתחלתית, תוך הפעלת הכללים
הדקדוקיים.

נדגים את המושגים עוד לפני הגדרתם המדוייקת. לשם כך, נסתכל על שפת הסוגריים כשפה
הפורמלית מעל האלפאבית בן שתי האותיות~$Σ=❴⌘), ⌘(❵$ כאוסף כל המילים~$w$,
המכילות מספר שווה
של שני סימני האלאפבית, ואשר בכל רישא שלהן אין יותר מופעים של~$⌘)$, סימן סגור
הסוגרים, מאשר מופעים של~$⌘($, סימן סגור הסוגריים.
הנה דקדוק חסר הקשר המתאר שפה זו
הסוגריים \דוגמה|שפת הסוגריים|
$Σ=❴⌘), ⌘(❵$,~$N=❴S❵$
\begin{equation}
  \label{eq:parenthesis}
  \begin{split}
    S &→ε ⏎
    S &→⌘)S⌘(⏎
    S &→SS ⏎
  \end{split}
\end{equation}
בדקדוק זה ישנם שלושה כללים, וכל אחת מסדרות הסימנים משמאל או מימין של החץ המופיע
בכל אחד מכללים אלו היא צורת משפט. אפשר לראות את הרקורסיה הטמונה בכללי
הגזירה, בעובדה שכלל הגזירה השני מחליף את צורת המשפט~$S$ בצורת המשפט~$⌘)S⌘($,
הכוללת את הסימן~$S$. גם כלל הגזירה השלישי מדגים רקורסיה, כאשר צורת המשפט~$S$
מוחלפת בצורת המשפט~$SS$. הדקדוק אינו מציין במפורש מהי צורת המשפט ההתחלתית,
אבל מי שמיומן בקריאת דקדוקים, יוכל לנחש כי צורה זו היא~$S$.

\subsection{דקוקים חסרי הקשר}
נהוג להגדיר דקדוקים חסרי הקשר כרביעיה,
המכילה את המרכיבים הבאים:
\begin{description}
✦ ]סימבולים[ זוהי קבוצה של סימנים, הקרויים לעיתים non-terminal symbols,
non-terminal characters, variables, syntactical categories, וגם verbs.
אנו נסמן קבוצה זו ב-$𝕍$. יש הדורשים כי~$𝕍$ תהיה סופית,
אולם דרישה זו מיותרת.
✦ ]סימנים סופיים[ זוהי קבוצה של סימנים, השונים מהסימבולים. קבוצה זו נקראת
לעיתים גם קבוצת ה-terminal symbols, או קבוצת ה-terminals. הגדרת הדקדוק מגדירה
  שפה פורמלית של מילים שכל אות בהן היא סימן סופי. אנו נסמן את
קבוצה זו ב-$Σ$.
✦ ]כללי גזירה[
✦ ]סימן התחלה[
\end{description}

\subsection{דוגמאות}

\דוגמה|שפת הסוגריים|
$Σ=❴⌘), ⌘(❵$,~$N=❴S❵$
\begin{equation}
  \label{eq:parenthesis}
  \begin{split}
    S &→ε ⏎
    S &→⌘)S⌘(⏎
    S &→SS ⏎
  \end{split}
\end{equation}

\דוגמה|שפת הפלינדרומים|
$Σ=❴⌘a, ⌘b, ⌘c❵$,~$N=❴S❵$
\begin{equation}
  \label{grammar:palindroms}
  \begin{split}
    S &→ε ⏎
    S &→⌘aS⌘a ⏎
    S &→⌘bS⌘b ⏎
    S &→⌘cS⌘c
  \end{split}
\end{equation}

\דוגמה|שפת הפונקציות הרציונליות|
\label{example:rationals}
$❴⌘1, ⌘I, ⌘(, ⌘), ⌘/, ⌘*, ⌘+, ⌘-❵$ \cref{eq:Q:alphabet}
\begin{equation}
  \label{eq:parenthesis}
  \begin{split}
    S &→⌘1 ⏎
    S &→⌘I ⏎
    S &→⌘)-S⌘(⏎
    S &→⌘)S⌘+S⌘(⏎
    S &→⌘)S⌘*S⌘(⏎
  \end{split}
\end{equation}

\דוגמה|הדקדוק של שפת העצים|
\label{example:grammar:re}
$\RE(Σ)$, השפה הפורמלית של הביטויים הרגולריים
מעל אלפאבית~$Σ=❴σ₁,σ₂,…,σₙ❵$
כפי שהוגדרה באמצעות כללי היסק
ב\פנה|definition:re| ניתנת להגדרה גם באמצעות דקדוק
מעל האלפאבית
$❴σ₁,σ₂,…,σₙ, ⌘., ⌘(, ⌘)❵$
\begin{equation}
  \label{eq:parenthesis}
  \begin{split}
    R &→σ₁ ⏎
    R &→σ₂ ⏎
    ⋮ ⏎
    R &→σₙ ⏎
    R &→⌘)R⌘.R⌘(
  \end{split}
\end{equation}

\דוגמה|הדקדוק של שפת הביטויים הרגולריים|
\label{example:grammar:re}
$\RE(Σ)$, השפה הפורמלית של הביטויים הרגולריים
מעל אלפאבית~$Σ=❴σ₁,σ₂,…,σₙ❵$
כפי שהוגדרה באמצעות כללי היסק
ב\פנה|definition:re| ניתנת להגדרה גם באמצעות דקדוק
מעל האלפאבית
$❴σ₁,σ₂,…,σₙ, ⌘|, ⌘;, ⌘*, ⌘(, ⌘)❵$
\begin{equation}
  \label{eq:parenthesis}
  \begin{split}
    R &→σ₁ ⏎
    R &→σ₂ ⏎
    ⋮ ⏎
    R &→σₙ ⏎
    R &→⌘)⌘(⏎
    R &→⌘)R R⌘(⏎
    R &→⌘)R ⌘| R⌘(⏎
    R &→⌘)R ⌘*⌘(
  \end{split}
\end{equation}
אינטואיטיבית, ד
ניתן להתסכל על
דקדוקי BNF
כוח הביטוי של ביטויים רגולריים הוא מוגבל ביותר. כך למשל, לא ניתן לבטא
באמצעות ביטוי רגולרי את הדרישה שהסוגריים בתכנית מאוזנים. לפיכך, השימוש
בביטויים
רגולריים מוגבל להגדרות פשוטות של אבני הבנין של השפה: משתנים, הערות, מספרים
וכו'. להגדרות מורכבות יותר, יש להשתמש במנגנון הידוע בשם דקדוק חסר הקשר
(Context Free Grammar), אשר נכתב בדרך כלל בשיטת הסימון הידועה בשם Backus Naur
Form או BNF. כתיב אחר לדקדוקים אלו הוא הדיאגרמות שתוארו לעיל.

הגדרת דקדוק בשיטת סימון זו מורכבת מארבעה חלקים:
\begin{enumerate}
✦ קבוצה של סימנים סופיים, Terminals. (ה-Terminals קרויים
לעיתים גם Tokens או אסימונים). הדקדוק מתאר שפה מעל האלפאבית
\item שיוצרים הסימנים הסופיים.
\item קבוצה של סימנים לא סופיים, Non Terminal Symbols, המשמשים
ככלי עזר להגדרת הדקדוק. סימני עזר אלו דומים מעט לשימוש בשמות
לביטויים רגולריים חלקיים, אלא, שהגדרתם של סימני העזר הללו
יכולה להיות רקורסיבית, וניתן להגדירן יותר מאשר פעם אחת.
\item קביעה של אחד מהסימנים הלא סופיים כסימן התחלה: Start Symbol
\item אוסף של כללי גזירה, כאשר לכלל גזירה יש שני חלקים: ראש הכלל
הכתוב בצד שמאל של הכלל, הוא תמיד סימן לא סופי, ואילו גוף הכלל
הכתוב בצידו הימני, הוא מילה (היכולה להיות ריקה) של סימנים
סופיים ולא סופיים. כללי הגזירה נכתבים כך שישנו חץ המוביל מראש
הכלל אל גופו. בפועל, נוהגים להשמיט את המרכיבים 1 עד 3 של
הגדרת הדקדוק ולהסתפק בכללי הגזירה לבדם. קל להבחין בין סימנים
סופיים ולא סופיים בכללי הגזירה, משום שסימן סופי לא יופיע
לעולם בראש כלל. גם סימן ההתחלה ברור בדרך כלל מההקשר.
הנה דוגמא:
\begin{align}
  S &→E ⏎
  E &→a E b ⏎
  E &→𝜺 ⏎
\end{align}
\end{enumerate}

נבחין בין דקדוקים
חסרי הקשר \E|(context free grammar (CFG))| ודקדוקים תלויי הקשר (כמו למשל
הדקדוק של שפת הסוגריים) ובין
\E|(context sensitiv grammar (CSG))|, שהם חזקים יותר מ-CFG, אבל, השימוש בהם
אינו כה נפוץ בהגדרות שפות תכנות (אך נפוץ יותר בניסיון להגדרות פורמליות של
הדקדוק של שפות טבעיות כמו עברית(.

נתאר גם את שיטת הכתיבה הנפוצה לדקדוקים הידועה בשם
Backus Naur ואת ההכללה שלה, הידועה כשם ENBF \E|(extended BNF)|.

\subsection{צורות משפט}
נזכר בכלל ההיסק \פנה|eq:Q:minus| בו נכתב
\begin{equation*}
   \infer{⌘)⌘-w⌘(∈L₁}{w∈L}⏎
\end{equation*}
אולם כדאי לשים לכך ש-$⌘)⌘-w⌘($ אינה בעצמה מילה מתוך האלפאבית
\פנה|eq:Q:alphabet|, ולכן היא בוודאי גם אינה מילה בשפה~$L₁$.
סדרה כמו~$⌘)⌘-w⌘($, המערבת אותיות מהאלפאבית ואותיות שאינן לקוחות ממנו,
נקראת \ע|צורת משפט|
(sentential forms).
לאות המופיעה בצורת משפט ואשר אינה לקוחה מהאלפאבית, קוראים סמל
(symbol).

צורת המשפט~$⌘)⌘-w⌘($, מציינת את כל המילים מעל האלפאבית \פנה|eq:Q:alphabet|
המתקבלות אם הסימבול~$w$ יוחלף במילה כלשהי מתוך אלפאבית זה, כלומר, כל המילים
המתחילות בסימן ⌘(, שמייד אחריו בא הסימן ⌘-
ןמסתיימות בסימן ⌘).
התנאי המגולם בכלל ההיסק
\begin{equation*}
   \infer{⌘)⌘-w⌘(∈L₁}{w∈L}⏎
\end{equation*}
אומר שהמילה המתקבלת מצורת המשפט~$⌘)⌘-w⌘($ שייכת לשפה~$L₁$ אם הסמל~$w$ יוחלף
במילה שגם היא שייכת לשפה~$L₁$.

צורות משפט מופיעות גם בכללי ההיסק \cref{eq:Q:plus}, \cref{eq:Q:times}
ו-\cref{eq:Q:times}. נשים לב לכך שצורות המשפט המופיעות בכללים אלו מכילות שני
סמלים ולא אחד. באופן כללי יותר, נבחר קבוצה אינסופית~$𝕊$ של סמלים, שהם סימנים
שאינם מופיעים באף אלפאבית, ונגדיר

\begin{definition}[צורות משפט מעל אלפאבית]
\label{definition:sentential}
צורת משפט מעל אלפאבית~$Σ$ היא מילה מתוך~$❨Σ∪𝕊❩^*$.
\end{definition}

כל צורת משפט~$α$ מעל אלפאבית~$Σ$ מגדירה, באופן טריביאלי, שפה פורמלית מעל~$Σ$.
זוהי השפה הפורמלית של כל המילים המתקבלות מ-$α$ על ידי בחירת מילה מ~$Σ^*$ בעבור
כל אחד מהסמלים המופיע ב-$α$ והחלפת כל מופע של סמל במילה המתאימה.

כך למשל, צורת המשפט~$www$ מתארת את השפה הפורמלית~$L₃$ של כל המילים שאפשר לחלק
אותן לשלוש מילים רצופות, זרות, וזהות. כמה מילים בשפה זו (מעל
האלפאבית~$❴⌘a,⌘b,⌘c❵$) הן:
\begin{equation}
  \label{eq:L3}
  L₃=❴ε, ⌘{aaa}, ⌘{bbb}, ⌘{ccc}, ⌘{aaaaaa}, ⌘{ababab}, ⌘{acacac}, ⌘{bababa},…❵.
\end{equation}

שימוש חשוב יותר בצורות משפט הוא בכללי גזירה. אם~$α$ ו~$β$, הן צורות משפט אזי
\begin{equation*}
α→β
\end{equation*}
הוא כלל גזירה שמשמעו החלפת צורת המשפט~$α$ בצורת המשפט~$β$. הפעלה של כלל גזירה
על צורת משפט~$ϕ$ יכולה להעשות אם ניתן למצוא בתוך~$ϕ$ מופע של צורת המשפט~$α$.
אם מופע כזה אכן נמצא, שכתוב של~$ϕ$ באמצעות כלל הגזירה~$α→β$, נעשה באמצעות
החלפת המופע האמור בצורת המשפט~$β$.

למשל
\begin{equation*}
  ⌘)Q⌘*⌘U⌘(→Q
\end{equation*}
הוא כלל גזירה המחליף את~$α=⌘)Q⌘*⌘U⌘($, צורת משפט באורך~4, בצורת
משפט~$α₂=Q$ באורך~1. כלל זה יכול להיות
מופעל על צורת המשפט
\begin{equation*}
ϕ=⌘)⌘-⌘)Q⌘*⌘U⌘(⌘(,
\end{equation*}
משום שהיא מכילה בתוכה כמילה חלקית את צורת המשפט~$α=⌘)Q⌘*⌘U⌘($.

מעט פורמלית יותר נאמר שניתן לחלק את~$ϕ$ לשלוש מילים רצופות,~$ϕ=ϕ₁ϕ₂ϕ₃$, כשהמילה
האמצעית שבהן היא צד שמאל של הכלל, כלומר~$ϕ₂=α$. בעבור הדוגמה שלנו, מתקיים
כי~$ϕ₀=⌘)⌘-$, ו-$ϕ₁=⌘(⌘($.

הפעלת הכלל
במקרה זה תחזיר את צורת המשפט
\begin{equation*}
⌘)⌘-Q⌘(.
\end{equation*}
ובאופן כללי, הפעלת הכלל~$α→β$ על המופע של~$α$ בתוך צורת המשפט~$ϕ$ המוגדר על ידי
הפירוק~$ϕ₁αϕ₃=ϕ$ מחזירה את צורת המשפט~$ϕ₁βϕ₃$.

נדגיש כי החיפוש אחר מופע של~$α$ בתוך~$ϕ$ אינו מסתכל על~$α$ כעל תבנית היכולה
להתאים למילים שונות, אלא כמילה שחייבת להימצא ככתבה וכלשונה. מסיבה זו, כלל
הגזירה
$⌘)Q⌘*⌘U⌘(→Q$ המכיל את הסמל~$Q$ בתוך צורת המשפט המצוייה בצידו השמאלי,
אינו יכול לפעול על המילה
\begin{equation*}
⌘)⌘)⌘-⌘)⌘I⌘*⌘U ⌘(⌘(⌘*⌘U⌘(
\end{equation*}
שהיא, צורת משפט שאינה מכילה אף לא סמל אחד, ובוודאי לא את הסמל~$Q$.

יתכן כי הצד השמאלי של כלל גזירה יופיע יותר מאשר פעם אחת בצורת
המשפט אותה הוא משכתב. כך למשל, ניתן להפעיל את כלל הגזירה
\begin{equation}
  \label{eq:parenthesis:rewrite}
  S→⌘) S ⌘(
\end{equation}
בשלושה מקומות שונים על צורת המשפט~$SSS$, ולקבל שלוש צורות משפט שונות.
\ע|גזירה שמאלית| היא גזירה בה כלל הגזירה מופעל במופע הראשון של~$α$ בתוך~$ϕ$.
באופן דומה, ניתן גם להגדיר \ע|גזירה ימנית| כגזירה בה כלל הגזירה מופעל במופע
הראשון של~$α$ בתוך~$ϕ$. גזירה שמאלית של~$SSS$ באמצעות כלל הגזירה~$S→⌘)S⌘($ תיתן
\begin{equation*}
  ⌘)S⌘(SS
\end{equation*}
ואילו גזירה ימנית תיתן
\begin{equation*}
  SS ⌘) S ⌘(.
\end{equation*}

§§ דקדוקים
בדוגמא זו בדקדוק ישנם שלושה כללי גזירה, אשר מקריאתם מתגלה כי:
\begin{enumerate}
✦
הסימנים הלא סופיים הם S וְ E
סימן ההתחלה הוא S
✦
הסימנים הלא סופיים הם a וְ b
\end{enumerate}

השפה המוגדרת על ידי הדקדוק חסר ההקשר הזה היא פשוטה ביותר, והיא מכילה את
כל הסדריות שבראשן יש מספר n (שיכול להיות 0) של a ואחריהם n מופעים של
הסימן b.
ניתן להוכיח (ולא נעשה זאת כאן), כי לא ניתן להגדיר שפה זו באמצעות ביטויים
רגולריים.

הנה דוגמא המהווה קטע של הדקדוק של שְׂפַת פסקל:

\begin{derivation}
  \begin{align}
    pascal-program→program identifier program-heading ; block . ⏎
    program-heading→𝜺 ⏎
    program-heading→(identifier-list) ⏎
    identifier-list→identifier ⏎
    identifier-list→identifier-list, identifier ⏎
    block→block1 ⏎
    block→label-declaration ; block1 ⏎
    block1→block2 ⏎
    block1→constant-declaration ; block2 ⏎
    block2→block3 ⏎
    block2→type-declaration ; block3 ⏎
    block3→block4 ⏎
    block3→variable-declaration ; block4 ⏎
    block4→block5 ⏎
    block4→proc-and-func-declaration ; block5 ⏎
    block5→begin statement-list end ⏎
…⏎
    type-declaration→type type-declarator ⏎
    type-declaration→type-declaration ; type-declarator ⏎
    type-declarator→identifier=type ⏎
…⏎
    type→identifier ⏎
    type→record field-list \=end=⏎
    field-list→𝜺 ⏎
  \end{align}
\end{derivation}

קל לזהות בהגדרת דקדוק זו את סימן ההתחלה. לשם הנוחות סימנו את הסימנים
הסופיים כגופן וצבע מיוחדים. מהגדרת הדקוק הזו אנו למדים למשל:
\begin{itemize}
✦ תכנית Pascal מתחילה תמיד במילה program ומסתיימת בסימן ". "
✦ לתכנית יש שם שאחריו יכולה להפועים רשימת מזהים העטופה בסוגריים עגולים.
✦ בראש התכנית יש ארבעה פרקי הגדרות החייבים להופיע בסדר קבוע: הגדרת תוויות,
✦ הגדרת קבועים, הגדרת טיפוסים והגדרת משתנים. כל אחד מארבעת מפרקי ההגדרות הוא
אופציונלי.
✦ בהגדרת פרק הטיפוסים אם מופיעה המילה type אזי אחריה חייבת להופיע הגדרת טיפוס
אחת לפחות.
✦ הגדרות הטיפוסים חייבות להיות מופרדות בסימן ";" כל הגדרת טיפוס בודדת מכילה
מזהה, סימן שיווין, ואחריו גוף הטיפוס, שיכול להיות מזהה או רשומה.

והנה דוגמא לתכנית פשוטה (וסרת טעם) המצייתת לדקדוק לעיל:

\end{itemize}
\begin{PASCAL}
program p;
type
  shalem=integer;
  student=record
end;
begin
end.
\end{PASCAL}

הגדרת הדקדוק של שְׂפַת תכנות באמצעות דקדוק חסר הקשר לא נועדה למען הדיוק
בלבד. ישנם כלים אוטמטיים המאפשרים תרגום של דקדוק חסר הקשר כזה לתכנית
ניתוח, אשר לוקחת טכסט נתון, ובונה בעבורו את אופן גזירתו מהדקדוק. אופן
הגזירה הזה נקרא "עץ גזירה" (ַParse Tree) אשר מהווה הוכחה כי הטכסט אמנם
נגזר מהדקדוק. הפורמליזם של דקדוק BNF חזק יותר מהפורמליזם של ביטויים
רגולריים שכן הוא מתיר הגדרות רקורסיביות. כך למשל, בהגדרת הדקדוק של Pascal
נמצא הגדרות רקורסיביות שבהן הסימן הלא סופי statement-list מוגדר באמצעות
הסימן הלא סופי statement ולהיפך:

\begin{align}
  statement-list→statement
  statement-list→statement-list ; statement
  statement→𝜺
  statement→variable :=expression
  statement→begin statement-list end
  statement→if expression then statement
  statement→if expression then statement else statement
  statement→case expression of case-list end
  statement→while expression do statement
  statement→repeat statement-list until expression
  statement→for varid :=for-list do statement
  statement→procid
  statement→procid(expression-list)
  statement→goto label
  statement→with record-variable-list do statement
  statement→label : statement
\end{align}

הגדרות רקורסיביות מעין אלו הינן חיוניות בהגדרת שפות תכנות מודרניות, אך הן אינן
ניתנות להיעשות בביטויים רגולריים. דקדוקי EBNF EBNF הוא קיצור של Extended BNF.
פורמליזם זה דומה בעיקרו לפורמליזם של דקדוק BNF, אלא שגופו של כלל הגזירה יכול
להיות ביטוי רגולרי מעל אוסף הסימנים, הסופיים והלא סופיים כאחד. שימוש בביטויים
רגולריים כאלו הוא בבחינת תַּחְבִּירִי סֻכָּר לדקדוקי BNF. ההרחבה עצמה אינה מאפשרת
הגדרת שפות פורמליות נוספות פרט לאלו הניתנות להגדרה בדקדוק BNF, אך ניתן באמצות
הרחבה זו להגדיר שפות פורמליות ביתר תמציתיות.

הנה שכתוב של קטע הדקדוק הראשון של Pascal שהבאנו כאן, תוך שימוש בשיטות הסימון
של EBNF.

\begin{align}
  Pascal -program→program identifier [(identifier {,identifier})] ; block .
  block→[label-declaration;]
  [constant-declaration;]
  [type-declaration;]
  [variable-declaration ;]
  begin statement-list end
…
  type-declaration→type ַtype-declarator {; type-declaration}
  type-declarator→identifier=type
  type→identifier | record field-list end
  field-list→𝜺
\end{align}
\endinput
כדאי לשים לב לכך שהכתיב של ביטויים רגולריים בגוף כלל הגזירה של EBNF הוא מעט
שונה. למעלה, בדוגמא הזו השתמשנו בכתיב על פיו * חזרה אפס או יותר פעמים מסומנת על
ידי עטיפה הביטוי החוזר בסוגריים מסולסלים, המעוצבים טיפוגרפית בדוגמא כך: {} כך
למשל תת הביטוי המופיע בגופו של כלל הגזירה הראשון לעיל
identifier {,identifier}
מציין רשימה של אחד או יותר מזהים המופרדים בפסיקים.
\begin{description}
✦ ביטוי אופציונלי עטוף בסוגריים מרובעים, המעוצבים טיפוגרפית בדוגמא כך: [] כך למשל תת הביטוי
[label-declaration;]
מציין שה label-declaration שאחריו יש סימן ; הוא אופציונלי.
עוד נשים לכך שהדוגמא מניחה כללי קדימות של האופרטורים היוצרים את הביטוי הרגולרי, בפרט
identifier | record field-list end
מתפרש כך:
identifier | (record field-list end)
ולא כך:
(identifier | record) field-list end
\end{description}

דקדוק ה-EBNF של שְׂפַת תכנות מסוימת עשוי להשתמש בשיטת סימון מעט אחרת ואולי אף כללי
קדימות אחרים. בדרך כלל, יכול הקורא הנבון להסיק את שיטת הסימון מתוך הקריאה,
ואילו הקורא הסכל יאלץ לעיין בנספח, בהקדמה או בתוספת אחרת למסמך הראשי, ואשר בהם
אולי תימצא הגדרה מדוייקת של שיטת הסימון.
